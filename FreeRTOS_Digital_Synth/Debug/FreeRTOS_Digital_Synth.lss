
FreeRTOS_Digital_Synth.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003380  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000006c  20000000  00003380  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000001fc  2000006c  000033ec  0001006c  2**2
                  ALLOC
  3 .stack        00002000  20000268  000035e8  0001006c  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  0001006c  2**0
                  CONTENTS, READONLY
  5 .comment      0000005b  00000000  00000000  00010094  2**0
                  CONTENTS, READONLY
  6 .debug_info   00023e49  00000000  00000000  000100ef  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003548  00000000  00000000  00033f38  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000a8b0  00000000  00000000  00037480  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000778  00000000  00000000  00041d30  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00001958  00000000  00000000  000424a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0001a995  00000000  00000000  00043e00  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000d5f1  00000000  00000000  0005e795  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000921c3  00000000  00000000  0006bd86  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00001a20  00000000  00000000  000fdf4c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_sfixed>:
       0:	20002268 	.word	0x20002268
       4:	00001fd5 	.word	0x00001fd5
       8:	00001fd1 	.word	0x00001fd1
       c:	00001fd1 	.word	0x00001fd1
	...
      2c:	000005c5 	.word	0x000005c5
	...
      38:	000005ed 	.word	0x000005ed
      3c:	00000631 	.word	0x00000631
      40:	00001fd1 	.word	0x00001fd1
      44:	00001fd1 	.word	0x00001fd1
      48:	00001fd1 	.word	0x00001fd1
      4c:	00001fd1 	.word	0x00001fd1
      50:	00001fd1 	.word	0x00001fd1
      54:	00001fd1 	.word	0x00001fd1
      58:	00001fd1 	.word	0x00001fd1
      5c:	00001fd1 	.word	0x00001fd1
      60:	00001fd1 	.word	0x00001fd1
      64:	00001839 	.word	0x00001839
      68:	00001849 	.word	0x00001849
      6c:	00001859 	.word	0x00001859
      70:	00001869 	.word	0x00001869
      74:	00001879 	.word	0x00001879
      78:	00001889 	.word	0x00001889
      7c:	00001fd1 	.word	0x00001fd1
      80:	00001fd1 	.word	0x00001fd1
      84:	00001fd1 	.word	0x00001fd1
      88:	00001fd1 	.word	0x00001fd1
      8c:	00001fd1 	.word	0x00001fd1
      90:	00001fd1 	.word	0x00001fd1
      94:	00001fd1 	.word	0x00001fd1
      98:	00001fd1 	.word	0x00001fd1
      9c:	00001fd1 	.word	0x00001fd1
      a0:	00001fd1 	.word	0x00001fd1
      a4:	00001fd1 	.word	0x00001fd1
      a8:	00001fd1 	.word	0x00001fd1
      ac:	00001fd1 	.word	0x00001fd1
      b0:	00000000 	.word	0x00000000

000000b4 <__do_global_dtors_aux>:
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
      b8:	7823      	ldrb	r3, [r4, #0]
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	2000006c 	.word	0x2000006c
      d4:	00000000 	.word	0x00000000
      d8:	00003380 	.word	0x00003380

000000dc <frame_dummy>:
      dc:	b508      	push	{r3, lr}
      de:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4807      	ldr	r0, [pc, #28]	; (104 <frame_dummy+0x28>)
      e6:	4908      	ldr	r1, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd08      	pop	{r3, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
     104:	00003380 	.word	0x00003380
     108:	20000070 	.word	0x20000070
     10c:	00003380 	.word	0x00003380
     110:	00000000 	.word	0x00000000

00000114 <_sercom_get_sync_baud_val>:
 */
enum status_code _sercom_get_sync_baud_val(
		const uint32_t baudrate,
		const uint32_t external_clock,
		uint16_t *const baudvalue)
{
     114:	b510      	push	{r4, lr}
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
     116:	0849      	lsrs	r1, r1, #1
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
     118:	2340      	movs	r3, #64	; 0x40
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
     11a:	2400      	movs	r4, #0
     11c:	4281      	cmp	r1, r0
     11e:	d202      	bcs.n	126 <_sercom_get_sync_baud_val+0x12>
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	} else {
		*baudvalue = baud_calculated;
		return STATUS_OK;
	}
}
     120:	1c18      	adds	r0, r3, #0
     122:	bd10      	pop	{r4, pc}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
		clock_value = clock_value - baudrate;
		baud_calculated++;
     124:	1c1c      	adds	r4, r3, #0
     126:	1c63      	adds	r3, r4, #1
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
		clock_value = clock_value - baudrate;
     128:	1a09      	subs	r1, r1, r0
		baud_calculated++;
     12a:	b29b      	uxth	r3, r3
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
     12c:	4288      	cmp	r0, r1
     12e:	d9f9      	bls.n	124 <_sercom_get_sync_baud_val+0x10>


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
     130:	2340      	movs	r3, #64	; 0x40
	}
	baud_calculated = baud_calculated - 1;

	/* Check if BAUD value is more than 255, which is maximum
	 * for synchronous mode */
	if (baud_calculated > 0xFF) {
     132:	2cff      	cmp	r4, #255	; 0xff
     134:	d8f4      	bhi.n	120 <_sercom_get_sync_baud_val+0xc>
		/* Return with an error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	} else {
		*baudvalue = baud_calculated;
     136:	8014      	strh	r4, [r2, #0]
		return STATUS_OK;
     138:	2300      	movs	r3, #0
     13a:	e7f1      	b.n	120 <_sercom_get_sync_baud_val+0xc>

0000013c <_sercom_get_async_baud_val>:
		const uint32_t baudrate,
		const uint32_t peripheral_clock,
		uint16_t *const baudval,
		enum sercom_asynchronous_operation_mode mode,
		enum sercom_asynchronous_sample_num sample_num)
{
     13c:	b5f0      	push	{r4, r5, r6, r7, lr}
     13e:	4656      	mov	r6, sl
     140:	464d      	mov	r5, r9
     142:	4644      	mov	r4, r8
     144:	465f      	mov	r7, fp
     146:	b4f0      	push	{r4, r5, r6, r7}
     148:	1c04      	adds	r4, r0, #0
	uint8_t baud_fp;
	uint32_t baud_int = 0;
	uint64_t temp1, temp2;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
     14a:	1c25      	adds	r5, r4, #0
		const uint32_t baudrate,
		const uint32_t peripheral_clock,
		uint16_t *const baudval,
		enum sercom_asynchronous_operation_mode mode,
		enum sercom_asynchronous_sample_num sample_num)
{
     14c:	b089      	sub	sp, #36	; 0x24
     14e:	a812      	add	r0, sp, #72	; 0x48
     150:	7806      	ldrb	r6, [r0, #0]
	uint64_t temp1, temp2;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
     152:	2040      	movs	r0, #64	; 0x40
	uint8_t baud_fp;
	uint32_t baud_int = 0;
	uint64_t temp1, temp2;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
     154:	4375      	muls	r5, r6
     156:	428d      	cmp	r5, r1
     158:	d906      	bls.n	168 <_sercom_get_async_baud_val+0x2c>
		baud_calculated = baud_int | (baud_fp << 13);
	}

	*baudval = baud_calculated;
	return STATUS_OK;
}
     15a:	b009      	add	sp, #36	; 0x24
     15c:	bc3c      	pop	{r2, r3, r4, r5}
     15e:	4690      	mov	r8, r2
     160:	4699      	mov	r9, r3
     162:	46a2      	mov	sl, r4
     164:	46ab      	mov	fp, r5
     166:	bdf0      	pop	{r4, r5, r6, r7, pc}
     168:	9206      	str	r2, [sp, #24]
     16a:	1c0d      	adds	r5, r1, #0
     16c:	1c22      	adds	r2, r4, #0
	if ((baudrate * sample_num) > peripheral_clock) {
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	}

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
     16e:	2b00      	cmp	r3, #0
     170:	d14f      	bne.n	212 <_sercom_get_async_baud_val+0xd6>
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
     172:	1c30      	adds	r0, r6, #0
     174:	4c6a      	ldr	r4, [pc, #424]	; (320 <_sercom_get_async_baud_val+0x1e4>)
     176:	2100      	movs	r1, #0
     178:	47a0      	blx	r4
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
     17a:	2200      	movs	r2, #0
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	}

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
     17c:	4681      	mov	r9, r0
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
     17e:	4690      	mov	r8, r2
     180:	2000      	movs	r0, #0
	}

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
     182:	2300      	movs	r3, #0
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
     184:	2100      	movs	r1, #0
	for (i = 63; i >= 0; i--) {
     186:	263f      	movs	r6, #63	; 0x3f
		bit_shift = (uint64_t)1 << i;
     188:	3220      	adds	r2, #32
     18a:	4692      	mov	sl, r2
     18c:	3a1f      	subs	r2, #31
	}

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
     18e:	9502      	str	r5, [sp, #8]
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
		bit_shift = (uint64_t)1 << i;
     190:	1c04      	adds	r4, r0, #0
	}

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
     192:	9303      	str	r3, [sp, #12]
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
		bit_shift = (uint64_t)1 << i;
     194:	4640      	mov	r0, r8
     196:	4694      	mov	ip, r2
     198:	46c8      	mov	r8, r9
     19a:	1c0d      	adds	r5, r1, #0
     19c:	46b1      	mov	r9, r6
     19e:	e005      	b.n	1ac <_sercom_get_async_baud_val+0x70>
     1a0:	428a      	cmp	r2, r1
     1a2:	d04b      	beq.n	23c <_sercom_get_async_baud_val+0x100>
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
     1a4:	464a      	mov	r2, r9
     1a6:	1e51      	subs	r1, r2, #1
     1a8:	4689      	mov	r9, r1
     1aa:	d32f      	bcc.n	20c <_sercom_get_async_baud_val+0xd0>
		bit_shift = (uint64_t)1 << i;
     1ac:	2120      	movs	r1, #32
     1ae:	464a      	mov	r2, r9
     1b0:	4249      	negs	r1, r1
     1b2:	1852      	adds	r2, r2, r1
     1b4:	d43b      	bmi.n	22e <_sercom_get_async_baud_val+0xf2>
     1b6:	4661      	mov	r1, ip
     1b8:	4091      	lsls	r1, r2
     1ba:	1c0a      	adds	r2, r1, #0
     1bc:	464e      	mov	r6, r9
     1be:	4661      	mov	r1, ip

		r = r << 1;
     1c0:	1924      	adds	r4, r4, r4
     1c2:	416d      	adcs	r5, r5
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
		bit_shift = (uint64_t)1 << i;
     1c4:	40b1      	lsls	r1, r6
     1c6:	4647      	mov	r7, r8

		r = r << 1;

		if (n & bit_shift) {
			r |= 0x01;
     1c8:	4666      	mov	r6, ip
     1ca:	4326      	orrs	r6, r4
     1cc:	4217      	tst	r7, r2
     1ce:	d000      	beq.n	1d2 <_sercom_get_async_baud_val+0x96>
     1d0:	1c34      	adds	r4, r6, #0
		}

		if (r >= d) {
			r = r - d;
     1d2:	9e02      	ldr	r6, [sp, #8]
     1d4:	9f03      	ldr	r7, [sp, #12]
     1d6:	9501      	str	r5, [sp, #4]
     1d8:	9400      	str	r4, [sp, #0]
     1da:	9c00      	ldr	r4, [sp, #0]
     1dc:	9d01      	ldr	r5, [sp, #4]
     1de:	1ba4      	subs	r4, r4, r6
     1e0:	41bd      	sbcs	r5, r7
     1e2:	1c3e      	adds	r6, r7, #0
     1e4:	9f01      	ldr	r7, [sp, #4]
			q |= bit_shift;
     1e6:	4319      	orrs	r1, r3
     1e8:	4302      	orrs	r2, r0
     1ea:	42be      	cmp	r6, r7
     1ec:	d81c      	bhi.n	228 <_sercom_get_async_baud_val+0xec>
     1ee:	9e03      	ldr	r6, [sp, #12]
     1f0:	42be      	cmp	r6, r7
     1f2:	d015      	beq.n	220 <_sercom_get_async_baud_val+0xe4>
     1f4:	1c0b      	adds	r3, r1, #0
     1f6:	1c10      	adds	r0, r2, #0
     1f8:	9901      	ldr	r1, [sp, #4]
     1fa:	9a03      	ldr	r2, [sp, #12]
     1fc:	428a      	cmp	r2, r1
     1fe:	d9cf      	bls.n	1a0 <_sercom_get_async_baud_val+0x64>
     200:	9c00      	ldr	r4, [sp, #0]
     202:	9d01      	ldr	r5, [sp, #4]
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
     204:	464a      	mov	r2, r9
     206:	1e51      	subs	r1, r2, #1
     208:	4689      	mov	r9, r1
     20a:	d2cf      	bcs.n	1ac <_sercom_get_async_baud_val+0x70>

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
     20c:	425c      	negs	r4, r3
     20e:	0c24      	lsrs	r4, r4, #16
     210:	e002      	b.n	218 <_sercom_get_async_baud_val+0xdc>
     212:	2400      	movs	r4, #0
		baud_calculated = (65536 * scale) >> SHIFT;
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
     214:	2b01      	cmp	r3, #1
     216:	d018      	beq.n	24a <_sercom_get_async_baud_val+0x10e>
			return STATUS_ERR_BAUDRATE_UNAVAILABLE;
		}
		baud_calculated = baud_int | (baud_fp << 13);
	}

	*baudval = baud_calculated;
     218:	9b06      	ldr	r3, [sp, #24]
	return STATUS_OK;
     21a:	2000      	movs	r0, #0
			return STATUS_ERR_BAUDRATE_UNAVAILABLE;
		}
		baud_calculated = baud_int | (baud_fp << 13);
	}

	*baudval = baud_calculated;
     21c:	801c      	strh	r4, [r3, #0]
	return STATUS_OK;
     21e:	e79c      	b.n	15a <_sercom_get_async_baud_val+0x1e>
     220:	9e02      	ldr	r6, [sp, #8]
     222:	9f00      	ldr	r7, [sp, #0]
     224:	42be      	cmp	r6, r7
     226:	d9e5      	bls.n	1f4 <_sercom_get_async_baud_val+0xb8>
     228:	1c19      	adds	r1, r3, #0
     22a:	1c02      	adds	r2, r0, #0
     22c:	e7e2      	b.n	1f4 <_sercom_get_async_baud_val+0xb8>
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
		bit_shift = (uint64_t)1 << i;
     22e:	4649      	mov	r1, r9
     230:	4652      	mov	r2, sl
     232:	1a52      	subs	r2, r2, r1
     234:	4661      	mov	r1, ip
     236:	40d1      	lsrs	r1, r2
     238:	1c0a      	adds	r2, r1, #0
     23a:	e7bf      	b.n	1bc <_sercom_get_async_baud_val+0x80>
     23c:	9a02      	ldr	r2, [sp, #8]
     23e:	9900      	ldr	r1, [sp, #0]
     240:	428a      	cmp	r2, r1
     242:	d9af      	bls.n	1a4 <_sercom_get_async_baud_val+0x68>
     244:	9c00      	ldr	r4, [sp, #0]
     246:	9d01      	ldr	r5, [sp, #4]
     248:	e7dc      	b.n	204 <_sercom_get_async_baud_val+0xc8>
     24a:	0f4b      	lsrs	r3, r1, #29
     24c:	4698      	mov	r8, r3
     24e:	00cb      	lsls	r3, r1, #3
     250:	469a      	mov	sl, r3
     252:	1c30      	adds	r0, r6, #0
     254:	2300      	movs	r3, #0
     256:	2100      	movs	r1, #0
     258:	4c31      	ldr	r4, [pc, #196]	; (320 <_sercom_get_async_baud_val+0x1e4>)
     25a:	47a0      	blx	r4
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
     25c:	2300      	movs	r3, #0
     25e:	9305      	str	r3, [sp, #20]
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
		bit_shift = (uint64_t)1 << i;
     260:	3301      	adds	r3, #1
     262:	469c      	mov	ip, r3
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
			temp2 = ((uint64_t)baudrate * sample_num);
			baud_int = long_division(temp1, temp2);
			baud_int -= baud_fp;
			baud_int = baud_int / BAUD_FP_MAX;
			if(baud_int < BAUD_INT_MAX) {
     264:	46c1      	mov	r9, r8
     266:	466b      	mov	r3, sp
     268:	7d1b      	ldrb	r3, [r3, #20]
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
     26a:	2200      	movs	r2, #0
     26c:	9307      	str	r3, [sp, #28]
     26e:	2300      	movs	r3, #0
	for (i = 63; i >= 0; i--) {
     270:	273f      	movs	r7, #63	; 0x3f
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
     272:	4698      	mov	r8, r3
     274:	2300      	movs	r3, #0
     276:	e018      	b.n	2aa <_sercom_get_async_baud_val+0x16e>
     278:	465c      	mov	r4, fp
     27a:	1c1d      	adds	r5, r3, #0
     27c:	1c22      	adds	r2, r4, #0
     27e:	1c2b      	adds	r3, r5, #0
		if (n & bit_shift) {
			r |= 0x01;
		}

		if (r >= d) {
			r = r - d;
     280:	1a24      	subs	r4, r4, r0
     282:	418d      	sbcs	r5, r1
			q |= bit_shift;
     284:	4646      	mov	r6, r8
		if (n & bit_shift) {
			r |= 0x01;
		}

		if (r >= d) {
			r = r - d;
     286:	9402      	str	r4, [sp, #8]
     288:	9503      	str	r5, [sp, #12]
			q |= bit_shift;
     28a:	9c00      	ldr	r4, [sp, #0]
     28c:	4334      	orrs	r4, r6
     28e:	1c26      	adds	r6, r4, #0
     290:	4299      	cmp	r1, r3
     292:	d838      	bhi.n	306 <_sercom_get_async_baud_val+0x1ca>
     294:	d035      	beq.n	302 <_sercom_get_async_baud_val+0x1c6>
     296:	46b0      	mov	r8, r6
     298:	4299      	cmp	r1, r3
     29a:	d820      	bhi.n	2de <_sercom_get_async_baud_val+0x1a2>
     29c:	d01d      	beq.n	2da <_sercom_get_async_baud_val+0x19e>
     29e:	9c02      	ldr	r4, [sp, #8]
     2a0:	9d03      	ldr	r5, [sp, #12]
     2a2:	1c22      	adds	r2, r4, #0
     2a4:	1c2b      	adds	r3, r5, #0
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
     2a6:	3f01      	subs	r7, #1
     2a8:	d31f      	bcc.n	2ea <_sercom_get_async_baud_val+0x1ae>
		bit_shift = (uint64_t)1 << i;
     2aa:	2420      	movs	r4, #32
     2ac:	4264      	negs	r4, r4
     2ae:	193d      	adds	r5, r7, r4
     2b0:	d42b      	bmi.n	30a <_sercom_get_async_baud_val+0x1ce>
     2b2:	4664      	mov	r4, ip
     2b4:	40ac      	lsls	r4, r5
     2b6:	1c25      	adds	r5, r4, #0

		r = r << 1;
     2b8:	1892      	adds	r2, r2, r2
     2ba:	415b      	adcs	r3, r3

		if (n & bit_shift) {
			r |= 0x01;
     2bc:	4664      	mov	r4, ip
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
		bit_shift = (uint64_t)1 << i;
     2be:	4666      	mov	r6, ip

		r = r << 1;

		if (n & bit_shift) {
			r |= 0x01;
     2c0:	4314      	orrs	r4, r2
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
		bit_shift = (uint64_t)1 << i;
     2c2:	40be      	lsls	r6, r7

		r = r << 1;

		if (n & bit_shift) {
			r |= 0x01;
     2c4:	46a3      	mov	fp, r4
	for (i = 63; i >= 0; i--) {
		bit_shift = (uint64_t)1 << i;

		r = r << 1;

		if (n & bit_shift) {
     2c6:	4654      	mov	r4, sl
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
		bit_shift = (uint64_t)1 << i;
     2c8:	9600      	str	r6, [sp, #0]

		r = r << 1;

		if (n & bit_shift) {
     2ca:	4034      	ands	r4, r6
     2cc:	464e      	mov	r6, r9
     2ce:	4035      	ands	r5, r6
     2d0:	432c      	orrs	r4, r5
     2d2:	d1d1      	bne.n	278 <_sercom_get_async_baud_val+0x13c>
     2d4:	1c14      	adds	r4, r2, #0
     2d6:	1c1d      	adds	r5, r3, #0
     2d8:	e7d0      	b.n	27c <_sercom_get_async_baud_val+0x140>
     2da:	4290      	cmp	r0, r2
     2dc:	d9df      	bls.n	29e <_sercom_get_async_baud_val+0x162>
     2de:	1c14      	adds	r4, r2, #0
     2e0:	1c1d      	adds	r5, r3, #0
     2e2:	1c22      	adds	r2, r4, #0
     2e4:	1c2b      	adds	r3, r5, #0
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
     2e6:	3f01      	subs	r7, #1
     2e8:	d2df      	bcs.n	2aa <_sercom_get_async_baud_val+0x16e>
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
			temp2 = ((uint64_t)baudrate * sample_num);
			baud_int = long_division(temp1, temp2);
			baud_int -= baud_fp;
     2ea:	9b05      	ldr	r3, [sp, #20]
			baud_int = baud_int / BAUD_FP_MAX;
			if(baud_int < BAUD_INT_MAX) {
     2ec:	4a0d      	ldr	r2, [pc, #52]	; (324 <_sercom_get_async_baud_val+0x1e8>)
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
			temp2 = ((uint64_t)baudrate * sample_num);
			baud_int = long_division(temp1, temp2);
			baud_int -= baud_fp;
     2ee:	1af6      	subs	r6, r6, r3
			baud_int = baud_int / BAUD_FP_MAX;
     2f0:	08f6      	lsrs	r6, r6, #3
			if(baud_int < BAUD_INT_MAX) {
     2f2:	4296      	cmp	r6, r2
     2f4:	d90f      	bls.n	316 <_sercom_get_async_baud_val+0x1da>
     2f6:	3301      	adds	r3, #1
     2f8:	9305      	str	r3, [sp, #20]
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
     2fa:	2b08      	cmp	r3, #8
     2fc:	d1b3      	bne.n	266 <_sercom_get_async_baud_val+0x12a>
	uint64_t temp1, temp2;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
     2fe:	2040      	movs	r0, #64	; 0x40
     300:	e72b      	b.n	15a <_sercom_get_async_baud_val+0x1e>
     302:	4290      	cmp	r0, r2
     304:	d9c7      	bls.n	296 <_sercom_get_async_baud_val+0x15a>
     306:	4646      	mov	r6, r8
     308:	e7c5      	b.n	296 <_sercom_get_async_baud_val+0x15a>
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
		bit_shift = (uint64_t)1 << i;
     30a:	2420      	movs	r4, #32
     30c:	1be5      	subs	r5, r4, r7
     30e:	4664      	mov	r4, ip
     310:	40ec      	lsrs	r4, r5
     312:	1c25      	adds	r5, r4, #0
     314:	e7d0      	b.n	2b8 <_sercom_get_async_baud_val+0x17c>
			}
		}
		if(baud_fp == BAUD_FP_MAX) {
			return STATUS_ERR_BAUDRATE_UNAVAILABLE;
		}
		baud_calculated = baud_int | (baud_fp << 13);
     316:	9b07      	ldr	r3, [sp, #28]
     318:	035c      	lsls	r4, r3, #13
     31a:	4334      	orrs	r4, r6
     31c:	b2a4      	uxth	r4, r4
     31e:	e77b      	b.n	218 <_sercom_get_async_baud_val+0xdc>
     320:	00002759 	.word	0x00002759
     324:	00001fff 	.word	0x00001fff

00000328 <sercom_set_gclk_generator>:
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
     328:	b530      	push	{r4, r5, lr}
	/* Check if valid option */
	if (!_sercom_config.generator_is_set || force_change) {
     32a:	4c0e      	ldr	r4, [pc, #56]	; (364 <sercom_set_gclk_generator+0x3c>)
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
     32c:	b083      	sub	sp, #12
	/* Check if valid option */
	if (!_sercom_config.generator_is_set || force_change) {
     32e:	7823      	ldrb	r3, [r4, #0]
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
     330:	1c05      	adds	r5, r0, #0
	/* Check if valid option */
	if (!_sercom_config.generator_is_set || force_change) {
     332:	2b00      	cmp	r3, #0
     334:	d006      	beq.n	344 <sercom_set_gclk_generator+0x1c>
     336:	2900      	cmp	r1, #0
     338:	d104      	bne.n	344 <sercom_set_gclk_generator+0x1c>
		/* Save config */
		_sercom_config.generator_source = generator_source;
		_sercom_config.generator_is_set = true;

		return STATUS_OK;
	} else if (generator_source == _sercom_config.generator_source) {
     33a:	7863      	ldrb	r3, [r4, #1]
     33c:	4283      	cmp	r3, r0
     33e:	d00f      	beq.n	360 <sercom_set_gclk_generator+0x38>
		/* Return status OK if same config */
		return STATUS_OK;
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
     340:	201d      	movs	r0, #29
     342:	e00b      	b.n	35c <sercom_set_gclk_generator+0x34>
	/* Check if valid option */
	if (!_sercom_config.generator_is_set || force_change) {
		/* Create and fill a GCLK configuration structure for the new config */
		struct system_gclk_chan_config gclk_chan_conf;
		system_gclk_chan_get_config_defaults(&gclk_chan_conf);
		gclk_chan_conf.source_generator = generator_source;
     344:	a901      	add	r1, sp, #4
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
     346:	2013      	movs	r0, #19
     348:	4b07      	ldr	r3, [pc, #28]	; (368 <sercom_set_gclk_generator+0x40>)
	/* Check if valid option */
	if (!_sercom_config.generator_is_set || force_change) {
		/* Create and fill a GCLK configuration structure for the new config */
		struct system_gclk_chan_config gclk_chan_conf;
		system_gclk_chan_get_config_defaults(&gclk_chan_conf);
		gclk_chan_conf.source_generator = generator_source;
     34a:	700d      	strb	r5, [r1, #0]
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
     34c:	4798      	blx	r3
		system_gclk_chan_enable(SERCOM_GCLK_ID);
     34e:	2013      	movs	r0, #19
     350:	4b06      	ldr	r3, [pc, #24]	; (36c <sercom_set_gclk_generator+0x44>)
     352:	4798      	blx	r3

		/* Save config */
		_sercom_config.generator_source = generator_source;
		_sercom_config.generator_is_set = true;
     354:	2301      	movs	r3, #1

		return STATUS_OK;
     356:	2000      	movs	r0, #0
		gclk_chan_conf.source_generator = generator_source;
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
		system_gclk_chan_enable(SERCOM_GCLK_ID);

		/* Save config */
		_sercom_config.generator_source = generator_source;
     358:	7065      	strb	r5, [r4, #1]
		_sercom_config.generator_is_set = true;
     35a:	7023      	strb	r3, [r4, #0]
		return STATUS_OK;
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
}
     35c:	b003      	add	sp, #12
     35e:	bd30      	pop	{r4, r5, pc}
		_sercom_config.generator_is_set = true;

		return STATUS_OK;
	} else if (generator_source == _sercom_config.generator_source) {
		/* Return status OK if same config */
		return STATUS_OK;
     360:	2000      	movs	r0, #0
     362:	e7fb      	b.n	35c <sercom_set_gclk_generator+0x34>
     364:	20000088 	.word	0x20000088
     368:	00001d99 	.word	0x00001d99
     36c:	00001dfd 	.word	0x00001dfd

00000370 <_sercom_get_default_pad>:
 */
uint32_t _sercom_get_default_pad(
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
     370:	4b3a      	ldr	r3, [pc, #232]	; (45c <_sercom_get_default_pad+0xec>)
     372:	4298      	cmp	r0, r3
     374:	d043      	beq.n	3fe <_sercom_get_default_pad+0x8e>
     376:	d90a      	bls.n	38e <_sercom_get_default_pad+0x1e>
     378:	4b39      	ldr	r3, [pc, #228]	; (460 <_sercom_get_default_pad+0xf0>)
     37a:	4298      	cmp	r0, r3
     37c:	d017      	beq.n	3ae <_sercom_get_default_pad+0x3e>
     37e:	4b39      	ldr	r3, [pc, #228]	; (464 <_sercom_get_default_pad+0xf4>)
     380:	4298      	cmp	r0, r3
     382:	d032      	beq.n	3ea <_sercom_get_default_pad+0x7a>
     384:	4b38      	ldr	r3, [pc, #224]	; (468 <_sercom_get_default_pad+0xf8>)
     386:	4298      	cmp	r0, r3
     388:	d01b      	beq.n	3c2 <_sercom_get_default_pad+0x52>
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
	}

	Assert(false);
	return 0;
     38a:	2000      	movs	r0, #0
}
     38c:	4770      	bx	lr
 */
uint32_t _sercom_get_default_pad(
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
     38e:	4b37      	ldr	r3, [pc, #220]	; (46c <_sercom_get_default_pad+0xfc>)
     390:	4298      	cmp	r0, r3
     392:	d020      	beq.n	3d6 <_sercom_get_default_pad+0x66>
     394:	4b36      	ldr	r3, [pc, #216]	; (470 <_sercom_get_default_pad+0x100>)
     396:	4298      	cmp	r0, r3
     398:	d1f7      	bne.n	38a <_sercom_get_default_pad+0x1a>
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     39a:	2901      	cmp	r1, #1
     39c:	d043      	beq.n	426 <_sercom_get_default_pad+0xb6>
     39e:	2900      	cmp	r1, #0
     3a0:	d03f      	beq.n	422 <_sercom_get_default_pad+0xb2>
     3a2:	2902      	cmp	r1, #2
     3a4:	d03b      	beq.n	41e <_sercom_get_default_pad+0xae>
     3a6:	2903      	cmp	r1, #3
     3a8:	d1ef      	bne.n	38a <_sercom_get_default_pad+0x1a>
     3aa:	4832      	ldr	r0, [pc, #200]	; (474 <_sercom_get_default_pad+0x104>)
     3ac:	e7ee      	b.n	38c <_sercom_get_default_pad+0x1c>
     3ae:	2901      	cmp	r1, #1
     3b0:	d031      	beq.n	416 <_sercom_get_default_pad+0xa6>
     3b2:	2900      	cmp	r1, #0
     3b4:	d02d      	beq.n	412 <_sercom_get_default_pad+0xa2>
     3b6:	2902      	cmp	r1, #2
     3b8:	d02f      	beq.n	41a <_sercom_get_default_pad+0xaa>
     3ba:	2903      	cmp	r1, #3
     3bc:	d1e5      	bne.n	38a <_sercom_get_default_pad+0x1a>
     3be:	482e      	ldr	r0, [pc, #184]	; (478 <_sercom_get_default_pad+0x108>)
     3c0:	e7e4      	b.n	38c <_sercom_get_default_pad+0x1c>
     3c2:	2901      	cmp	r1, #1
     3c4:	d03f      	beq.n	446 <_sercom_get_default_pad+0xd6>
     3c6:	2900      	cmp	r1, #0
     3c8:	d03b      	beq.n	442 <_sercom_get_default_pad+0xd2>
     3ca:	2902      	cmp	r1, #2
     3cc:	d037      	beq.n	43e <_sercom_get_default_pad+0xce>
     3ce:	2903      	cmp	r1, #3
     3d0:	d1db      	bne.n	38a <_sercom_get_default_pad+0x1a>
     3d2:	482a      	ldr	r0, [pc, #168]	; (47c <_sercom_get_default_pad+0x10c>)
     3d4:	e7da      	b.n	38c <_sercom_get_default_pad+0x1c>
     3d6:	2901      	cmp	r1, #1
     3d8:	d03d      	beq.n	456 <_sercom_get_default_pad+0xe6>
     3da:	2900      	cmp	r1, #0
     3dc:	d039      	beq.n	452 <_sercom_get_default_pad+0xe2>
     3de:	2902      	cmp	r1, #2
     3e0:	d02b      	beq.n	43a <_sercom_get_default_pad+0xca>
     3e2:	2903      	cmp	r1, #3
     3e4:	d1d1      	bne.n	38a <_sercom_get_default_pad+0x1a>
     3e6:	4826      	ldr	r0, [pc, #152]	; (480 <_sercom_get_default_pad+0x110>)
     3e8:	e7d0      	b.n	38c <_sercom_get_default_pad+0x1c>
     3ea:	2901      	cmp	r1, #1
     3ec:	d023      	beq.n	436 <_sercom_get_default_pad+0xc6>
     3ee:	2900      	cmp	r1, #0
     3f0:	d01f      	beq.n	432 <_sercom_get_default_pad+0xc2>
     3f2:	2902      	cmp	r1, #2
     3f4:	d01b      	beq.n	42e <_sercom_get_default_pad+0xbe>
     3f6:	2903      	cmp	r1, #3
     3f8:	d1c7      	bne.n	38a <_sercom_get_default_pad+0x1a>
     3fa:	4822      	ldr	r0, [pc, #136]	; (484 <_sercom_get_default_pad+0x114>)
     3fc:	e7c6      	b.n	38c <_sercom_get_default_pad+0x1c>
     3fe:	2901      	cmp	r1, #1
     400:	d025      	beq.n	44e <_sercom_get_default_pad+0xde>
     402:	2900      	cmp	r1, #0
     404:	d021      	beq.n	44a <_sercom_get_default_pad+0xda>
     406:	2902      	cmp	r1, #2
     408:	d00f      	beq.n	42a <_sercom_get_default_pad+0xba>
     40a:	2903      	cmp	r1, #3
     40c:	d1bd      	bne.n	38a <_sercom_get_default_pad+0x1a>
     40e:	481e      	ldr	r0, [pc, #120]	; (488 <_sercom_get_default_pad+0x118>)
     410:	e7bc      	b.n	38c <_sercom_get_default_pad+0x1c>
     412:	481e      	ldr	r0, [pc, #120]	; (48c <_sercom_get_default_pad+0x11c>)
     414:	e7ba      	b.n	38c <_sercom_get_default_pad+0x1c>
     416:	481e      	ldr	r0, [pc, #120]	; (490 <_sercom_get_default_pad+0x120>)
     418:	e7b8      	b.n	38c <_sercom_get_default_pad+0x1c>
     41a:	481e      	ldr	r0, [pc, #120]	; (494 <_sercom_get_default_pad+0x124>)
     41c:	e7b6      	b.n	38c <_sercom_get_default_pad+0x1c>
     41e:	481e      	ldr	r0, [pc, #120]	; (498 <_sercom_get_default_pad+0x128>)
     420:	e7b4      	b.n	38c <_sercom_get_default_pad+0x1c>
     422:	2003      	movs	r0, #3
     424:	e7b2      	b.n	38c <_sercom_get_default_pad+0x1c>
     426:	481d      	ldr	r0, [pc, #116]	; (49c <_sercom_get_default_pad+0x12c>)
     428:	e7b0      	b.n	38c <_sercom_get_default_pad+0x1c>
     42a:	481d      	ldr	r0, [pc, #116]	; (4a0 <_sercom_get_default_pad+0x130>)
     42c:	e7ae      	b.n	38c <_sercom_get_default_pad+0x1c>
     42e:	481d      	ldr	r0, [pc, #116]	; (4a4 <_sercom_get_default_pad+0x134>)
     430:	e7ac      	b.n	38c <_sercom_get_default_pad+0x1c>
     432:	481d      	ldr	r0, [pc, #116]	; (4a8 <_sercom_get_default_pad+0x138>)
     434:	e7aa      	b.n	38c <_sercom_get_default_pad+0x1c>
     436:	481d      	ldr	r0, [pc, #116]	; (4ac <_sercom_get_default_pad+0x13c>)
     438:	e7a8      	b.n	38c <_sercom_get_default_pad+0x1c>
     43a:	481d      	ldr	r0, [pc, #116]	; (4b0 <_sercom_get_default_pad+0x140>)
     43c:	e7a6      	b.n	38c <_sercom_get_default_pad+0x1c>
     43e:	481d      	ldr	r0, [pc, #116]	; (4b4 <_sercom_get_default_pad+0x144>)
     440:	e7a4      	b.n	38c <_sercom_get_default_pad+0x1c>
     442:	481d      	ldr	r0, [pc, #116]	; (4b8 <_sercom_get_default_pad+0x148>)
     444:	e7a2      	b.n	38c <_sercom_get_default_pad+0x1c>
     446:	481d      	ldr	r0, [pc, #116]	; (4bc <_sercom_get_default_pad+0x14c>)
     448:	e7a0      	b.n	38c <_sercom_get_default_pad+0x1c>
     44a:	481d      	ldr	r0, [pc, #116]	; (4c0 <_sercom_get_default_pad+0x150>)
     44c:	e79e      	b.n	38c <_sercom_get_default_pad+0x1c>
     44e:	481d      	ldr	r0, [pc, #116]	; (4c4 <_sercom_get_default_pad+0x154>)
     450:	e79c      	b.n	38c <_sercom_get_default_pad+0x1c>
     452:	481d      	ldr	r0, [pc, #116]	; (4c8 <_sercom_get_default_pad+0x158>)
     454:	e79a      	b.n	38c <_sercom_get_default_pad+0x1c>
     456:	481d      	ldr	r0, [pc, #116]	; (4cc <_sercom_get_default_pad+0x15c>)
     458:	e798      	b.n	38c <_sercom_get_default_pad+0x1c>
     45a:	46c0      	nop			; (mov r8, r8)
     45c:	42001000 	.word	0x42001000
     460:	42001800 	.word	0x42001800
     464:	42001c00 	.word	0x42001c00
     468:	42001400 	.word	0x42001400
     46c:	42000800 	.word	0x42000800
     470:	42000c00 	.word	0x42000c00
     474:	001f0003 	.word	0x001f0003
     478:	000f0003 	.word	0x000f0003
     47c:	00130003 	.word	0x00130003
     480:	00070003 	.word	0x00070003
     484:	00190003 	.word	0x00190003
     488:	000b0003 	.word	0x000b0003
     48c:	000c0003 	.word	0x000c0003
     490:	000d0003 	.word	0x000d0003
     494:	000e0003 	.word	0x000e0003
     498:	001e0003 	.word	0x001e0003
     49c:	00010003 	.word	0x00010003
     4a0:	000a0003 	.word	0x000a0003
     4a4:	00180003 	.word	0x00180003
     4a8:	00160003 	.word	0x00160003
     4ac:	00170003 	.word	0x00170003
     4b0:	00060003 	.word	0x00060003
     4b4:	00120003 	.word	0x00120003
     4b8:	00100003 	.word	0x00100003
     4bc:	00110003 	.word	0x00110003
     4c0:	00080003 	.word	0x00080003
     4c4:	00090003 	.word	0x00090003
     4c8:	00040003 	.word	0x00040003
     4cc:	00050003 	.word	0x00050003

000004d0 <_sercom_get_sercom_inst_index>:
 *
 * \return Index of given instance.
 */
uint8_t _sercom_get_sercom_inst_index(
		Sercom *const sercom_instance)
{
     4d0:	b570      	push	{r4, r5, r6, lr}
     4d2:	b086      	sub	sp, #24
     4d4:	1c01      	adds	r1, r0, #0
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;
     4d6:	4668      	mov	r0, sp
     4d8:	4b15      	ldr	r3, [pc, #84]	; (530 <_sercom_get_sercom_inst_index+0x60>)
     4da:	cb70      	ldmia	r3!, {r4, r5, r6}
     4dc:	c070      	stmia	r0!, {r4, r5, r6}
     4de:	cb70      	ldmia	r3!, {r4, r5, r6}
     4e0:	c070      	stmia	r0!, {r4, r5, r6}

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
     4e2:	9b00      	ldr	r3, [sp, #0]
     4e4:	428b      	cmp	r3, r1
     4e6:	d011      	beq.n	50c <_sercom_get_sercom_inst_index+0x3c>
     4e8:	9b01      	ldr	r3, [sp, #4]
     4ea:	428b      	cmp	r3, r1
     4ec:	d011      	beq.n	512 <_sercom_get_sercom_inst_index+0x42>
     4ee:	9b02      	ldr	r3, [sp, #8]
     4f0:	428b      	cmp	r3, r1
     4f2:	d011      	beq.n	518 <_sercom_get_sercom_inst_index+0x48>
     4f4:	9b03      	ldr	r3, [sp, #12]
     4f6:	428b      	cmp	r3, r1
     4f8:	d011      	beq.n	51e <_sercom_get_sercom_inst_index+0x4e>
     4fa:	9b04      	ldr	r3, [sp, #16]
     4fc:	428b      	cmp	r3, r1
     4fe:	d011      	beq.n	524 <_sercom_get_sercom_inst_index+0x54>
     500:	9b05      	ldr	r3, [sp, #20]
		}
	}

	/* Invalid data given */
	Assert(false);
	return 0;
     502:	2000      	movs	r0, #0
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
     504:	428b      	cmp	r3, r1
     506:	d010      	beq.n	52a <_sercom_get_sercom_inst_index+0x5a>
	}

	/* Invalid data given */
	Assert(false);
	return 0;
}
     508:	b006      	add	sp, #24
     50a:	bd70      	pop	{r4, r5, r6, pc}
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     50c:	2000      	movs	r0, #0
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
			return i;
     50e:	b2c0      	uxtb	r0, r0
     510:	e7fa      	b.n	508 <_sercom_get_sercom_inst_index+0x38>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     512:	2001      	movs	r0, #1
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
			return i;
     514:	b2c0      	uxtb	r0, r0
     516:	e7f7      	b.n	508 <_sercom_get_sercom_inst_index+0x38>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     518:	2002      	movs	r0, #2
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
			return i;
     51a:	b2c0      	uxtb	r0, r0
     51c:	e7f4      	b.n	508 <_sercom_get_sercom_inst_index+0x38>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     51e:	2003      	movs	r0, #3
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
			return i;
     520:	b2c0      	uxtb	r0, r0
     522:	e7f1      	b.n	508 <_sercom_get_sercom_inst_index+0x38>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     524:	2004      	movs	r0, #4
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
			return i;
     526:	b2c0      	uxtb	r0, r0
     528:	e7ee      	b.n	508 <_sercom_get_sercom_inst_index+0x38>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     52a:	3005      	adds	r0, #5
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
			return i;
     52c:	b2c0      	uxtb	r0, r0
     52e:	e7eb      	b.n	508 <_sercom_get_sercom_inst_index+0x38>
     530:	0000325c 	.word	0x0000325c

00000534 <_read>:
int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
{
     534:	b5f0      	push	{r4, r5, r6, r7, lr}
     536:	4647      	mov	r7, r8
     538:	1c0c      	adds	r4, r1, #0
     53a:	b480      	push	{r7}
     53c:	4690      	mov	r8, r2
	int nChars = 0;

	if (file != 0) {
     53e:	2800      	cmp	r0, #0
     540:	d112      	bne.n	568 <_read+0x34>
		return -1;
	}

	for (; len > 0; --len) {
     542:	2a00      	cmp	r2, #0
     544:	dd0d      	ble.n	562 <_read+0x2e>
     546:	4e0a      	ldr	r6, [pc, #40]	; (570 <_read+0x3c>)
     548:	4d0a      	ldr	r5, [pc, #40]	; (574 <_read+0x40>)
     54a:	188f      	adds	r7, r1, r2
		ptr_get(stdio_base, ptr);
     54c:	1c21      	adds	r1, r4, #0
     54e:	6830      	ldr	r0, [r6, #0]
     550:	682b      	ldr	r3, [r5, #0]
		ptr++;
     552:	3401      	adds	r4, #1
	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
		ptr_get(stdio_base, ptr);
     554:	4798      	blx	r3

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
     556:	42bc      	cmp	r4, r7
     558:	d1f8      	bne.n	54c <_read+0x18>
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
	}
	return nChars;
     55a:	4640      	mov	r0, r8
}
     55c:	bc04      	pop	{r2}
     55e:	4690      	mov	r8, r2
     560:	bdf0      	pop	{r4, r5, r6, r7, pc}

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
     562:	2300      	movs	r3, #0
     564:	4698      	mov	r8, r3
     566:	e7f8      	b.n	55a <_read+0x26>
_read (int file, char * ptr, int len)
{
	int nChars = 0;

	if (file != 0) {
		return -1;
     568:	2001      	movs	r0, #1
     56a:	4240      	negs	r0, r0
     56c:	e7f6      	b.n	55c <_read+0x28>
     56e:	46c0      	nop			; (mov r8, r8)
     570:	200001ac 	.word	0x200001ac
     574:	200001a4 	.word	0x200001a4

00000578 <_write>:
int __attribute__((weak))
_write (int file, char * ptr, int len);

int __attribute__((weak))
_write (int file, char * ptr, int len)
{
     578:	b5f0      	push	{r4, r5, r6, r7, lr}
     57a:	4647      	mov	r7, r8
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
     57c:	3801      	subs	r0, #1
int __attribute__((weak))
_write (int file, char * ptr, int len);

int __attribute__((weak))
_write (int file, char * ptr, int len)
{
     57e:	b480      	push	{r7}
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
     580:	2802      	cmp	r0, #2
     582:	d812      	bhi.n	5aa <_write+0x32>
		return -1;
	}

	for (; len != 0; --len) {
     584:	2a00      	cmp	r2, #0
     586:	d015      	beq.n	5b4 <_write+0x3c>
     588:	4b0c      	ldr	r3, [pc, #48]	; (5bc <_write+0x44>)
     58a:	1c15      	adds	r5, r2, #0
     58c:	1c0e      	adds	r6, r1, #0
     58e:	2400      	movs	r4, #0
     590:	4698      	mov	r8, r3
     592:	4f0b      	ldr	r7, [pc, #44]	; (5c0 <_write+0x48>)
     594:	e002      	b.n	59c <_write+0x24>
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
		}
		++nChars;
     596:	3401      	adds	r4, #1

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
     598:	42a5      	cmp	r5, r4
     59a:	d00c      	beq.n	5b6 <_write+0x3e>
		if (ptr_put(stdio_base, *ptr++) < 0) {
     59c:	4643      	mov	r3, r8
     59e:	5d31      	ldrb	r1, [r6, r4]
     5a0:	6818      	ldr	r0, [r3, #0]
     5a2:	683b      	ldr	r3, [r7, #0]
     5a4:	4798      	blx	r3
     5a6:	2800      	cmp	r0, #0
     5a8:	daf5      	bge.n	596 <_write+0x1e>
_write (int file, char * ptr, int len)
{
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
     5aa:	2001      	movs	r0, #1
     5ac:	4240      	negs	r0, r0
			return -1;
		}
		++nChars;
	}
	return nChars;
}
     5ae:	bc04      	pop	{r2}
     5b0:	4690      	mov	r8, r2
     5b2:	bdf0      	pop	{r4, r5, r6, r7, pc}

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
     5b4:	2400      	movs	r4, #0
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
		}
		++nChars;
	}
	return nChars;
     5b6:	1c20      	adds	r0, r4, #0
     5b8:	e7f9      	b.n	5ae <_write+0x36>
     5ba:	46c0      	nop			; (mov r8, r8)
     5bc:	200001ac 	.word	0x200001ac
     5c0:	200001a8 	.word	0x200001a8

000005c4 <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
     5c4:	4b08      	ldr	r3, [pc, #32]	; (5e8 <pxCurrentTCBConst2>)
     5c6:	6819      	ldr	r1, [r3, #0]
     5c8:	6808      	ldr	r0, [r1, #0]
     5ca:	3010      	adds	r0, #16
     5cc:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     5ce:	46a0      	mov	r8, r4
     5d0:	46a9      	mov	r9, r5
     5d2:	46b2      	mov	sl, r6
     5d4:	46bb      	mov	fp, r7
     5d6:	f380 8809 	msr	PSP, r0
     5da:	3820      	subs	r0, #32
     5dc:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     5de:	4671      	mov	r1, lr
     5e0:	200d      	movs	r0, #13
     5e2:	4301      	orrs	r1, r0
     5e4:	4708      	bx	r1
     5e6:	46c0      	nop			; (mov r8, r8)

000005e8 <pxCurrentTCBConst2>:
     5e8:	200000fc 	.word	0x200000fc

000005ec <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
     5ec:	f3ef 8009 	mrs	r0, PSP
     5f0:	4b0e      	ldr	r3, [pc, #56]	; (62c <pxCurrentTCBConst>)
     5f2:	681a      	ldr	r2, [r3, #0]
     5f4:	3820      	subs	r0, #32
     5f6:	6010      	str	r0, [r2, #0]
     5f8:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     5fa:	4644      	mov	r4, r8
     5fc:	464d      	mov	r5, r9
     5fe:	4656      	mov	r6, sl
     600:	465f      	mov	r7, fp
     602:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     604:	b508      	push	{r3, lr}
     606:	b672      	cpsid	i
     608:	f000 f974 	bl	8f4 <vTaskSwitchContext>
     60c:	b662      	cpsie	i
     60e:	bc0c      	pop	{r2, r3}
     610:	6811      	ldr	r1, [r2, #0]
     612:	6808      	ldr	r0, [r1, #0]
     614:	3010      	adds	r0, #16
     616:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     618:	46a0      	mov	r8, r4
     61a:	46a9      	mov	r9, r5
     61c:	46b2      	mov	sl, r6
     61e:	46bb      	mov	fp, r7
     620:	f380 8809 	msr	PSP, r0
     624:	3820      	subs	r0, #32
     626:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     628:	4718      	bx	r3
     62a:	46c0      	nop			; (mov r8, r8)

0000062c <pxCurrentTCBConst>:
     62c:	200000fc 	.word	0x200000fc

00000630 <SysTick_Handler>:
{
unsigned long ulDummy;

	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
     630:	2280      	movs	r2, #128	; 0x80
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
     632:	b508      	push	{r3, lr}
unsigned long ulDummy;

	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
     634:	4b03      	ldr	r3, [pc, #12]	; (644 <SysTick_Handler+0x14>)
     636:	0552      	lsls	r2, r2, #21
     638:	601a      	str	r2, [r3, #0]
	#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
     63a:	b672      	cpsid	i
	{
		vTaskIncrementTick();
     63c:	4b02      	ldr	r3, [pc, #8]	; (648 <SysTick_Handler+0x18>)
     63e:	4798      	blx	r3
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
     640:	b662      	cpsie	i
}
     642:	bd08      	pop	{r3, pc}
     644:	e000ed04 	.word	0xe000ed04
     648:	000007d1 	.word	0x000007d1

0000064c <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     64c:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
     64e:	685a      	ldr	r2, [r3, #4]
     650:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
     652:	6842      	ldr	r2, [r0, #4]
     654:	608a      	str	r2, [r1, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     656:	685a      	ldr	r2, [r3, #4]
     658:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     65a:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     65c:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     65e:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
     660:	6803      	ldr	r3, [r0, #0]
     662:	3301      	adds	r3, #1
     664:	6003      	str	r3, [r0, #0]
}
     666:	4770      	bx	lr

00000668 <uxListRemove>:

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     668:	6843      	ldr	r3, [r0, #4]
     66a:	6882      	ldr	r2, [r0, #8]
     66c:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     66e:	6883      	ldr	r3, [r0, #8]
     670:	6842      	ldr	r2, [r0, #4]
     672:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     674:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     676:	685a      	ldr	r2, [r3, #4]
     678:	4282      	cmp	r2, r0
     67a:	d006      	beq.n	68a <uxListRemove+0x22>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
	}

	pxItemToRemove->pvContainer = NULL;
     67c:	2200      	movs	r2, #0
     67e:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
     680:	681a      	ldr	r2, [r3, #0]
     682:	3a01      	subs	r2, #1
     684:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
     686:	6818      	ldr	r0, [r3, #0]
}
     688:	4770      	bx	lr
	pxList = ( xList * ) pxItemToRemove->pvContainer;

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     68a:	6882      	ldr	r2, [r0, #8]
     68c:	605a      	str	r2, [r3, #4]
     68e:	e7f5      	b.n	67c <uxListRemove+0x14>

00000690 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     690:	b538      	push	{r3, r4, r5, lr}
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     692:	6c03      	ldr	r3, [r0, #64]	; 0x40

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     694:	1c04      	adds	r4, r0, #0
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     696:	2b00      	cmp	r3, #0
     698:	d107      	bne.n	6aa <prvCopyDataToQueue+0x1a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     69a:	6805      	ldr	r5, [r0, #0]
     69c:	2d00      	cmp	r5, #0
     69e:	d124      	bne.n	6ea <prvCopyDataToQueue+0x5a>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     6a0:	6840      	ldr	r0, [r0, #4]
     6a2:	4b14      	ldr	r3, [pc, #80]	; (6f4 <prvCopyDataToQueue+0x64>)
     6a4:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
     6a6:	6065      	str	r5, [r4, #4]
     6a8:	e01f      	b.n	6ea <prvCopyDataToQueue+0x5a>
     6aa:	4d13      	ldr	r5, [pc, #76]	; (6f8 <prvCopyDataToQueue+0x68>)
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     6ac:	2a00      	cmp	r2, #0
     6ae:	d10d      	bne.n	6cc <prvCopyDataToQueue+0x3c>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
     6b0:	1c1a      	adds	r2, r3, #0
     6b2:	6880      	ldr	r0, [r0, #8]
     6b4:	47a8      	blx	r5
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     6b6:	6c22      	ldr	r2, [r4, #64]	; 0x40
     6b8:	68a3      	ldr	r3, [r4, #8]
     6ba:	4694      	mov	ip, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     6bc:	6862      	ldr	r2, [r4, #4]
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     6be:	4463      	add	r3, ip
     6c0:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     6c2:	4293      	cmp	r3, r2
     6c4:	d311      	bcc.n	6ea <prvCopyDataToQueue+0x5a>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     6c6:	6823      	ldr	r3, [r4, #0]
     6c8:	60a3      	str	r3, [r4, #8]
     6ca:	e00e      	b.n	6ea <prvCopyDataToQueue+0x5a>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
     6cc:	1c1a      	adds	r2, r3, #0
     6ce:	68c0      	ldr	r0, [r0, #12]
     6d0:	47a8      	blx	r5
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     6d2:	6c23      	ldr	r3, [r4, #64]	; 0x40
     6d4:	68e2      	ldr	r2, [r4, #12]
     6d6:	425b      	negs	r3, r3
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     6d8:	6821      	ldr	r1, [r4, #0]
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     6da:	18d2      	adds	r2, r2, r3
     6dc:	60e2      	str	r2, [r4, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     6de:	428a      	cmp	r2, r1
     6e0:	d203      	bcs.n	6ea <prvCopyDataToQueue+0x5a>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     6e2:	6862      	ldr	r2, [r4, #4]
     6e4:	4694      	mov	ip, r2
     6e6:	4463      	add	r3, ip
     6e8:	60e3      	str	r3, [r4, #12]
		}
	}

	++( pxQueue->uxMessagesWaiting );
     6ea:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     6ec:	3301      	adds	r3, #1
     6ee:	63a3      	str	r3, [r4, #56]	; 0x38
}
     6f0:	bd38      	pop	{r3, r4, r5, pc}
     6f2:	46c0      	nop			; (mov r8, r8)
     6f4:	000009e9 	.word	0x000009e9
     6f8:	000027f9 	.word	0x000027f9

000006fc <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static portBASE_TYPE prvNotifyQueueSetContainer( xQUEUE *pxQueue, portBASE_TYPE xCopyPosition )
	{
     6fc:	b510      	push	{r4, lr}
	xQUEUE *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
     6fe:	6cc4      	ldr	r4, [r0, #76]	; 0x4c
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static portBASE_TYPE prvNotifyQueueSetContainer( xQUEUE *pxQueue, portBASE_TYPE xCopyPosition )
	{
     700:	b082      	sub	sp, #8
     702:	9001      	str	r0, [sp, #4]
	xQUEUE *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
	portBASE_TYPE xReturn = pdFALSE;

		configASSERT( pxQueueSetContainer );
     704:	2c00      	cmp	r4, #0
     706:	d00b      	beq.n	720 <prvNotifyQueueSetContainer+0x24>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
     708:	6ba2      	ldr	r2, [r4, #56]	; 0x38
     70a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     70c:	429a      	cmp	r2, r3
     70e:	d301      	bcc.n	714 <prvNotifyQueueSetContainer+0x18>
     710:	b672      	cpsid	i
     712:	e7fe      	b.n	712 <prvNotifyQueueSetContainer+0x16>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
     714:	6ba2      	ldr	r2, [r4, #56]	; 0x38
     716:	4293      	cmp	r3, r2
     718:	d804      	bhi.n	724 <prvNotifyQueueSetContainer+0x28>
#if ( configUSE_QUEUE_SETS == 1 )

	static portBASE_TYPE prvNotifyQueueSetContainer( xQUEUE *pxQueue, portBASE_TYPE xCopyPosition )
	{
	xQUEUE *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
	portBASE_TYPE xReturn = pdFALSE;
     71a:	2000      	movs	r0, #0
				}
			}
		}

		return xReturn;
	}
     71c:	b002      	add	sp, #8
     71e:	bd10      	pop	{r4, pc}
	static portBASE_TYPE prvNotifyQueueSetContainer( xQUEUE *pxQueue, portBASE_TYPE xCopyPosition )
	{
	xQUEUE *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
	portBASE_TYPE xReturn = pdFALSE;

		configASSERT( pxQueueSetContainer );
     720:	b672      	cpsid	i
     722:	e7fe      	b.n	722 <prvNotifyQueueSetContainer+0x26>
     724:	1c0a      	adds	r2, r1, #0

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
		{
			traceQUEUE_SEND( pxQueueSetContainer );
			/* The data copies is the handle of the queue that contains data. */
			prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
     726:	4b07      	ldr	r3, [pc, #28]	; (744 <prvNotifyQueueSetContainer+0x48>)
     728:	1c20      	adds	r0, r4, #0
     72a:	a901      	add	r1, sp, #4
     72c:	4798      	blx	r3
			if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
     72e:	6a63      	ldr	r3, [r4, #36]	; 0x24
     730:	2b00      	cmp	r3, #0
     732:	d0f2      	beq.n	71a <prvNotifyQueueSetContainer+0x1e>
			{
				if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
     734:	1c20      	adds	r0, r4, #0
     736:	4b04      	ldr	r3, [pc, #16]	; (748 <prvNotifyQueueSetContainer+0x4c>)
     738:	3024      	adds	r0, #36	; 0x24
     73a:	4798      	blx	r3
#if ( configUSE_QUEUE_SETS == 1 )

	static portBASE_TYPE prvNotifyQueueSetContainer( xQUEUE *pxQueue, portBASE_TYPE xCopyPosition )
	{
	xQUEUE *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
	portBASE_TYPE xReturn = pdFALSE;
     73c:	1e43      	subs	r3, r0, #1
     73e:	4198      	sbcs	r0, r3
     740:	e7ec      	b.n	71c <prvNotifyQueueSetContainer+0x20>
     742:	46c0      	nop			; (mov r8, r8)
     744:	00000691 	.word	0x00000691
     748:	00000971 	.word	0x00000971

0000074c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     74c:	b570      	push	{r4, r5, r6, lr}
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
     74e:	2800      	cmp	r0, #0
     750:	d009      	beq.n	766 <xQueueGenericSendFromISR+0x1a>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
     752:	2900      	cmp	r1, #0
     754:	d017      	beq.n	786 <xQueueGenericSendFromISR+0x3a>
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     756:	b672      	cpsid	i
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     758:	6b84      	ldr	r4, [r0, #56]	; 0x38
     75a:	6bc5      	ldr	r5, [r0, #60]	; 0x3c
     75c:	42ac      	cmp	r4, r5
     75e:	d304      	bcc.n	76a <xQueueGenericSendFromISR+0x1e>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     760:	2000      	movs	r0, #0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
     762:	b662      	cpsie	i

	return xReturn;
}
     764:	bd70      	pop	{r4, r5, r6, pc}
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
     766:	b672      	cpsid	i
     768:	e7fe      	b.n	768 <xQueueGenericSendFromISR+0x1c>
     76a:	1c04      	adds	r4, r0, #0
     76c:	1c1e      	adds	r6, r3, #0
     76e:	1c15      	adds	r5, r2, #0
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     770:	1c1a      	adds	r2, r3, #0
     772:	4b14      	ldr	r3, [pc, #80]	; (7c4 <xQueueGenericSendFromISR+0x78>)
     774:	4798      	blx	r3

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     776:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     778:	3301      	adds	r3, #1
     77a:	d009      	beq.n	790 <xQueueGenericSendFromISR+0x44>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     77c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
			}

			xReturn = pdPASS;
     77e:	2001      	movs	r0, #1
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     780:	3301      	adds	r3, #1
     782:	64a3      	str	r3, [r4, #72]	; 0x48
     784:	e7ed      	b.n	762 <xQueueGenericSendFromISR+0x16>
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
     786:	6c04      	ldr	r4, [r0, #64]	; 0x40
     788:	2c00      	cmp	r4, #0
     78a:	d0e4      	beq.n	756 <xQueueGenericSendFromISR+0xa>
     78c:	b672      	cpsid	i
     78e:	e7fe      	b.n	78e <xQueueGenericSendFromISR+0x42>
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
			{
				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
     790:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
     792:	2b00      	cmp	r3, #0
     794:	d007      	beq.n	7a6 <xQueueGenericSendFromISR+0x5a>
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
     796:	1c20      	adds	r0, r4, #0
     798:	1c31      	adds	r1, r6, #0
     79a:	4b0b      	ldr	r3, [pc, #44]	; (7c8 <xQueueGenericSendFromISR+0x7c>)
     79c:	4798      	blx	r3
     79e:	2801      	cmp	r0, #1
     7a0:	d00a      	beq.n	7b8 <xQueueGenericSendFromISR+0x6c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
     7a2:	2001      	movs	r0, #1
     7a4:	e7dd      	b.n	762 <xQueueGenericSendFromISR+0x16>
							}
						}
					}
					else
					{
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     7a6:	6a63      	ldr	r3, [r4, #36]	; 0x24
     7a8:	2b00      	cmp	r3, #0
     7aa:	d0fa      	beq.n	7a2 <xQueueGenericSendFromISR+0x56>
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     7ac:	1c20      	adds	r0, r4, #0
     7ae:	4b07      	ldr	r3, [pc, #28]	; (7cc <xQueueGenericSendFromISR+0x80>)
     7b0:	3024      	adds	r0, #36	; 0x24
     7b2:	4798      	blx	r3
     7b4:	2800      	cmp	r0, #0
     7b6:	d0f4      	beq.n	7a2 <xQueueGenericSendFromISR+0x56>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
						{
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock.  A context switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
     7b8:	2d00      	cmp	r5, #0
     7ba:	d0f2      	beq.n	7a2 <xQueueGenericSendFromISR+0x56>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     7bc:	2301      	movs	r3, #1
     7be:	602b      	str	r3, [r5, #0]
     7c0:	e7ef      	b.n	7a2 <xQueueGenericSendFromISR+0x56>
     7c2:	46c0      	nop			; (mov r8, r8)
     7c4:	00000691 	.word	0x00000691
     7c8:	000006fd 	.word	0x000006fd
     7cc:	00000971 	.word	0x00000971

000007d0 <vTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
     7d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     7d2:	465f      	mov	r7, fp
     7d4:	4656      	mov	r6, sl
     7d6:	464d      	mov	r5, r9
     7d8:	4644      	mov	r4, r8
     7da:	b4f0      	push	{r4, r5, r6, r7}

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     7dc:	4b3a      	ldr	r3, [pc, #232]	; (8c8 <vTaskIncrementTick+0xf8>)
     7de:	681b      	ldr	r3, [r3, #0]
     7e0:	2b00      	cmp	r3, #0
     7e2:	d145      	bne.n	870 <vTaskIncrementTick+0xa0>
	{
		++xTickCount;
     7e4:	4e39      	ldr	r6, [pc, #228]	; (8cc <vTaskIncrementTick+0xfc>)
     7e6:	6833      	ldr	r3, [r6, #0]
     7e8:	3301      	adds	r3, #1
     7ea:	6033      	str	r3, [r6, #0]
		if( xTickCount == ( portTickType ) 0U )
     7ec:	6833      	ldr	r3, [r6, #0]
     7ee:	2b00      	cmp	r3, #0
     7f0:	d048      	beq.n	884 <vTaskIncrementTick+0xb4>
     7f2:	4c37      	ldr	r4, [pc, #220]	; (8d0 <vTaskIncrementTick+0x100>)
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
     7f4:	6832      	ldr	r2, [r6, #0]
     7f6:	6823      	ldr	r3, [r4, #0]
     7f8:	429a      	cmp	r2, r3
     7fa:	d33d      	bcc.n	878 <vTaskIncrementTick+0xa8>
     7fc:	4f35      	ldr	r7, [pc, #212]	; (8d4 <vTaskIncrementTick+0x104>)
     7fe:	683b      	ldr	r3, [r7, #0]
     800:	681b      	ldr	r3, [r3, #0]
     802:	2b00      	cmp	r3, #0
     804:	d030      	beq.n	868 <vTaskIncrementTick+0x98>
     806:	683b      	ldr	r3, [r7, #0]
     808:	68db      	ldr	r3, [r3, #12]
     80a:	68dd      	ldr	r5, [r3, #12]
     80c:	6832      	ldr	r2, [r6, #0]
     80e:	686b      	ldr	r3, [r5, #4]
     810:	4293      	cmp	r3, r2
     812:	d850      	bhi.n	8b6 <vTaskIncrementTick+0xe6>
     814:	4b30      	ldr	r3, [pc, #192]	; (8d8 <vTaskIncrementTick+0x108>)
     816:	4699      	mov	r9, r3
     818:	4b30      	ldr	r3, [pc, #192]	; (8dc <vTaskIncrementTick+0x10c>)
     81a:	4698      	mov	r8, r3
     81c:	4b30      	ldr	r3, [pc, #192]	; (8e0 <vTaskIncrementTick+0x110>)
     81e:	469b      	mov	fp, r3
     820:	e006      	b.n	830 <vTaskIncrementTick+0x60>
     822:	683b      	ldr	r3, [r7, #0]
     824:	68db      	ldr	r3, [r3, #12]
     826:	68dd      	ldr	r5, [r3, #12]
     828:	6832      	ldr	r2, [r6, #0]
     82a:	686b      	ldr	r3, [r5, #4]
     82c:	4293      	cmp	r3, r2
     82e:	d842      	bhi.n	8b6 <vTaskIncrementTick+0xe6>
     830:	1d2b      	adds	r3, r5, #4
     832:	1c18      	adds	r0, r3, #0
     834:	469a      	mov	sl, r3
     836:	47c8      	blx	r9
     838:	6aab      	ldr	r3, [r5, #40]	; 0x28
     83a:	2b00      	cmp	r3, #0
     83c:	d002      	beq.n	844 <vTaskIncrementTick+0x74>
     83e:	1c28      	adds	r0, r5, #0
     840:	3018      	adds	r0, #24
     842:	47c8      	blx	r9
     844:	4642      	mov	r2, r8
     846:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
     848:	6812      	ldr	r2, [r2, #0]
     84a:	4293      	cmp	r3, r2
     84c:	d901      	bls.n	852 <vTaskIncrementTick+0x82>
     84e:	4642      	mov	r2, r8
     850:	6013      	str	r3, [r2, #0]
     852:	0098      	lsls	r0, r3, #2
     854:	18c0      	adds	r0, r0, r3
     856:	0080      	lsls	r0, r0, #2
     858:	4b22      	ldr	r3, [pc, #136]	; (8e4 <vTaskIncrementTick+0x114>)
     85a:	4458      	add	r0, fp
     85c:	4651      	mov	r1, sl
     85e:	4798      	blx	r3
     860:	683b      	ldr	r3, [r7, #0]
     862:	681b      	ldr	r3, [r3, #0]
     864:	2b00      	cmp	r3, #0
     866:	d1dc      	bne.n	822 <vTaskIncrementTick+0x52>
     868:	2301      	movs	r3, #1
     86a:	425b      	negs	r3, r3
     86c:	6023      	str	r3, [r4, #0]
     86e:	e003      	b.n	878 <vTaskIncrementTick+0xa8>
	}
	else
	{
		++uxMissedTicks;
     870:	4a1d      	ldr	r2, [pc, #116]	; (8e8 <vTaskIncrementTick+0x118>)
     872:	6813      	ldr	r3, [r2, #0]
     874:	3301      	adds	r3, #1
     876:	6013      	str	r3, [r2, #0]
		{
			vApplicationTickHook();
		}
	}
	#endif /* configUSE_TICK_HOOK */
}
     878:	bc3c      	pop	{r2, r3, r4, r5}
     87a:	4690      	mov	r8, r2
     87c:	4699      	mov	r9, r3
     87e:	46a2      	mov	sl, r4
     880:	46ab      	mov	fp, r5
     882:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
     884:	4b13      	ldr	r3, [pc, #76]	; (8d4 <vTaskIncrementTick+0x104>)
     886:	681a      	ldr	r2, [r3, #0]
     888:	6812      	ldr	r2, [r2, #0]
     88a:	2a00      	cmp	r2, #0
     88c:	d001      	beq.n	892 <vTaskIncrementTick+0xc2>
     88e:	b672      	cpsid	i
     890:	e7fe      	b.n	890 <vTaskIncrementTick+0xc0>

			pxTemp = pxDelayedTaskList;
			pxDelayedTaskList = pxOverflowDelayedTaskList;
     892:	4a16      	ldr	r2, [pc, #88]	; (8ec <vTaskIncrementTick+0x11c>)
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
     894:	6819      	ldr	r1, [r3, #0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
     896:	6810      	ldr	r0, [r2, #0]
     898:	6018      	str	r0, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
     89a:	6011      	str	r1, [r2, #0]
			xNumOfOverflows++;
     89c:	4914      	ldr	r1, [pc, #80]	; (8f0 <vTaskIncrementTick+0x120>)
     89e:	680a      	ldr	r2, [r1, #0]
     8a0:	3201      	adds	r2, #1
     8a2:	600a      	str	r2, [r1, #0]

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     8a4:	681a      	ldr	r2, [r3, #0]
     8a6:	6812      	ldr	r2, [r2, #0]
     8a8:	2a00      	cmp	r2, #0
     8aa:	d106      	bne.n	8ba <vTaskIncrementTick+0xea>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
     8ac:	2301      	movs	r3, #1
     8ae:	4c08      	ldr	r4, [pc, #32]	; (8d0 <vTaskIncrementTick+0x100>)
     8b0:	425b      	negs	r3, r3
     8b2:	6023      	str	r3, [r4, #0]
     8b4:	e79e      	b.n	7f4 <vTaskIncrementTick+0x24>
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
     8b6:	6023      	str	r3, [r4, #0]
     8b8:	e7de      	b.n	878 <vTaskIncrementTick+0xa8>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     8ba:	681b      	ldr	r3, [r3, #0]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     8bc:	4c04      	ldr	r4, [pc, #16]	; (8d0 <vTaskIncrementTick+0x100>)
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     8be:	68db      	ldr	r3, [r3, #12]
     8c0:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     8c2:	685b      	ldr	r3, [r3, #4]
     8c4:	6023      	str	r3, [r4, #0]
     8c6:	e795      	b.n	7f4 <vTaskIncrementTick+0x24>
     8c8:	200000f8 	.word	0x200000f8
     8cc:	20000118 	.word	0x20000118
     8d0:	20000000 	.word	0x20000000
     8d4:	20000090 	.word	0x20000090
     8d8:	00000669 	.word	0x00000669
     8dc:	20000120 	.word	0x20000120
     8e0:	20000094 	.word	0x20000094
     8e4:	0000064d 	.word	0x0000064d
     8e8:	2000008c 	.word	0x2000008c
     8ec:	2000011c 	.word	0x2000011c
     8f0:	20000114 	.word	0x20000114

000008f4 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
     8f4:	4b19      	ldr	r3, [pc, #100]	; (95c <vTaskSwitchContext+0x68>)
     8f6:	681b      	ldr	r3, [r3, #0]
     8f8:	2b00      	cmp	r3, #0
     8fa:	d128      	bne.n	94e <vTaskSwitchContext+0x5a>
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
     8fc:	4a18      	ldr	r2, [pc, #96]	; (960 <vTaskSwitchContext+0x6c>)
     8fe:	4819      	ldr	r0, [pc, #100]	; (964 <vTaskSwitchContext+0x70>)
     900:	6811      	ldr	r1, [r2, #0]
     902:	008b      	lsls	r3, r1, #2
     904:	1859      	adds	r1, r3, r1
     906:	0089      	lsls	r1, r1, #2
     908:	5843      	ldr	r3, [r0, r1]
     90a:	2b00      	cmp	r3, #0
     90c:	d00a      	beq.n	924 <vTaskSwitchContext+0x30>
     90e:	e00e      	b.n	92e <vTaskSwitchContext+0x3a>
     910:	6811      	ldr	r1, [r2, #0]
     912:	3901      	subs	r1, #1
     914:	6011      	str	r1, [r2, #0]
     916:	6813      	ldr	r3, [r2, #0]
     918:	0099      	lsls	r1, r3, #2
     91a:	18cb      	adds	r3, r1, r3
     91c:	009b      	lsls	r3, r3, #2
     91e:	58c3      	ldr	r3, [r0, r3]
     920:	2b00      	cmp	r3, #0
     922:	d104      	bne.n	92e <vTaskSwitchContext+0x3a>
     924:	6813      	ldr	r3, [r2, #0]
     926:	2b00      	cmp	r3, #0
     928:	d1f2      	bne.n	910 <vTaskSwitchContext+0x1c>
     92a:	b672      	cpsid	i
     92c:	e7fe      	b.n	92c <vTaskSwitchContext+0x38>
     92e:	6813      	ldr	r3, [r2, #0]
     930:	009a      	lsls	r2, r3, #2
     932:	18d3      	adds	r3, r2, r3
     934:	009b      	lsls	r3, r3, #2
     936:	18c1      	adds	r1, r0, r3
     938:	684a      	ldr	r2, [r1, #4]
     93a:	3308      	adds	r3, #8
     93c:	6852      	ldr	r2, [r2, #4]
     93e:	18c3      	adds	r3, r0, r3
     940:	604a      	str	r2, [r1, #4]
     942:	429a      	cmp	r2, r3
     944:	d007      	beq.n	956 <vTaskSwitchContext+0x62>
     946:	68d2      	ldr	r2, [r2, #12]
     948:	4b07      	ldr	r3, [pc, #28]	; (968 <vTaskSwitchContext+0x74>)
     94a:	601a      	str	r2, [r3, #0]

		traceTASK_SWITCHED_IN();
	}
}
     94c:	4770      	bx	lr
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
     94e:	2201      	movs	r2, #1
     950:	4b06      	ldr	r3, [pc, #24]	; (96c <vTaskSwitchContext+0x78>)
     952:	601a      	str	r2, [r3, #0]
     954:	e7fa      	b.n	94c <vTaskSwitchContext+0x58>
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
     956:	6852      	ldr	r2, [r2, #4]
     958:	604a      	str	r2, [r1, #4]
     95a:	e7f4      	b.n	946 <vTaskSwitchContext+0x52>
     95c:	200000f8 	.word	0x200000f8
     960:	20000120 	.word	0x20000120
     964:	20000094 	.word	0x20000094
     968:	200000fc 	.word	0x200000fc
     96c:	20000124 	.word	0x20000124

00000970 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
     970:	b570      	push	{r4, r5, r6, lr}
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     972:	68c3      	ldr	r3, [r0, #12]
     974:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
     976:	2c00      	cmp	r4, #0
     978:	d026      	beq.n	9c8 <xTaskRemoveFromEventList+0x58>
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     97a:	1c25      	adds	r5, r4, #0
     97c:	3518      	adds	r5, #24
     97e:	1c28      	adds	r0, r5, #0
     980:	4e12      	ldr	r6, [pc, #72]	; (9cc <xTaskRemoveFromEventList+0x5c>)
     982:	47b0      	blx	r6

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     984:	4b12      	ldr	r3, [pc, #72]	; (9d0 <xTaskRemoveFromEventList+0x60>)
     986:	681b      	ldr	r3, [r3, #0]
     988:	2b00      	cmp	r3, #0
     98a:	d118      	bne.n	9be <xTaskRemoveFromEventList+0x4e>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
     98c:	1d25      	adds	r5, r4, #4
     98e:	1c28      	adds	r0, r5, #0
     990:	47b0      	blx	r6
		prvAddTaskToReadyQueue( pxUnblockedTCB );
     992:	4a10      	ldr	r2, [pc, #64]	; (9d4 <xTaskRemoveFromEventList+0x64>)
     994:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
     996:	6811      	ldr	r1, [r2, #0]
     998:	428b      	cmp	r3, r1
     99a:	d900      	bls.n	99e <xTaskRemoveFromEventList+0x2e>
     99c:	6013      	str	r3, [r2, #0]
     99e:	0098      	lsls	r0, r3, #2
     9a0:	18c3      	adds	r3, r0, r3
     9a2:	480d      	ldr	r0, [pc, #52]	; (9d8 <xTaskRemoveFromEventList+0x68>)
     9a4:	009b      	lsls	r3, r3, #2
     9a6:	18c0      	adds	r0, r0, r3
     9a8:	1c29      	adds	r1, r5, #0
     9aa:	4b0c      	ldr	r3, [pc, #48]	; (9dc <xTaskRemoveFromEventList+0x6c>)
     9ac:	4798      	blx	r3
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
     9ae:	2000      	movs	r0, #0
     9b0:	4b0b      	ldr	r3, [pc, #44]	; (9e0 <xTaskRemoveFromEventList+0x70>)
     9b2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
     9b4:	681b      	ldr	r3, [r3, #0]
     9b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
     9b8:	429a      	cmp	r2, r3
     9ba:	4140      	adcs	r0, r0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     9bc:	bd70      	pop	{r4, r5, r6, pc}
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     9be:	4809      	ldr	r0, [pc, #36]	; (9e4 <xTaskRemoveFromEventList+0x74>)
     9c0:	1c29      	adds	r1, r5, #0
     9c2:	4b06      	ldr	r3, [pc, #24]	; (9dc <xTaskRemoveFromEventList+0x6c>)
     9c4:	4798      	blx	r3
     9c6:	e7f2      	b.n	9ae <xTaskRemoveFromEventList+0x3e>
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	configASSERT( pxUnblockedTCB );
     9c8:	b672      	cpsid	i
     9ca:	e7fe      	b.n	9ca <xTaskRemoveFromEventList+0x5a>
     9cc:	00000669 	.word	0x00000669
     9d0:	200000f8 	.word	0x200000f8
     9d4:	20000120 	.word	0x20000120
     9d8:	20000094 	.word	0x20000094
     9dc:	0000064d 	.word	0x0000064d
     9e0:	200000fc 	.word	0x200000fc
     9e4:	20000100 	.word	0x20000100

000009e8 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
     9e8:	b538      	push	{r3, r4, r5, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
     9ea:	2800      	cmp	r0, #0
     9ec:	d019      	beq.n	a22 <vTaskPriorityDisinherit+0x3a>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
     9ee:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
     9f0:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
     9f2:	4293      	cmp	r3, r2
     9f4:	d015      	beq.n	a22 <vTaskPriorityDisinherit+0x3a>
     9f6:	1c04      	adds	r4, r0, #0
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
     9f8:	1d05      	adds	r5, r0, #4
     9fa:	4b0b      	ldr	r3, [pc, #44]	; (a28 <vTaskPriorityDisinherit+0x40>)
     9fc:	1c28      	adds	r0, r5, #0
     9fe:	4798      	blx	r3

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
     a00:	2205      	movs	r2, #5
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
     a02:	6be3      	ldr	r3, [r4, #60]	; 0x3c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
     a04:	1ad2      	subs	r2, r2, r3
     a06:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyQueue( pxTCB );
     a08:	4a08      	ldr	r2, [pc, #32]	; (a2c <vTaskPriorityDisinherit+0x44>)
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
     a0a:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
     a0c:	6811      	ldr	r1, [r2, #0]
     a0e:	428b      	cmp	r3, r1
     a10:	d808      	bhi.n	a24 <vTaskPriorityDisinherit+0x3c>
     a12:	0098      	lsls	r0, r3, #2
     a14:	18c0      	adds	r0, r0, r3
     a16:	0083      	lsls	r3, r0, #2
     a18:	4805      	ldr	r0, [pc, #20]	; (a30 <vTaskPriorityDisinherit+0x48>)
     a1a:	1c29      	adds	r1, r5, #0
     a1c:	18c0      	adds	r0, r0, r3
     a1e:	4b05      	ldr	r3, [pc, #20]	; (a34 <vTaskPriorityDisinherit+0x4c>)
     a20:	4798      	blx	r3
			}
		}
	}
     a22:	bd38      	pop	{r3, r4, r5, pc}
				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
     a24:	6013      	str	r3, [r2, #0]
     a26:	e7f4      	b.n	a12 <vTaskPriorityDisinherit+0x2a>
     a28:	00000669 	.word	0x00000669
     a2c:	20000120 	.word	0x20000120
     a30:	20000094 	.word	0x20000094
     a34:	0000064d 	.word	0x0000064d

00000a38 <usart_init>:
 */
enum status_code usart_init(
		struct usart_module *const module,
		Sercom *const hw,
		const struct usart_config *const config)
{
     a38:	b5f0      	push	{r4, r5, r6, r7, lr}
     a3a:	464d      	mov	r5, r9
     a3c:	4644      	mov	r4, r8
     a3e:	4656      	mov	r6, sl
     a40:	465f      	mov	r7, fp
     a42:	b4f0      	push	{r4, r5, r6, r7}
     a44:	1c05      	adds	r5, r0, #0
	module->hw = hw;

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
     a46:	4bb7      	ldr	r3, [pc, #732]	; (d24 <usart_init+0x2ec>)
 */
enum status_code usart_init(
		struct usart_module *const module,
		Sercom *const hw,
		const struct usart_config *const config)
{
     a48:	1c0c      	adds	r4, r1, #0
     a4a:	b091      	sub	sp, #68	; 0x44
	Assert(config);

	enum status_code status_code = STATUS_OK;

	/* Assign module pointer to software instance struct */
	module->hw = hw;
     a4c:	6029      	str	r1, [r5, #0]

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
     a4e:	1c08      	adds	r0, r1, #0
 */
enum status_code usart_init(
		struct usart_module *const module,
		Sercom *const hw,
		const struct usart_config *const config)
{
     a50:	4690      	mov	r8, r2
	module->hw = hw;

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
     a52:	4699      	mov	r9, r3
     a54:	4798      	blx	r3
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
     a56:	2301      	movs	r3, #1
     a58:	6822      	ldr	r2, [r4, #0]
	module->hw = hw;

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
     a5a:	1c06      	adds	r6, r0, #0
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
		/* The module is busy resetting itself */
		return STATUS_BUSY;
     a5c:	2005      	movs	r0, #5
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
     a5e:	4213      	tst	r3, r2
     a60:	d006      	beq.n	a70 <usart_init+0x38>
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
	_sercom_instances[instance_index] = module;
#endif

	return status_code;
}
     a62:	b011      	add	sp, #68	; 0x44
     a64:	bc3c      	pop	{r2, r3, r4, r5}
     a66:	4690      	mov	r8, r2
     a68:	4699      	mov	r9, r3
     a6a:	46a2      	mov	sl, r4
     a6c:	46ab      	mov	fp, r5
     a6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
		/* The module is busy resetting itself */
		return STATUS_BUSY;
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
     a70:	2702      	movs	r7, #2
     a72:	6822      	ldr	r2, [r4, #0]
		/* Check the module is enabled */
		return STATUS_ERR_DENIED;
     a74:	3017      	adds	r0, #23
	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
		/* The module is busy resetting itself */
		return STATUS_BUSY;
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
     a76:	4017      	ands	r7, r2
     a78:	d1f3      	bne.n	a62 <usart_init+0x2a>
#else
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
     a7a:	1cb0      	adds	r0, r6, #2
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBD, 1 << pm_index);
	} else {
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);	
	}
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
     a7c:	4083      	lsls	r3, r0
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
			break;

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
     a7e:	49aa      	ldr	r1, [pc, #680]	; (d28 <usart_init+0x2f0>)
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
     a80:	3614      	adds	r6, #20
     a82:	6a0a      	ldr	r2, [r1, #32]

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
     a84:	b2f6      	uxtb	r6, r6
     a86:	4313      	orrs	r3, r2
     a88:	620b      	str	r3, [r1, #32]
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
     a8a:	232d      	movs	r3, #45	; 0x2d
     a8c:	469a      	mov	sl, r3
     a8e:	4643      	mov	r3, r8
     a90:	4652      	mov	r2, sl
     a92:	5c9b      	ldrb	r3, [r3, r2]
     a94:	a90a      	add	r1, sp, #40	; 0x28
     a96:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
     a98:	1c30      	adds	r0, r6, #0
     a9a:	4ba4      	ldr	r3, [pc, #656]	; (d2c <usart_init+0x2f4>)
     a9c:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
     a9e:	1c30      	adds	r0, r6, #0
     aa0:	4ba3      	ldr	r3, [pc, #652]	; (d30 <usart_init+0x2f8>)
     aa2:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
     aa4:	4652      	mov	r2, sl
     aa6:	4643      	mov	r3, r8
     aa8:	2100      	movs	r1, #0
     aaa:	5c98      	ldrb	r0, [r3, r2]
     aac:	4ba1      	ldr	r3, [pc, #644]	; (d34 <usart_init+0x2fc>)
     aae:	4798      	blx	r3

	/* Set character size */
	module->character_size = config->character_size;
     ab0:	4643      	mov	r3, r8
     ab2:	7adb      	ldrb	r3, [r3, #11]

	/* Set transmitter and receiver status */
	module->receiver_enabled = config->receiver_enable;
     ab4:	4642      	mov	r2, r8
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
	system_gclk_chan_enable(gclk_index);
	sercom_set_gclk_generator(config->generator_source, false);

	/* Set character size */
	module->character_size = config->character_size;
     ab6:	716b      	strb	r3, [r5, #5]

	/* Set transmitter and receiver status */
	module->receiver_enabled = config->receiver_enable;
     ab8:	2324      	movs	r3, #36	; 0x24
     aba:	5cd3      	ldrb	r3, [r2, r3]
	uint32_t ctrla = 0;
	uint32_t ctrlb = 0;
#ifdef FEATURE_USART_ISO7816
	uint32_t ctrlc = 0;
#endif
	uint16_t baud  = 0;
     abc:	ae0c      	add	r6, sp, #48	; 0x30

	/* Set character size */
	module->character_size = config->character_size;

	/* Set transmitter and receiver status */
	module->receiver_enabled = config->receiver_enable;
     abe:	71ab      	strb	r3, [r5, #6]
	module->transmitter_enabled = config->transmitter_enable;
     ac0:	2325      	movs	r3, #37	; 0x25
     ac2:	5cd3      	ldrb	r3, [r2, r3]
     ac4:	71eb      	strb	r3, [r5, #7]

#ifdef FEATURE_USART_LIN_SLAVE
	module->lin_slave_enabled = config->lin_slave_enable;
     ac6:	7ed3      	ldrb	r3, [r2, #27]
     ac8:	722b      	strb	r3, [r5, #8]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	module->start_frame_detection_enabled = config->start_frame_detection_enable;
     aca:	7f13      	ldrb	r3, [r2, #28]
     acc:	726b      	strb	r3, [r5, #9]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
     ace:	682b      	ldr	r3, [r5, #0]

	/* Index for generic clock */
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
     ad0:	1c18      	adds	r0, r3, #0
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
     ad2:	469a      	mov	sl, r3

	/* Index for generic clock */
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
     ad4:	47c8      	blx	r9

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;

#ifdef FEATURE_USART_OVER_SAMPLE
	switch (config->sample_rate) {
     ad6:	4643      	mov	r3, r8
	uint32_t ctrla = 0;
	uint32_t ctrlb = 0;
#ifdef FEATURE_USART_ISO7816
	uint32_t ctrlc = 0;
#endif
	uint16_t baud  = 0;
     ad8:	8037      	strh	r7, [r6, #0]

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;

#ifdef FEATURE_USART_OVER_SAMPLE
	switch (config->sample_rate) {
     ada:	8a1a      	ldrh	r2, [r3, #16]
     adc:	2380      	movs	r3, #128	; 0x80
	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Index for generic clock */
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
	uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
     ade:	3014      	adds	r0, #20

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;

#ifdef FEATURE_USART_OVER_SAMPLE
	switch (config->sample_rate) {
     ae0:	9202      	str	r2, [sp, #8]
     ae2:	01db      	lsls	r3, r3, #7
     ae4:	429a      	cmp	r2, r3
     ae6:	d100      	bne.n	aea <usart_init+0xb2>
     ae8:	e0d0      	b.n	c8c <usart_init+0x254>
     aea:	d800      	bhi.n	aee <usart_init+0xb6>
     aec:	e0ea      	b.n	cc4 <usart_init+0x28c>
     aee:	23c0      	movs	r3, #192	; 0xc0
     af0:	9a02      	ldr	r2, [sp, #8]
     af2:	01db      	lsls	r3, r3, #7
     af4:	429a      	cmp	r2, r3
     af6:	d100      	bne.n	afa <usart_init+0xc2>
     af8:	e0f2      	b.n	ce0 <usart_init+0x2a8>
     afa:	2380      	movs	r3, #128	; 0x80
     afc:	021b      	lsls	r3, r3, #8
     afe:	429a      	cmp	r2, r3
     b00:	d000      	beq.n	b04 <usart_init+0xcc>
     b02:	e0e8      	b.n	cd6 <usart_init+0x29e>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
			break;
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
     b04:	2303      	movs	r3, #3
     b06:	9309      	str	r3, [sp, #36]	; 0x24
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
			break;
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
     b08:	2300      	movs	r3, #0
     b0a:	9308      	str	r3, [sp, #32]
			break;
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
     b0c:	4643      	mov	r3, r8
     b0e:	681b      	ldr	r3, [r3, #0]
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
     b10:	4642      	mov	r2, r8
			break;
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
     b12:	9303      	str	r3, [sp, #12]
		(uint32_t)config->mux_setting |
     b14:	4643      	mov	r3, r8
     b16:	68db      	ldr	r3, [r3, #12]
     b18:	9304      	str	r3, [sp, #16]
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
     b1a:	4643      	mov	r3, r8
     b1c:	695b      	ldr	r3, [r3, #20]
     b1e:	9305      	str	r3, [sp, #20]
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
     b20:	4643      	mov	r3, r8
     b22:	7e1b      	ldrb	r3, [r3, #24]
     b24:	9306      	str	r3, [sp, #24]
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
     b26:	2326      	movs	r3, #38	; 0x26
     b28:	5cd3      	ldrb	r3, [r2, r3]
     b2a:	9307      	str	r3, [sp, #28]

	enum status_code status_code = STATUS_OK;

	transfer_mode = (uint32_t)config->transfer_mode;
     b2c:	6853      	ldr	r3, [r2, #4]
     b2e:	469b      	mov	fp, r3
#ifdef FEATURE_USART_ISO7816
	if(config->iso7816_config.enabled) {
		baud = config->baudrate;
	} else {
#endif
	switch (transfer_mode)
     b30:	2b00      	cmp	r3, #0
     b32:	d100      	bne.n	b36 <usart_init+0xfe>
     b34:	e0b4      	b.n	ca0 <usart_init+0x268>
     b36:	2380      	movs	r3, #128	; 0x80
     b38:	055b      	lsls	r3, r3, #21
     b3a:	459b      	cmp	fp, r3
     b3c:	d000      	beq.n	b40 <usart_init+0x108>
     b3e:	e0ad      	b.n	c9c <usart_init+0x264>
	{
		case USART_TRANSFER_SYNCHRONOUSLY:
			if (!config->use_external_clock) {
     b40:	2327      	movs	r3, #39	; 0x27
     b42:	5cd3      	ldrb	r3, [r2, r3]
     b44:	2100      	movs	r1, #0
     b46:	2b00      	cmp	r3, #0
     b48:	d100      	bne.n	b4c <usart_init+0x114>
     b4a:	e0e0      	b.n	d0e <usart_init+0x2d6>
#ifdef FEATURE_USART_ISO7816
	}
#endif

#ifdef FEATURE_USART_IRDA
	if(config->encoding_format_enable) {
     b4c:	4643      	mov	r3, r8
     b4e:	7e5b      	ldrb	r3, [r3, #25]
     b50:	2b00      	cmp	r3, #0
     b52:	d003      	beq.n	b5c <usart_init+0x124>
		usart_hw->RXPL.reg = config->receive_pulse_length;
     b54:	4643      	mov	r3, r8
     b56:	4652      	mov	r2, sl
     b58:	7e9b      	ldrb	r3, [r3, #26]
     b5a:	7393      	strb	r3, [r2, #14]
     b5c:	682a      	ldr	r2, [r5, #0]
     b5e:	9f02      	ldr	r7, [sp, #8]
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
     b60:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
     b62:	2b00      	cmp	r3, #0
     b64:	d1fc      	bne.n	b60 <usart_init+0x128>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/*Set baud val */
	usart_hw->BAUD.reg = baud;
     b66:	4653      	mov	r3, sl
     b68:	9a03      	ldr	r2, [sp, #12]
     b6a:	8199      	strh	r1, [r3, #12]
     b6c:	9b04      	ldr	r3, [sp, #16]
     b6e:	4313      	orrs	r3, r2
     b70:	9a05      	ldr	r2, [sp, #20]
     b72:	4313      	orrs	r3, r2
     b74:	465a      	mov	r2, fp
     b76:	4313      	orrs	r3, r2
     b78:	431f      	orrs	r7, r3
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
     b7a:	9b06      	ldr	r3, [sp, #24]
	usart_hw->BAUD.reg = baud;

	/* Set sample mode */
	ctrla |= transfer_mode;

	if (config->use_external_clock == false) {
     b7c:	4642      	mov	r2, r8
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
     b7e:	021b      	lsls	r3, r3, #8
     b80:	431f      	orrs	r7, r3
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
     b82:	9b07      	ldr	r3, [sp, #28]
     b84:	075b      	lsls	r3, r3, #29

	/*Set baud val */
	usart_hw->BAUD.reg = baud;

	/* Set sample mode */
	ctrla |= transfer_mode;
     b86:	431f      	orrs	r7, r3

	if (config->use_external_clock == false) {
     b88:	2327      	movs	r3, #39	; 0x27
     b8a:	5cd3      	ldrb	r3, [r2, r3]
     b8c:	2b00      	cmp	r3, #0
     b8e:	d101      	bne.n	b94 <usart_init+0x15c>
		ctrla |= SERCOM_USART_CTRLA_MODE(0x1);
     b90:	3304      	adds	r3, #4
     b92:	431f      	orrs	r7, r3
	ctrlb =  
		#ifdef FEATURE_USART_IRDA
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
     b94:	4643      	mov	r3, r8
     b96:	7f1b      	ldrb	r3, [r3, #28]
     b98:	0259      	lsls	r1, r3, #9
	}

	/* Set stopbits and enable transceivers */
	ctrlb =  
		#ifdef FEATURE_USART_IRDA
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
     b9a:	4643      	mov	r3, r8
     b9c:	7e5a      	ldrb	r2, [r3, #25]
     b9e:	0293      	lsls	r3, r2, #10
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
     ba0:	4642      	mov	r2, r8
     ba2:	7f52      	ldrb	r2, [r2, #29]
	}

	/* Set stopbits and enable transceivers */
	ctrlb =  
		#ifdef FEATURE_USART_IRDA
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
     ba4:	430b      	orrs	r3, r1
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
     ba6:	0212      	lsls	r2, r2, #8
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
     ba8:	4641      	mov	r1, r8
	ctrlb =  
		#ifdef FEATURE_USART_IRDA
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
     baa:	4313      	orrs	r3, r2
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
     bac:	2224      	movs	r2, #36	; 0x24
     bae:	5c8a      	ldrb	r2, [r1, r2]
     bb0:	0452      	lsls	r2, r2, #17
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
     bb2:	4313      	orrs	r3, r2
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
			(config->transmitter_enable << SERCOM_USART_CTRLB_TXEN_Pos);
     bb4:	2225      	movs	r2, #37	; 0x25
     bb6:	5c8a      	ldrb	r2, [r1, r2]
				ctrlb |= USART_STOPBITS_1;
				break;		
		}
	} else {
#endif
	ctrlb |= (uint32_t)config->character_size;
     bb8:	7ac9      	ldrb	r1, [r1, #11]
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
			(config->transmitter_enable << SERCOM_USART_CTRLB_TXEN_Pos);
     bba:	0412      	lsls	r2, r2, #16
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
     bbc:	4313      	orrs	r3, r2
				ctrlb |= USART_STOPBITS_1;
				break;		
		}
	} else {
#endif
	ctrlb |= (uint32_t)config->character_size;
     bbe:	4642      	mov	r2, r8
     bc0:	4319      	orrs	r1, r3
	/* Check parity mode bits */
	if (config->parity != USART_PARITY_NONE) {
     bc2:	8913      	ldrh	r3, [r2, #8]
     bc4:	2bff      	cmp	r3, #255	; 0xff
     bc6:	d100      	bne.n	bca <usart_init+0x192>
     bc8:	e08f      	b.n	cea <usart_init+0x2b2>
		ctrla |= SERCOM_USART_CTRLA_FORM(1);
     bca:	2280      	movs	r2, #128	; 0x80
     bcc:	0452      	lsls	r2, r2, #17
     bce:	4317      	orrs	r7, r2
		ctrlb |= config->parity;
     bd0:	4319      	orrs	r1, r3
		ctrla |= config->lin_node;
	}
#endif

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
     bd2:	232c      	movs	r3, #44	; 0x2c
     bd4:	4642      	mov	r2, r8
     bd6:	5cd3      	ldrb	r3, [r2, r3]
     bd8:	2b00      	cmp	r3, #0
     bda:	d103      	bne.n	be4 <usart_init+0x1ac>
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
     bdc:	4b56      	ldr	r3, [pc, #344]	; (d38 <usart_init+0x300>)
     bde:	789b      	ldrb	r3, [r3, #2]
     be0:	079b      	lsls	r3, r3, #30
     be2:	d501      	bpl.n	be8 <usart_init+0x1b0>
		ctrla |= SERCOM_USART_CTRLA_RUNSTDBY;
     be4:	2380      	movs	r3, #128	; 0x80
     be6:	431f      	orrs	r7, r3
     be8:	682a      	ldr	r2, [r5, #0]
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
     bea:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
     bec:	2b00      	cmp	r3, #0
     bee:	d1fc      	bne.n	bea <usart_init+0x1b2>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write configuration to CTRLB */
	usart_hw->CTRLB.reg = ctrlb;
     bf0:	4653      	mov	r3, sl
     bf2:	6059      	str	r1, [r3, #4]
     bf4:	682a      	ldr	r2, [r5, #0]
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
     bf6:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
     bf8:	2b00      	cmp	r3, #0
     bfa:	d1fc      	bne.n	bf6 <usart_init+0x1be>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write configuration to CTRLA */
	usart_hw->CTRLA.reg = ctrla;
     bfc:	4652      	mov	r2, sl
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
     bfe:	a908      	add	r1, sp, #32
     c00:	6017      	str	r7, [r2, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
     c02:	734b      	strb	r3, [r1, #13]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
	config->powersave    = false;
     c04:	73cb      	strb	r3, [r1, #15]
	}

	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
     c06:	738b      	strb	r3, [r1, #14]

	uint32_t pad_pinmuxes[] = {
     c08:	4643      	mov	r3, r8
     c0a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
     c0c:	2280      	movs	r2, #128	; 0x80
     c0e:	930c      	str	r3, [sp, #48]	; 0x30
     c10:	4643      	mov	r3, r8
     c12:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     c14:	2700      	movs	r7, #0
     c16:	6073      	str	r3, [r6, #4]
     c18:	4643      	mov	r3, r8
     c1a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     c1c:	730a      	strb	r2, [r1, #12]
     c1e:	60b3      	str	r3, [r6, #8]
     c20:	4643      	mov	r3, r8
     c22:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     c24:	60f3      	str	r3, [r6, #12]
	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];

		if (current_pinmux == PINMUX_DEFAULT) {
			current_pinmux = _sercom_get_default_pad(hw, pad);
     c26:	4b45      	ldr	r3, [pc, #276]	; (d3c <usart_init+0x304>)
     c28:	469b      	mov	fp, r3
		}

		if (current_pinmux != PINMUX_UNUSED) {
			pin_conf.mux_position = current_pinmux & 0xFFFF;
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
     c2a:	4b45      	ldr	r3, [pc, #276]	; (d40 <usart_init+0x308>)
     c2c:	469a      	mov	sl, r3
     c2e:	00bb      	lsls	r3, r7, #2
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
     c30:	58f0      	ldr	r0, [r6, r3]
     c32:	b2f9      	uxtb	r1, r7

		if (current_pinmux == PINMUX_DEFAULT) {
     c34:	2800      	cmp	r0, #0
     c36:	d02e      	beq.n	c96 <usart_init+0x25e>
			current_pinmux = _sercom_get_default_pad(hw, pad);
		}

		if (current_pinmux != PINMUX_UNUSED) {
     c38:	1c43      	adds	r3, r0, #1
     c3a:	d005      	beq.n	c48 <usart_init+0x210>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
     c3c:	ab08      	add	r3, sp, #32
     c3e:	7318      	strb	r0, [r3, #12]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
     c40:	0c00      	lsrs	r0, r0, #16
     c42:	b2c0      	uxtb	r0, r0
     c44:	a90b      	add	r1, sp, #44	; 0x2c
     c46:	47d0      	blx	sl
     c48:	3701      	adds	r7, #1
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
     c4a:	2f04      	cmp	r7, #4
     c4c:	d1ef      	bne.n	c2e <usart_init+0x1f6>
	}

#if USART_CALLBACK_MODE == true
	/* Initialize parameters */
	for (uint32_t i = 0; i < USART_CALLBACK_N; i++) {
		module->callback[i]            = NULL;
     c4e:	1c28      	adds	r0, r5, #0
     c50:	2100      	movs	r1, #0
     c52:	2218      	movs	r2, #24
     c54:	4b3b      	ldr	r3, [pc, #236]	; (d44 <usart_init+0x30c>)
     c56:	300c      	adds	r0, #12
     c58:	4798      	blx	r3
	}

	module->tx_buffer_ptr              = NULL;
     c5a:	2200      	movs	r2, #0
	module->rx_buffer_ptr              = NULL;
	module->remaining_tx_buffer_length = 0x0000;
     c5c:	2300      	movs	r3, #0
     c5e:	85ea      	strh	r2, [r5, #46]	; 0x2e
	/* Initialize parameters */
	for (uint32_t i = 0; i < USART_CALLBACK_N; i++) {
		module->callback[i]            = NULL;
	}

	module->tx_buffer_ptr              = NULL;
     c60:	62aa      	str	r2, [r5, #40]	; 0x28
	module->rx_buffer_ptr              = NULL;
     c62:	626a      	str	r2, [r5, #36]	; 0x24
	module->remaining_tx_buffer_length = 0x0000;
	module->remaining_rx_buffer_length = 0x0000;
     c64:	85aa      	strh	r2, [r5, #44]	; 0x2c
	module->callback_reg_mask          = 0x00;
     c66:	3230      	adds	r2, #48	; 0x30
     c68:	54ab      	strb	r3, [r5, r2]
	module->callback_enable_mask       = 0x00;
     c6a:	3201      	adds	r2, #1
     c6c:	54ab      	strb	r3, [r5, r2]
	module->rx_status                  = STATUS_OK;
     c6e:	3201      	adds	r2, #1
     c70:	54ab      	strb	r3, [r5, r2]
	module->tx_status                  = STATUS_OK;
     c72:	3201      	adds	r2, #1
     c74:	54ab      	strb	r3, [r5, r2]

	/* Set interrupt handler and register USART software module struct in
	 * look-up table */
	uint8_t instance_index = _sercom_get_sercom_inst_index(module->hw);
     c76:	6828      	ldr	r0, [r5, #0]
     c78:	47c8      	blx	r9
     c7a:	1c04      	adds	r4, r0, #0
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
     c7c:	4b32      	ldr	r3, [pc, #200]	; (d48 <usart_init+0x310>)
     c7e:	4933      	ldr	r1, [pc, #204]	; (d4c <usart_init+0x314>)
     c80:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
     c82:	4b33      	ldr	r3, [pc, #204]	; (d50 <usart_init+0x318>)
     c84:	00a4      	lsls	r4, r4, #2
     c86:	50e5      	str	r5, [r4, r3]
#endif

	return status_code;
     c88:	2000      	movs	r0, #0
     c8a:	e6ea      	b.n	a62 <usart_init+0x2a>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
     c8c:	2308      	movs	r3, #8
     c8e:	9309      	str	r3, [sp, #36]	; 0x24
		case USART_SAMPLE_RATE_16X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
     c90:	2300      	movs	r3, #0
     c92:	9308      	str	r3, [sp, #32]
     c94:	e73a      	b.n	b0c <usart_init+0xd4>
	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];

		if (current_pinmux == PINMUX_DEFAULT) {
			current_pinmux = _sercom_get_default_pad(hw, pad);
     c96:	1c20      	adds	r0, r4, #0
     c98:	47d8      	blx	fp
     c9a:	e7cd      	b.n	c38 <usart_init+0x200>
#ifdef FEATURE_USART_ISO7816
	if(config->iso7816_config.enabled) {
		baud = config->baudrate;
	} else {
#endif
	switch (transfer_mode)
     c9c:	2100      	movs	r1, #0
     c9e:	e755      	b.n	b4c <usart_init+0x114>
			}

			break;

		case USART_TRANSFER_ASYNCHRONOUSLY:
			if (config->use_external_clock) {
     ca0:	2327      	movs	r3, #39	; 0x27
     ca2:	4642      	mov	r2, r8
     ca4:	5cd3      	ldrb	r3, [r2, r3]
     ca6:	2b00      	cmp	r3, #0
     ca8:	d027      	beq.n	cfa <usart_init+0x2c2>
				status_code =
     caa:	9b09      	ldr	r3, [sp, #36]	; 0x24
     cac:	9300      	str	r3, [sp, #0]
     cae:	6a10      	ldr	r0, [r2, #32]
     cb0:	6a91      	ldr	r1, [r2, #40]	; 0x28
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
     cb2:	1c32      	adds	r2, r6, #0
     cb4:	9b08      	ldr	r3, [sp, #32]
     cb6:	4f27      	ldr	r7, [pc, #156]	; (d54 <usart_init+0x31c>)
     cb8:	47b8      	blx	r7

			break;
	}

	/* Check if calculating the baudrate failed */
	if (status_code != STATUS_OK) {
     cba:	2800      	cmp	r0, #0
     cbc:	d000      	beq.n	cc0 <usart_init+0x288>
     cbe:	e6d0      	b.n	a62 <usart_init+0x2a>
     cc0:	8831      	ldrh	r1, [r6, #0]
     cc2:	e743      	b.n	b4c <usart_init+0x114>

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;

#ifdef FEATURE_USART_OVER_SAMPLE
	switch (config->sample_rate) {
     cc4:	2380      	movs	r3, #128	; 0x80
     cc6:	019b      	lsls	r3, r3, #6
     cc8:	429a      	cmp	r2, r3
     cca:	d104      	bne.n	cd6 <usart_init+0x29e>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
			break;
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
     ccc:	2310      	movs	r3, #16
     cce:	9309      	str	r3, [sp, #36]	; 0x24
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
			break;
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
     cd0:	3b0f      	subs	r3, #15
     cd2:	9308      	str	r3, [sp, #32]
     cd4:	e71a      	b.n	b0c <usart_init+0xd4>
#endif
	uint16_t baud  = 0;
	uint32_t transfer_mode;

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
     cd6:	2310      	movs	r3, #16
     cd8:	9309      	str	r3, [sp, #36]	; 0x24
	uint32_t ctrlc = 0;
#endif
	uint16_t baud  = 0;
	uint32_t transfer_mode;

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
     cda:	2300      	movs	r3, #0
     cdc:	9308      	str	r3, [sp, #32]
     cde:	e715      	b.n	b0c <usart_init+0xd4>
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
     ce0:	2308      	movs	r3, #8
     ce2:	9309      	str	r3, [sp, #36]	; 0x24
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
     ce4:	3b07      	subs	r3, #7
     ce6:	9308      	str	r3, [sp, #32]
     ce8:	e710      	b.n	b0c <usart_init+0xd4>
	if (config->parity != USART_PARITY_NONE) {
		ctrla |= SERCOM_USART_CTRLA_FORM(1);
		ctrlb |= config->parity;
	} else {
#ifdef FEATURE_USART_LIN_SLAVE
		if(config->lin_slave_enable) {
     cea:	7ed3      	ldrb	r3, [r2, #27]
     cec:	2b00      	cmp	r3, #0
     cee:	d100      	bne.n	cf2 <usart_init+0x2ba>
     cf0:	e76f      	b.n	bd2 <usart_init+0x19a>
			ctrla |= SERCOM_USART_CTRLA_FORM(0x4);
     cf2:	2380      	movs	r3, #128	; 0x80
     cf4:	04db      	lsls	r3, r3, #19
     cf6:	431f      	orrs	r7, r3
     cf8:	e76b      	b.n	bd2 <usart_init+0x19a>
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
     cfa:	6a13      	ldr	r3, [r2, #32]
     cfc:	b2c0      	uxtb	r0, r0
     cfe:	1c1f      	adds	r7, r3, #0
     d00:	4b15      	ldr	r3, [pc, #84]	; (d58 <usart_init+0x320>)
     d02:	4798      	blx	r3
			if (config->use_external_clock) {
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
     d04:	9b09      	ldr	r3, [sp, #36]	; 0x24
						_sercom_get_async_baud_val(config->baudrate,
     d06:	1c01      	adds	r1, r0, #0
			if (config->use_external_clock) {
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
     d08:	9300      	str	r3, [sp, #0]
     d0a:	1c38      	adds	r0, r7, #0
     d0c:	e7d1      	b.n	cb2 <usart_init+0x27a>
#endif
	switch (transfer_mode)
	{
		case USART_TRANSFER_SYNCHRONOUSLY:
			if (!config->use_external_clock) {
				status_code = _sercom_get_sync_baud_val(config->baudrate,
     d0e:	6a13      	ldr	r3, [r2, #32]
     d10:	b2c0      	uxtb	r0, r0
     d12:	1c1f      	adds	r7, r3, #0
     d14:	4b10      	ldr	r3, [pc, #64]	; (d58 <usart_init+0x320>)
     d16:	4798      	blx	r3
     d18:	1c32      	adds	r2, r6, #0
     d1a:	1c01      	adds	r1, r0, #0
     d1c:	4b0f      	ldr	r3, [pc, #60]	; (d5c <usart_init+0x324>)
     d1e:	1c38      	adds	r0, r7, #0
     d20:	4798      	blx	r3
     d22:	e7ca      	b.n	cba <usart_init+0x282>
     d24:	000004d1 	.word	0x000004d1
     d28:	40000400 	.word	0x40000400
     d2c:	00001d99 	.word	0x00001d99
     d30:	00001dfd 	.word	0x00001dfd
     d34:	00000329 	.word	0x00000329
     d38:	41002000 	.word	0x41002000
     d3c:	00000371 	.word	0x00000371
     d40:	00001ed1 	.word	0x00001ed1
     d44:	0000280b 	.word	0x0000280b
     d48:	000017c9 	.word	0x000017c9
     d4c:	00000e15 	.word	0x00000e15
     d50:	200001b0 	.word	0x200001b0
     d54:	0000013d 	.word	0x0000013d
     d58:	00001e2d 	.word	0x00001e2d
     d5c:	00000115 	.word	0x00000115

00000d60 <usart_write_wait>:
 * \retval STATUS_ERR_DENIED If the transmitter is not enabled
 */
enum status_code usart_write_wait(
		struct usart_module *const module,
		const uint16_t tx_data)
{
     d60:	b510      	push	{r4, lr}

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the transmitter is enabled */
	if (!(module->transmitter_enabled)) {
     d62:	79c4      	ldrb	r4, [r0, #7]
 * \retval STATUS_ERR_DENIED If the transmitter is not enabled
 */
enum status_code usart_write_wait(
		struct usart_module *const module,
		const uint16_t tx_data)
{
     d64:	1c02      	adds	r2, r0, #0
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
     d66:	6803      	ldr	r3, [r0, #0]

	/* Check that the transmitter is enabled */
	if (!(module->transmitter_enabled)) {
		return STATUS_ERR_DENIED;
     d68:	201c      	movs	r0, #28

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the transmitter is enabled */
	if (!(module->transmitter_enabled)) {
     d6a:	2c00      	cmp	r4, #0
     d6c:	d100      	bne.n	d70 <usart_write_wait+0x10>
	while (!(usart_hw->INTFLAG.reg & SERCOM_USART_INTFLAG_TXC)) {
		/* Wait until data is sent */
	}

	return STATUS_OK;
}
     d6e:	bd10      	pop	{r4, pc}
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_tx_buffer_length > 0) {
     d70:	8dd2      	ldrh	r2, [r2, #46]	; 0x2e
		return STATUS_BUSY;
     d72:	3817      	subs	r0, #23
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_tx_buffer_length > 0) {
     d74:	2a00      	cmp	r2, #0
     d76:	d1fa      	bne.n	d6e <usart_write_wait+0xe>
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
     d78:	69da      	ldr	r2, [r3, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
     d7a:	2a00      	cmp	r2, #0
     d7c:	d1fc      	bne.n	d78 <usart_write_wait+0x18>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write data to USART module */
	usart_hw->DATA.reg = tx_data;
     d7e:	8519      	strh	r1, [r3, #40]	; 0x28

	while (!(usart_hw->INTFLAG.reg & SERCOM_USART_INTFLAG_TXC)) {
     d80:	2102      	movs	r1, #2
     d82:	7e1a      	ldrb	r2, [r3, #24]
     d84:	4211      	tst	r1, r2
     d86:	d0fc      	beq.n	d82 <usart_write_wait+0x22>
		/* Wait until data is sent */
	}

	return STATUS_OK;
     d88:	2000      	movs	r0, #0
     d8a:	e7f0      	b.n	d6e <usart_write_wait+0xe>

00000d8c <usart_read_wait>:
 * \retval STATUS_ERR_DENIED        If the receiver is not enabled
 */
enum status_code usart_read_wait(
		struct usart_module *const module,
		uint16_t *const rx_data)
{
     d8c:	b510      	push	{r4, lr}

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the receiver is enabled */
	if (!(module->receiver_enabled)) {
     d8e:	7982      	ldrb	r2, [r0, #6]
 * \retval STATUS_ERR_DENIED        If the receiver is not enabled
 */
enum status_code usart_read_wait(
		struct usart_module *const module,
		uint16_t *const rx_data)
{
     d90:	1c03      	adds	r3, r0, #0

	/* Error variable */
	uint8_t error_code;

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
     d92:	6804      	ldr	r4, [r0, #0]

	/* Check that the receiver is enabled */
	if (!(module->receiver_enabled)) {
		return STATUS_ERR_DENIED;
     d94:	201c      	movs	r0, #28

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the receiver is enabled */
	if (!(module->receiver_enabled)) {
     d96:	2a00      	cmp	r2, #0
     d98:	d100      	bne.n	d9c <usart_read_wait+0x10>

	/* Read data from USART module */
	*rx_data = usart_hw->DATA.reg;

	return STATUS_OK;
}
     d9a:	bd10      	pop	{r4, pc}
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_rx_buffer_length > 0) {
     d9c:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
		return STATUS_BUSY;
     d9e:	3817      	subs	r0, #23
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_rx_buffer_length > 0) {
     da0:	2b00      	cmp	r3, #0
     da2:	d1fa      	bne.n	d9a <usart_read_wait+0xe>
		return STATUS_BUSY;
	}
#endif

	/* Check if USART has new data */
	if (!(usart_hw->INTFLAG.reg & SERCOM_USART_INTFLAG_RXC)) {
     da4:	7e23      	ldrb	r3, [r4, #24]
     da6:	075b      	lsls	r3, r3, #29
     da8:	d5f7      	bpl.n	d9a <usart_read_wait+0xe>
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
     daa:	69e3      	ldr	r3, [r4, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
     dac:	2b00      	cmp	r3, #0
     dae:	d1fc      	bne.n	daa <usart_read_wait+0x1e>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Read out the status code and mask away all but the 3 LSBs*/
	error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
     db0:	8b63      	ldrh	r3, [r4, #26]
     db2:	b2db      	uxtb	r3, r3

	/* Check if an error has occurred during the receiving */
	if (error_code) {
     db4:	069a      	lsls	r2, r3, #26
     db6:	d005      	beq.n	dc4 <usart_read_wait+0x38>
		/* Check which error occurred */
		if (error_code & SERCOM_USART_STATUS_FERR) {
     db8:	2202      	movs	r2, #2
     dba:	421a      	tst	r2, r3
     dbc:	d006      	beq.n	dcc <usart_read_wait+0x40>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_FERR;
     dbe:	8362      	strh	r2, [r4, #26]

			return STATUS_ERR_BAD_FORMAT;
     dc0:	201a      	movs	r0, #26
     dc2:	e7ea      	b.n	d9a <usart_read_wait+0xe>
		}
#endif
	}

	/* Read data from USART module */
	*rx_data = usart_hw->DATA.reg;
     dc4:	8d23      	ldrh	r3, [r4, #40]	; 0x28

	return STATUS_OK;
     dc6:	2000      	movs	r0, #0
		}
#endif
	}

	/* Read data from USART module */
	*rx_data = usart_hw->DATA.reg;
     dc8:	800b      	strh	r3, [r1, #0]

	return STATUS_OK;
     dca:	e7e6      	b.n	d9a <usart_read_wait+0xe>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_FERR;

			return STATUS_ERR_BAD_FORMAT;
		} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
     dcc:	2204      	movs	r2, #4
     dce:	421a      	tst	r2, r3
     dd0:	d002      	beq.n	dd8 <usart_read_wait+0x4c>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_BUFOVF;
     dd2:	8362      	strh	r2, [r4, #26]

			return STATUS_ERR_OVERFLOW;
     dd4:	201e      	movs	r0, #30
     dd6:	e7e0      	b.n	d9a <usart_read_wait+0xe>
		} else if (error_code & SERCOM_USART_STATUS_PERR) {
     dd8:	2201      	movs	r2, #1
     dda:	421a      	tst	r2, r3
     ddc:	d002      	beq.n	de4 <usart_read_wait+0x58>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_PERR;
     dde:	8362      	strh	r2, [r4, #26]

			return STATUS_ERR_BAD_DATA;
     de0:	2013      	movs	r0, #19
     de2:	e7da      	b.n	d9a <usart_read_wait+0xe>
		}
#ifdef FEATURE_USART_LIN_SLAVE
		else if (error_code & SERCOM_USART_STATUS_ISF) {
     de4:	2210      	movs	r2, #16
     de6:	4213      	tst	r3, r2
     de8:	d002      	beq.n	df0 <usart_read_wait+0x64>
			/* Clear flag by writing 1 to it  and
			 *  return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_ISF;
     dea:	8362      	strh	r2, [r4, #26]

			return STATUS_ERR_PROTOCOL;
     dec:	2042      	movs	r0, #66	; 0x42
     dee:	e7d4      	b.n	d9a <usart_read_wait+0xe>
		}
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
		else if (error_code & SERCOM_USART_STATUS_COLL) {
     df0:	2220      	movs	r2, #32
     df2:	4213      	tst	r3, r2
     df4:	d0e6      	beq.n	dc4 <usart_read_wait+0x38>
			/* Clear flag by writing 1 to it
			 *  return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_COLL;
     df6:	8362      	strh	r2, [r4, #26]

			return STATUS_ERR_PACKET_COLLISION;
     df8:	2041      	movs	r0, #65	; 0x41
     dfa:	e7ce      	b.n	d9a <usart_read_wait+0xe>

00000dfc <usart_register_callback>:
	/* Sanity check arguments */
	Assert(module);
	Assert(callback_func);

	/* Register callback function */
	module->callback[callback_type] = callback_func;
     dfc:	1c93      	adds	r3, r2, #2
     dfe:	009b      	lsls	r3, r3, #2
     e00:	18c3      	adds	r3, r0, r3
     e02:	6059      	str	r1, [r3, #4]

	/* Set the bit corresponding to the callback_type */
	module->callback_reg_mask |= (1 << callback_type);
     e04:	2301      	movs	r3, #1
     e06:	4093      	lsls	r3, r2
     e08:	2130      	movs	r1, #48	; 0x30
     e0a:	1c1a      	adds	r2, r3, #0
     e0c:	5c43      	ldrb	r3, [r0, r1]
     e0e:	431a      	orrs	r2, r3
     e10:	5442      	strb	r2, [r0, r1]
}
     e12:	4770      	bx	lr

00000e14 <_usart_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _usart_interrupt_handler(
		uint8_t instance)
{
     e14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint16_t callback_status;
	uint8_t error_code;


	/* Get device instance from the look-up table */
	struct usart_module *module
     e16:	4b62      	ldr	r3, [pc, #392]	; (fa0 <_usart_interrupt_handler+0x18c>)
     e18:	0080      	lsls	r0, r0, #2
     e1a:	58c5      	ldr	r5, [r0, r3]
		= (struct usart_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomUsart *const usart_hw
		= &(module->hw->USART);
     e1c:	682c      	ldr	r4, [r5, #0]
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
     e1e:	69e3      	ldr	r3, [r4, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
     e20:	2b00      	cmp	r3, #0
     e22:	d1fc      	bne.n	e1e <_usart_interrupt_handler+0xa>

	/* Wait for the synchronization to complete */
	_usart_wait_for_sync(module);

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
     e24:	7e26      	ldrb	r6, [r4, #24]
	interrupt_status &= usart_hw->INTENSET.reg;
     e26:	7da3      	ldrb	r3, [r4, #22]
	callback_status = module->callback_reg_mask &
     e28:	2230      	movs	r2, #48	; 0x30
	/* Wait for the synchronization to complete */
	_usart_wait_for_sync(module);

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
	interrupt_status &= usart_hw->INTENSET.reg;
     e2a:	401e      	ands	r6, r3
	callback_status = module->callback_reg_mask &
			module->callback_enable_mask;
     e2c:	2331      	movs	r3, #49	; 0x31
	_usart_wait_for_sync(module);

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
	interrupt_status &= usart_hw->INTENSET.reg;
	callback_status = module->callback_reg_mask &
     e2e:	5caf      	ldrb	r7, [r5, r2]
     e30:	5ceb      	ldrb	r3, [r5, r3]
     e32:	401f      	ands	r7, r3
			module->callback_enable_mask;

	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
     e34:	2301      	movs	r3, #1
     e36:	4233      	tst	r3, r6
     e38:	d019      	beq.n	e6e <_usart_interrupt_handler+0x5a>
		if (module->remaining_tx_buffer_length) {
     e3a:	8dea      	ldrh	r2, [r5, #46]	; 0x2e
     e3c:	2a00      	cmp	r2, #0
     e3e:	d04d      	beq.n	edc <_usart_interrupt_handler+0xc8>
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
     e40:	6aaa      	ldr	r2, [r5, #40]	; 0x28
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;
     e42:	1c51      	adds	r1, r2, #1
	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
		if (module->remaining_tx_buffer_length) {
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
     e44:	7813      	ldrb	r3, [r2, #0]
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;
     e46:	62a9      	str	r1, [r5, #40]	; 0x28

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
     e48:	7969      	ldrb	r1, [r5, #5]
	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
		if (module->remaining_tx_buffer_length) {
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
     e4a:	b2db      	uxtb	r3, r3
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
     e4c:	2901      	cmp	r1, #1
     e4e:	d100      	bne.n	e52 <_usart_interrupt_handler+0x3e>
     e50:	e075      	b.n	f3e <_usart_interrupt_handler+0x12a>
	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
		if (module->remaining_tx_buffer_length) {
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
     e52:	b29b      	uxth	r3, r3
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
				/* Increment 8-bit pointer */
				(module->tx_buffer_ptr)++;
			}
			/* Write the data to send */
			usart_hw->DATA.reg = (data_to_send & SERCOM_USART_DATA_MASK);
     e54:	05db      	lsls	r3, r3, #23
     e56:	0ddb      	lsrs	r3, r3, #23
     e58:	8523      	strh	r3, [r4, #40]	; 0x28

			if (--(module->remaining_tx_buffer_length) == 0) {
     e5a:	8deb      	ldrh	r3, [r5, #46]	; 0x2e
     e5c:	3b01      	subs	r3, #1
     e5e:	b29b      	uxth	r3, r3
     e60:	85eb      	strh	r3, [r5, #46]	; 0x2e
     e62:	2b00      	cmp	r3, #0
     e64:	d103      	bne.n	e6e <_usart_interrupt_handler+0x5a>
				/* Disable the Data Register Empty Interrupt */
				usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
     e66:	3301      	adds	r3, #1
     e68:	7523      	strb	r3, [r4, #20]
				/* Enable Transmission Complete interrupt */
				usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_TXC;
     e6a:	3301      	adds	r3, #1
     e6c:	75a3      	strb	r3, [r4, #22]

	/* Check if the Transmission Complete interrupt has occurred and
	 * that the transmit buffer is empty */
	}

	if (interrupt_status & SERCOM_USART_INTFLAG_TXC) {
     e6e:	2302      	movs	r3, #2
     e70:	4233      	tst	r3, r6
     e72:	d005      	beq.n	e80 <_usart_interrupt_handler+0x6c>

		/* Disable TX Complete Interrupt, and set STATUS_OK */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_TXC;
		module->tx_status = STATUS_OK;
     e74:	2200      	movs	r2, #0
	}

	if (interrupt_status & SERCOM_USART_INTFLAG_TXC) {

		/* Disable TX Complete Interrupt, and set STATUS_OK */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_TXC;
     e76:	7523      	strb	r3, [r4, #20]
		module->tx_status = STATUS_OK;
     e78:	3331      	adds	r3, #49	; 0x31
     e7a:	54ea      	strb	r2, [r5, r3]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BUFFER_TRANSMITTED)) {
     e7c:	07fb      	lsls	r3, r7, #31
     e7e:	d43b      	bmi.n	ef8 <_usart_interrupt_handler+0xe4>

	/* Check if the Receive Complete interrupt has occurred, and that
	 * there's more data to receive */
	}

	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {
     e80:	2304      	movs	r3, #4
     e82:	4233      	tst	r3, r6
     e84:	d012      	beq.n	eac <_usart_interrupt_handler+0x98>

		if (module->remaining_rx_buffer_length) {
     e86:	8daa      	ldrh	r2, [r5, #44]	; 0x2c
     e88:	2a00      	cmp	r2, #0
     e8a:	d025      	beq.n	ed8 <_usart_interrupt_handler+0xc4>
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
     e8c:	8b63      	ldrh	r3, [r4, #26]
     e8e:	b2db      	uxtb	r3, r3
#if !SAMD20
			/* CTS status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_CTS) {
     e90:	071a      	lsls	r2, r3, #28
     e92:	d435      	bmi.n	f00 <_usart_interrupt_handler+0xec>

	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {

		if (module->remaining_rx_buffer_length) {
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
     e94:	223f      	movs	r2, #63	; 0x3f
     e96:	4013      	ands	r3, r2
			if(error_code & SERCOM_USART_STATUS_TXE) {
				error_code &= ~SERCOM_USART_STATUS_TXE;
			}
#endif
			/* Check if an error has occurred during the receiving */
			if (error_code) {
     e98:	d035      	beq.n	f06 <_usart_interrupt_handler+0xf2>
				/* Check which error occurred */
				if (error_code & SERCOM_USART_STATUS_FERR) {
     e9a:	2202      	movs	r2, #2
     e9c:	421a      	tst	r2, r3
     e9e:	d054      	beq.n	f4a <_usart_interrupt_handler+0x136>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_FORMAT;
     ea0:	211a      	movs	r1, #26
     ea2:	2332      	movs	r3, #50	; 0x32
     ea4:	54e9      	strb	r1, [r5, r3]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_FERR;
     ea6:	8362      	strh	r2, [r4, #26]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_COLL;
				}
#endif

				/* Run callback if registered and enabled */
				if (callback_status
     ea8:	077b      	lsls	r3, r7, #29
     eaa:	d459      	bmi.n	f60 <_usart_interrupt_handler+0x14c>
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
		}
	}

#ifdef FEATURE_USART_HARDWARE_FLOW_CONTROL
	if (interrupt_status & SERCOM_USART_INTFLAG_CTSIC) {
     eac:	2310      	movs	r3, #16
     eae:	4233      	tst	r3, r6
     eb0:	d003      	beq.n	eba <_usart_interrupt_handler+0xa6>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_CTSIC;
     eb2:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_CTSIC;
     eb4:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_CTS_INPUT_CHANGE)) {
     eb6:	423b      	tst	r3, r7
     eb8:	d116      	bne.n	ee8 <_usart_interrupt_handler+0xd4>
		}
	}
#endif

#ifdef FEATURE_USART_LIN_SLAVE
	if (interrupt_status & SERCOM_USART_INTFLAG_RXBRK) {
     eba:	2320      	movs	r3, #32
     ebc:	4233      	tst	r3, r6
     ebe:	d003      	beq.n	ec8 <_usart_interrupt_handler+0xb4>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXBRK;
     ec0:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXBRK;
     ec2:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BREAK_RECEIVED)) {
     ec4:	073b      	lsls	r3, r7, #28
     ec6:	d413      	bmi.n	ef0 <_usart_interrupt_handler+0xdc>
		}
	}
#endif

#ifdef FEATURE_USART_START_FRAME_DECTION
	if (interrupt_status & SERCOM_USART_INTFLAG_RXS) {
     ec8:	2308      	movs	r3, #8
     eca:	4233      	tst	r3, r6
     ecc:	d003      	beq.n	ed6 <_usart_interrupt_handler+0xc2>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXS;
     ece:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXS;
     ed0:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_START_RECEIVED)) {
     ed2:	06bb      	lsls	r3, r7, #26
     ed4:	d404      	bmi.n	ee0 <_usart_interrupt_handler+0xcc>
			(*(module->callback[USART_CALLBACK_START_RECEIVED]))(module);
		}
	}
#endif
}
     ed6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					}
				}
			}
		} else {
			/* This should not happen. Disable Receive Complete interrupt. */
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
     ed8:	7523      	strb	r3, [r4, #20]
     eda:	e7e7      	b.n	eac <_usart_interrupt_handler+0x98>
				/* Enable Transmission Complete interrupt */
				usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_TXC;

			}
		} else {
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
     edc:	7523      	strb	r3, [r4, #20]
     ede:	e7c6      	b.n	e6e <_usart_interrupt_handler+0x5a>
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXS;

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_START_RECEIVED)) {
			(*(module->callback[USART_CALLBACK_START_RECEIVED]))(module);
     ee0:	6a2b      	ldr	r3, [r5, #32]
     ee2:	1c28      	adds	r0, r5, #0
     ee4:	4798      	blx	r3
     ee6:	e7f6      	b.n	ed6 <_usart_interrupt_handler+0xc2>
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_CTSIC;

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_CTS_INPUT_CHANGE)) {
			(*(module->callback[USART_CALLBACK_CTS_INPUT_CHANGE]))(module);
     ee8:	1c28      	adds	r0, r5, #0
     eea:	69eb      	ldr	r3, [r5, #28]
     eec:	4798      	blx	r3
     eee:	e7e4      	b.n	eba <_usart_interrupt_handler+0xa6>
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXBRK;

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BREAK_RECEIVED)) {
			(*(module->callback[USART_CALLBACK_BREAK_RECEIVED]))(module);
     ef0:	1c28      	adds	r0, r5, #0
     ef2:	69ab      	ldr	r3, [r5, #24]
     ef4:	4798      	blx	r3
     ef6:	e7e7      	b.n	ec8 <_usart_interrupt_handler+0xb4>
		usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_TXC;
		module->tx_status = STATUS_OK;

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BUFFER_TRANSMITTED)) {
			(*(module->callback[USART_CALLBACK_BUFFER_TRANSMITTED]))(module);
     ef8:	1c28      	adds	r0, r5, #0
     efa:	68eb      	ldr	r3, [r5, #12]
     efc:	4798      	blx	r3
     efe:	e7bf      	b.n	e80 <_usart_interrupt_handler+0x6c>
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
#if !SAMD20
			/* CTS status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_CTS) {
				error_code &= ~SERCOM_USART_STATUS_CTS;
     f00:	2237      	movs	r2, #55	; 0x37
     f02:	4013      	ands	r3, r2
			if(error_code & SERCOM_USART_STATUS_TXE) {
				error_code &= ~SERCOM_USART_STATUS_TXE;
			}
#endif
			/* Check if an error has occurred during the receiving */
			if (error_code) {
     f04:	d1c9      	bne.n	e9a <_usart_interrupt_handler+0x86>

			} else {

				/* Read current packet from DATA register,
				 * increment buffer pointer and decrement buffer length */
				uint16_t received_data = (usart_hw->DATA.reg & SERCOM_USART_DATA_MASK);
     f06:	8d23      	ldrh	r3, [r4, #40]	; 0x28

				/* Read value will be at least 8-bits long */
				*(module->rx_buffer_ptr) = received_data;
     f08:	6a69      	ldr	r1, [r5, #36]	; 0x24

			} else {

				/* Read current packet from DATA register,
				 * increment buffer pointer and decrement buffer length */
				uint16_t received_data = (usart_hw->DATA.reg & SERCOM_USART_DATA_MASK);
     f0a:	05db      	lsls	r3, r3, #23
     f0c:	0ddb      	lsrs	r3, r3, #23

				/* Read value will be at least 8-bits long */
				*(module->rx_buffer_ptr) = received_data;
     f0e:	b2da      	uxtb	r2, r3
     f10:	700a      	strb	r2, [r1, #0]
				/* Increment 8-bit pointer */
				module->rx_buffer_ptr += 1;
     f12:	6a6a      	ldr	r2, [r5, #36]	; 0x24
     f14:	1c51      	adds	r1, r2, #1
     f16:	6269      	str	r1, [r5, #36]	; 0x24

				if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
     f18:	7969      	ldrb	r1, [r5, #5]
     f1a:	2901      	cmp	r1, #1
     f1c:	d029      	beq.n	f72 <_usart_interrupt_handler+0x15e>
					/* Increment 8-bit pointer */
					module->rx_buffer_ptr += 1;
				}

				/* Check if the last character have been received */
				if(--(module->remaining_rx_buffer_length) == 0) {
     f1e:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
     f20:	3b01      	subs	r3, #1
     f22:	b29b      	uxth	r3, r3
     f24:	85ab      	strh	r3, [r5, #44]	; 0x2c
     f26:	2b00      	cmp	r3, #0
     f28:	d1c0      	bne.n	eac <_usart_interrupt_handler+0x98>
					/* Disable RX Complete Interrupt,
					 * and set STATUS_OK */
					usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
     f2a:	2204      	movs	r2, #4
     f2c:	7522      	strb	r2, [r4, #20]
					module->rx_status = STATUS_OK;
     f2e:	322e      	adds	r2, #46	; 0x2e
     f30:	54ab      	strb	r3, [r5, r2]

					/* Run callback if registered and enabled */
					if (callback_status
     f32:	07bb      	lsls	r3, r7, #30
     f34:	d5ba      	bpl.n	eac <_usart_interrupt_handler+0x98>
							& (1 << USART_CALLBACK_BUFFER_RECEIVED)) {
						(*(module->callback[USART_CALLBACK_BUFFER_RECEIVED]))(module);
     f36:	1c28      	adds	r0, r5, #0
     f38:	692b      	ldr	r3, [r5, #16]
     f3a:	4798      	blx	r3
     f3c:	e7b6      	b.n	eac <_usart_interrupt_handler+0x98>
			uint16_t data_to_send = *(module->tx_buffer_ptr);
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
     f3e:	7851      	ldrb	r1, [r2, #1]
				/* Increment 8-bit pointer */
				(module->tx_buffer_ptr)++;
     f40:	3202      	adds	r2, #2
			uint16_t data_to_send = *(module->tx_buffer_ptr);
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
     f42:	0209      	lsls	r1, r1, #8
     f44:	430b      	orrs	r3, r1
				/* Increment 8-bit pointer */
				(module->tx_buffer_ptr)++;
     f46:	62aa      	str	r2, [r5, #40]	; 0x28
     f48:	e784      	b.n	e54 <_usart_interrupt_handler+0x40>
				/* Check which error occurred */
				if (error_code & SERCOM_USART_STATUS_FERR) {
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_FORMAT;
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_FERR;
				} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
     f4a:	2204      	movs	r2, #4
     f4c:	421a      	tst	r2, r3
     f4e:	d10b      	bne.n	f68 <_usart_interrupt_handler+0x154>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_OVERFLOW;
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_BUFOVF;
				} else if (error_code & SERCOM_USART_STATUS_PERR) {
     f50:	2201      	movs	r2, #1
     f52:	421a      	tst	r2, r3
     f54:	d013      	beq.n	f7e <_usart_interrupt_handler+0x16a>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_DATA;
     f56:	2113      	movs	r1, #19
     f58:	2332      	movs	r3, #50	; 0x32
     f5a:	54e9      	strb	r1, [r5, r3]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_PERR;
     f5c:	8362      	strh	r2, [r4, #26]
     f5e:	e7a3      	b.n	ea8 <_usart_interrupt_handler+0x94>
#endif

				/* Run callback if registered and enabled */
				if (callback_status
						& (1 << USART_CALLBACK_ERROR)) {
					(*(module->callback[USART_CALLBACK_ERROR]))(module);
     f60:	1c28      	adds	r0, r5, #0
     f62:	696b      	ldr	r3, [r5, #20]
     f64:	4798      	blx	r3
     f66:	e7a1      	b.n	eac <_usart_interrupt_handler+0x98>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_FORMAT;
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_FERR;
				} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_OVERFLOW;
     f68:	211e      	movs	r1, #30
     f6a:	2332      	movs	r3, #50	; 0x32
     f6c:	54e9      	strb	r1, [r5, r3]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_BUFOVF;
     f6e:	8362      	strh	r2, [r4, #26]
     f70:	e79a      	b.n	ea8 <_usart_interrupt_handler+0x94>
				/* Increment 8-bit pointer */
				module->rx_buffer_ptr += 1;

				if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
					/* 9-bit data, write next received byte to the buffer */
					*(module->rx_buffer_ptr) = (received_data >> 8);
     f72:	0a1b      	lsrs	r3, r3, #8
     f74:	7053      	strb	r3, [r2, #1]
					/* Increment 8-bit pointer */
					module->rx_buffer_ptr += 1;
     f76:	6a6b      	ldr	r3, [r5, #36]	; 0x24
     f78:	3301      	adds	r3, #1
     f7a:	626b      	str	r3, [r5, #36]	; 0x24
     f7c:	e7cf      	b.n	f1e <_usart_interrupt_handler+0x10a>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_DATA;
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_PERR;
				}
#ifdef FEATURE_USART_LIN_SLAVE
				else if (error_code & SERCOM_USART_STATUS_ISF) {
     f7e:	2210      	movs	r2, #16
     f80:	421a      	tst	r2, r3
     f82:	d004      	beq.n	f8e <_usart_interrupt_handler+0x17a>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PROTOCOL;
     f84:	2142      	movs	r1, #66	; 0x42
     f86:	2332      	movs	r3, #50	; 0x32
     f88:	54e9      	strb	r1, [r5, r3]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_ISF;
     f8a:	8362      	strh	r2, [r4, #26]
     f8c:	e78c      	b.n	ea8 <_usart_interrupt_handler+0x94>
				}
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
				else if (error_code & SERCOM_USART_STATUS_COLL) {
     f8e:	2220      	movs	r2, #32
     f90:	421a      	tst	r2, r3
     f92:	d100      	bne.n	f96 <_usart_interrupt_handler+0x182>
     f94:	e788      	b.n	ea8 <_usart_interrupt_handler+0x94>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PACKET_COLLISION;
     f96:	2141      	movs	r1, #65	; 0x41
     f98:	2332      	movs	r3, #50	; 0x32
     f9a:	54e9      	strb	r1, [r5, r3]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_COLL;
     f9c:	8362      	strh	r2, [r4, #26]
     f9e:	e783      	b.n	ea8 <_usart_interrupt_handler+0x94>
     fa0:	200001b0 	.word	0x200001b0

00000fa4 <spi_set_baudrate>:
 * \retval STATUS_OK               If the configuration was written
 */
enum status_code spi_set_baudrate(
		struct spi_module *const module,
		uint32_t baudrate)
{
     fa4:	b570      	push	{r4, r5, r6, lr}
     fa6:	b082      	sub	sp, #8
	Assert(module);
	Assert(baudrate);
	Assert(module->hw);

	/* Value to write to BAUD register */
	uint16_t baud = 0;
     fa8:	2300      	movs	r3, #0
     faa:	466a      	mov	r2, sp
 * \retval STATUS_OK               If the configuration was written
 */
enum status_code spi_set_baudrate(
		struct spi_module *const module,
		uint32_t baudrate)
{
     fac:	1c05      	adds	r5, r0, #0
     fae:	1c0e      	adds	r6, r1, #0
	Assert(module->hw);

	/* Value to write to BAUD register */
	uint16_t baud = 0;

	SercomSpi *const spi_module = &(module->hw->SPI);
     fb0:	6804      	ldr	r4, [r0, #0]
	Assert(module);
	Assert(baudrate);
	Assert(module->hw);

	/* Value to write to BAUD register */
	uint16_t baud = 0;
     fb2:	80d3      	strh	r3, [r2, #6]

	SercomSpi *const spi_module = &(module->hw->SPI);

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
     fb4:	69e3      	ldr	r3, [r4, #28]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
#  endif

	while (spi_is_syncing(module)) {
     fb6:	2b00      	cmp	r3, #0
     fb8:	d1fc      	bne.n	fb4 <spi_set_baudrate+0x10>
		/* Wait until the synchronization is complete */
	}

	/* Disable SPI */
	spi_module->CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
     fba:	2202      	movs	r2, #2
     fbc:	6823      	ldr	r3, [r4, #0]
     fbe:	4393      	bics	r3, r2
     fc0:	6023      	str	r3, [r4, #0]
     fc2:	6828      	ldr	r0, [r5, #0]

	SercomSpi *const spi_module = &(module->hw->SPI);

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
     fc4:	69c3      	ldr	r3, [r0, #28]
	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Disable the module */
	spi_disable(module);

	while (spi_is_syncing(module)) {
     fc6:	2b00      	cmp	r3, #0
     fc8:	d1fc      	bne.n	fc4 <spi_set_baudrate+0x20>
		/* Wait until the synchronization is complete */
	}

	/* Find frequency of the internal SERCOMi_GCLK_ID_CORE */
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
     fca:	4b12      	ldr	r3, [pc, #72]	; (1014 <spi_set_baudrate+0x70>)
     fcc:	4798      	blx	r3
	uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
     fce:	3014      	adds	r0, #20
	uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
     fd0:	4b11      	ldr	r3, [pc, #68]	; (1018 <spi_set_baudrate+0x74>)
     fd2:	b2c0      	uxtb	r0, r0
     fd4:	4798      	blx	r3

	/* Get baud value, based on baudrate and the internal clock frequency */
	enum status_code error_code = _sercom_get_sync_baud_val(
     fd6:	466b      	mov	r3, sp
	}

	/* Find frequency of the internal SERCOMi_GCLK_ID_CORE */
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
	uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
	uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
     fd8:	1c01      	adds	r1, r0, #0

	/* Get baud value, based on baudrate and the internal clock frequency */
	enum status_code error_code = _sercom_get_sync_baud_val(
     fda:	1d9a      	adds	r2, r3, #6
     fdc:	1c30      	adds	r0, r6, #0
     fde:	4b0f      	ldr	r3, [pc, #60]	; (101c <spi_set_baudrate+0x78>)
     fe0:	4798      	blx	r3
			baudrate, internal_clock, &baud);

	if (error_code != STATUS_OK) {
		/* Baud rate calculation error, return status code */
		return STATUS_ERR_INVALID_ARG;
     fe2:	2317      	movs	r3, #23

	/* Get baud value, based on baudrate and the internal clock frequency */
	enum status_code error_code = _sercom_get_sync_baud_val(
			baudrate, internal_clock, &baud);

	if (error_code != STATUS_OK) {
     fe4:	2800      	cmp	r0, #0
     fe6:	d002      	beq.n	fee <spi_set_baudrate+0x4a>
	while (spi_is_syncing(module)) {
		/* Wait until the synchronization is complete */
	}

	return STATUS_OK;
}
     fe8:	1c18      	adds	r0, r3, #0
     fea:	b002      	add	sp, #8
     fec:	bd70      	pop	{r4, r5, r6, pc}
	if (error_code != STATUS_OK) {
		/* Baud rate calculation error, return status code */
		return STATUS_ERR_INVALID_ARG;
	}

	spi_module->BAUD.reg = (uint8_t)baud;
     fee:	466b      	mov	r3, sp
     ff0:	799b      	ldrb	r3, [r3, #6]
     ff2:	7323      	strb	r3, [r4, #12]
     ff4:	682b      	ldr	r3, [r5, #0]
     ff6:	69da      	ldr	r2, [r3, #28]

	while (spi_is_syncing(module)) {
     ff8:	2a00      	cmp	r2, #0
     ffa:	d1fc      	bne.n	ff6 <spi_set_baudrate+0x52>
     ffc:	69da      	ldr	r2, [r3, #28]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#  endif

	while (spi_is_syncing(module)) {
     ffe:	2a00      	cmp	r2, #0
    1000:	d1fc      	bne.n	ffc <spi_set_baudrate+0x58>
		/* Wait until the synchronization is complete */
	}

	/* Enable SPI */
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
    1002:	6819      	ldr	r1, [r3, #0]
    1004:	3202      	adds	r2, #2
    1006:	430a      	orrs	r2, r1
    1008:	601a      	str	r2, [r3, #0]
    100a:	682a      	ldr	r2, [r5, #0]

	SercomSpi *const spi_module = &(module->hw->SPI);

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
    100c:	69d3      	ldr	r3, [r2, #28]
	}

	/* Enable the module */
	spi_enable(module);

	while (spi_is_syncing(module)) {
    100e:	2b00      	cmp	r3, #0
    1010:	d1fc      	bne.n	100c <spi_set_baudrate+0x68>
    1012:	e7e9      	b.n	fe8 <spi_set_baudrate+0x44>
    1014:	000004d1 	.word	0x000004d1
    1018:	00001e2d 	.word	0x00001e2d
    101c:	00000115 	.word	0x00000115

00001020 <spi_init>:
 */
enum status_code spi_init(
		struct spi_module *const module,
		Sercom *const hw,
		const struct spi_config *const config)
{
    1020:	b5f0      	push	{r4, r5, r6, r7, lr}
    1022:	4656      	mov	r6, sl
    1024:	464d      	mov	r5, r9
    1026:	4644      	mov	r4, r8
    1028:	465f      	mov	r7, fp
    102a:	b4f0      	push	{r4, r5, r6, r7}
    102c:	1c05      	adds	r5, r0, #0
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize device instance */
	module->hw = hw;
    102e:	6029      	str	r1, [r5, #0]

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if module is enabled. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
    1030:	680b      	ldr	r3, [r1, #0]
 */
enum status_code spi_init(
		struct spi_module *const module,
		Sercom *const hw,
		const struct spi_config *const config)
{
    1032:	b087      	sub	sp, #28
    1034:	1c0e      	adds	r6, r1, #0
    1036:	1c14      	adds	r4, r2, #0
	module->hw = hw;

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if module is enabled. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
    1038:	079b      	lsls	r3, r3, #30
    103a:	d40c      	bmi.n	1056 <spi_init+0x36>
		return STATUS_ERR_DENIED;
#  endif
	}

	/* Check if reset is in progress. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
    103c:	2701      	movs	r7, #1
    103e:	680b      	ldr	r3, [r1, #0]
		return STATUS_BUSY;
    1040:	2005      	movs	r0, #5
		return STATUS_ERR_DENIED;
#  endif
	}

	/* Check if reset is in progress. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
    1042:	421f      	tst	r7, r3
    1044:	d100      	bne.n	1048 <spi_init+0x28>
    1046:	e0c6      	b.n	11d6 <spi_init+0x1b6>
	_sercom_instances[instance_index] = module;
#endif

	/* Write configuration to module and return status code */
	return _spi_set_config(module, config);
}
    1048:	b007      	add	sp, #28
    104a:	bc3c      	pop	{r2, r3, r4, r5}
    104c:	4690      	mov	r8, r2
    104e:	4699      	mov	r9, r3
    1050:	46a2      	mov	sl, r4
    1052:	46ab      	mov	fp, r5
    1054:	bdf0      	pop	{r4, r5, r6, r7, pc}
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
	Sercom *const hw = module->hw;

	uint32_t pad_pinmuxes[] = {
    1056:	6a93      	ldr	r3, [r2, #40]	; 0x28
    1058:	af02      	add	r7, sp, #8
    105a:	9302      	str	r3, [sp, #8]
    105c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
		config->pinmux_pad2, config->pinmux_pad3
	};

	/* Compare the current SERCOM pins against the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
    105e:	6a90      	ldr	r0, [r2, #40]	; 0x28
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
	Sercom *const hw = module->hw;

	uint32_t pad_pinmuxes[] = {
    1060:	607b      	str	r3, [r7, #4]
    1062:	6b13      	ldr	r3, [r2, #48]	; 0x30
    1064:	60bb      	str	r3, [r7, #8]
    1066:	6b53      	ldr	r3, [r2, #52]	; 0x34
    1068:	60fb      	str	r3, [r7, #12]

	/* Compare the current SERCOM pins against the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];

		if (current_pinmux == PINMUX_DEFAULT) {
    106a:	2800      	cmp	r0, #0
    106c:	d100      	bne.n	1070 <spi_init+0x50>
    106e:	e0a3      	b.n	11b8 <spi_init+0x198>
			current_pinmux = _sercom_get_default_pad(hw, pad);
		}

		if (current_pinmux == PINMUX_UNUSED) {
    1070:	1c43      	adds	r3, r0, #1
    1072:	d01c      	beq.n	10ae <spi_init+0x8e>
			continue;
		}

		if ((current_pinmux & 0xFFFF) !=
    1074:	0401      	lsls	r1, r0, #16
				system_pinmux_pin_get_mux_position(current_pinmux >> 16)) {
    1076:	0c00      	lsrs	r0, r0, #16

		if (current_pinmux == PINMUX_UNUSED) {
			continue;
		}

		if ((current_pinmux & 0xFFFF) !=
    1078:	0c09      	lsrs	r1, r1, #16
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    107a:	b2c3      	uxtb	r3, r0
    107c:	0602      	lsls	r2, r0, #24
    107e:	d500      	bpl.n	1082 <spi_init+0x62>
    1080:	e0a4      	b.n	11cc <spi_init+0x1ac>
 */
static inline uint8_t system_pinmux_pin_get_mux_position(
		const uint8_t gpio_pin)
{
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_index = (gpio_pin % 32);
    1082:	201f      	movs	r0, #31
    1084:	4018      	ands	r0, r3
    1086:	4684      	mov	ip, r0

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
    1088:	48d2      	ldr	r0, [pc, #840]	; (13d4 <spi_init+0x3b4>)

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
		return &(ports[port_index]->Group[group_index]);
    108a:	095a      	lsrs	r2, r3, #5
		const uint8_t gpio_pin)
{
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_index = (gpio_pin % 32);

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
    108c:	4680      	mov	r8, r0
    108e:	01d2      	lsls	r2, r2, #7
    1090:	4442      	add	r2, r8
    1092:	4692      	mov	sl, r2
    1094:	4660      	mov	r0, ip
    1096:	4450      	add	r0, sl
    1098:	3040      	adds	r0, #64	; 0x40
    109a:	7802      	ldrb	r2, [r0, #0]
    109c:	2001      	movs	r0, #1
    109e:	4680      	mov	r8, r0
    10a0:	4210      	tst	r0, r2
    10a2:	d000      	beq.n	10a6 <spi_init+0x86>
    10a4:	e185      	b.n	13b2 <spi_init+0x392>
    10a6:	2280      	movs	r2, #128	; 0x80
    10a8:	4291      	cmp	r1, r2
    10aa:	d000      	beq.n	10ae <spi_init+0x8e>
    10ac:	e15b      	b.n	1366 <spi_init+0x346>
		config->pinmux_pad2, config->pinmux_pad3
	};

	/* Compare the current SERCOM pins against the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
    10ae:	6878      	ldr	r0, [r7, #4]

		if (current_pinmux == PINMUX_DEFAULT) {
    10b0:	2800      	cmp	r0, #0
    10b2:	d100      	bne.n	10b6 <spi_init+0x96>
    10b4:	e085      	b.n	11c2 <spi_init+0x1a2>
			current_pinmux = _sercom_get_default_pad(hw, pad);
		}

		if (current_pinmux == PINMUX_UNUSED) {
    10b6:	1c43      	adds	r3, r0, #1
    10b8:	d01c      	beq.n	10f4 <spi_init+0xd4>
			continue;
		}

		if ((current_pinmux & 0xFFFF) !=
    10ba:	0401      	lsls	r1, r0, #16
				system_pinmux_pin_get_mux_position(current_pinmux >> 16)) {
    10bc:	0c00      	lsrs	r0, r0, #16

		if (current_pinmux == PINMUX_UNUSED) {
			continue;
		}

		if ((current_pinmux & 0xFFFF) !=
    10be:	0c09      	lsrs	r1, r1, #16
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    10c0:	b2c3      	uxtb	r3, r0
    10c2:	0602      	lsls	r2, r0, #24
    10c4:	d500      	bpl.n	10c8 <spi_init+0xa8>
    10c6:	e081      	b.n	11cc <spi_init+0x1ac>
 */
static inline uint8_t system_pinmux_pin_get_mux_position(
		const uint8_t gpio_pin)
{
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_index = (gpio_pin % 32);
    10c8:	201f      	movs	r0, #31
    10ca:	4018      	ands	r0, r3
    10cc:	4684      	mov	ip, r0

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
    10ce:	48c1      	ldr	r0, [pc, #772]	; (13d4 <spi_init+0x3b4>)

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
		return &(ports[port_index]->Group[group_index]);
    10d0:	095a      	lsrs	r2, r3, #5
		const uint8_t gpio_pin)
{
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_index = (gpio_pin % 32);

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
    10d2:	4680      	mov	r8, r0
    10d4:	01d2      	lsls	r2, r2, #7
    10d6:	4442      	add	r2, r8
    10d8:	4692      	mov	sl, r2
    10da:	4660      	mov	r0, ip
    10dc:	4450      	add	r0, sl
    10de:	3040      	adds	r0, #64	; 0x40
    10e0:	7802      	ldrb	r2, [r0, #0]
    10e2:	2001      	movs	r0, #1
    10e4:	4680      	mov	r8, r0
    10e6:	4210      	tst	r0, r2
    10e8:	d000      	beq.n	10ec <spi_init+0xcc>
    10ea:	e187      	b.n	13fc <spi_init+0x3dc>
    10ec:	2280      	movs	r2, #128	; 0x80
    10ee:	4291      	cmp	r1, r2
    10f0:	d000      	beq.n	10f4 <spi_init+0xd4>
    10f2:	e138      	b.n	1366 <spi_init+0x346>
		config->pinmux_pad2, config->pinmux_pad3
	};

	/* Compare the current SERCOM pins against the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
    10f4:	68b8      	ldr	r0, [r7, #8]

		if (current_pinmux == PINMUX_DEFAULT) {
    10f6:	2800      	cmp	r0, #0
    10f8:	d100      	bne.n	10fc <spi_init+0xdc>
    10fa:	e149      	b.n	1390 <spi_init+0x370>
			current_pinmux = _sercom_get_default_pad(hw, pad);
		}

		if (current_pinmux == PINMUX_UNUSED) {
    10fc:	1c43      	adds	r3, r0, #1
    10fe:	d01b      	beq.n	1138 <spi_init+0x118>
			continue;
		}

		if ((current_pinmux & 0xFFFF) !=
    1100:	0401      	lsls	r1, r0, #16
				system_pinmux_pin_get_mux_position(current_pinmux >> 16)) {
    1102:	0c00      	lsrs	r0, r0, #16

		if (current_pinmux == PINMUX_UNUSED) {
			continue;
		}

		if ((current_pinmux & 0xFFFF) !=
    1104:	0c09      	lsrs	r1, r1, #16
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    1106:	b2c3      	uxtb	r3, r0
    1108:	0602      	lsls	r2, r0, #24
    110a:	d45f      	bmi.n	11cc <spi_init+0x1ac>
 */
static inline uint8_t system_pinmux_pin_get_mux_position(
		const uint8_t gpio_pin)
{
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_index = (gpio_pin % 32);
    110c:	201f      	movs	r0, #31
    110e:	4018      	ands	r0, r3
    1110:	4684      	mov	ip, r0

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
    1112:	48b0      	ldr	r0, [pc, #704]	; (13d4 <spi_init+0x3b4>)

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
		return &(ports[port_index]->Group[group_index]);
    1114:	095a      	lsrs	r2, r3, #5
		const uint8_t gpio_pin)
{
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_index = (gpio_pin % 32);

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
    1116:	4680      	mov	r8, r0
    1118:	01d2      	lsls	r2, r2, #7
    111a:	4442      	add	r2, r8
    111c:	4692      	mov	sl, r2
    111e:	4660      	mov	r0, ip
    1120:	4450      	add	r0, sl
    1122:	3040      	adds	r0, #64	; 0x40
    1124:	7802      	ldrb	r2, [r0, #0]
    1126:	2001      	movs	r0, #1
    1128:	4680      	mov	r8, r0
    112a:	4210      	tst	r0, r2
    112c:	d000      	beq.n	1130 <spi_init+0x110>
    112e:	e176      	b.n	141e <spi_init+0x3fe>
    1130:	2280      	movs	r2, #128	; 0x80
    1132:	4291      	cmp	r1, r2
    1134:	d000      	beq.n	1138 <spi_init+0x118>
    1136:	e116      	b.n	1366 <spi_init+0x346>
		config->pinmux_pad2, config->pinmux_pad3
	};

	/* Compare the current SERCOM pins against the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
    1138:	68f8      	ldr	r0, [r7, #12]

		if (current_pinmux == PINMUX_DEFAULT) {
    113a:	2800      	cmp	r0, #0
    113c:	d100      	bne.n	1140 <spi_init+0x120>
    113e:	e12c      	b.n	139a <spi_init+0x37a>
			current_pinmux = _sercom_get_default_pad(hw, pad);
		}

		if (current_pinmux == PINMUX_UNUSED) {
    1140:	1c43      	adds	r3, r0, #1
    1142:	d01e      	beq.n	1182 <spi_init+0x162>
			continue;
		}

		if ((current_pinmux & 0xFFFF) !=
    1144:	0401      	lsls	r1, r0, #16
				system_pinmux_pin_get_mux_position(current_pinmux >> 16)) {
    1146:	0c00      	lsrs	r0, r0, #16

		if (current_pinmux == PINMUX_UNUSED) {
			continue;
		}

		if ((current_pinmux & 0xFFFF) !=
    1148:	0c09      	lsrs	r1, r1, #16
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    114a:	b2c3      	uxtb	r3, r0
    114c:	0602      	lsls	r2, r0, #24
    114e:	d43d      	bmi.n	11cc <spi_init+0x1ac>
		const uint8_t gpio_pin)
{
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_index = (gpio_pin % 32);

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
    1150:	4fa0      	ldr	r7, [pc, #640]	; (13d4 <spi_init+0x3b4>)
 */
static inline uint8_t system_pinmux_pin_get_mux_position(
		const uint8_t gpio_pin)
{
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_index = (gpio_pin % 32);
    1152:	201f      	movs	r0, #31

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
    1154:	46bc      	mov	ip, r7

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
		return &(ports[port_index]->Group[group_index]);
    1156:	095a      	lsrs	r2, r3, #5
		const uint8_t gpio_pin)
{
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_index = (gpio_pin % 32);

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
    1158:	01d2      	lsls	r2, r2, #7
    115a:	4462      	add	r2, ip
 */
static inline uint8_t system_pinmux_pin_get_mux_position(
		const uint8_t gpio_pin)
{
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_index = (gpio_pin % 32);
    115c:	4018      	ands	r0, r3
    115e:	4681      	mov	r9, r0

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
    1160:	1c17      	adds	r7, r2, #0
    1162:	444f      	add	r7, r9
    1164:	3740      	adds	r7, #64	; 0x40
    1166:	783f      	ldrb	r7, [r7, #0]
    1168:	4692      	mov	sl, r2
    116a:	46b8      	mov	r8, r7
    116c:	2701      	movs	r7, #1
    116e:	46bc      	mov	ip, r7
    1170:	4640      	mov	r0, r8
    1172:	4662      	mov	r2, ip
    1174:	377f      	adds	r7, #127	; 0x7f
    1176:	4202      	tst	r2, r0
    1178:	d000      	beq.n	117c <spi_init+0x15c>
    117a:	e175      	b.n	1468 <spi_init+0x448>
    117c:	42b9      	cmp	r1, r7
    117e:	d000      	beq.n	1182 <spi_init+0x162>
    1180:	e0f1      	b.n	1366 <spi_init+0x346>
	}

#  if CONF_SPI_MASTER_ENABLE == true
	/* Value to read BAUD register */
	uint16_t baud;
	uint32_t external_clock = system_gclk_chan_get_hz(SERCOM_GCLK_ID);
    1182:	4b95      	ldr	r3, [pc, #596]	; (13d8 <spi_init+0x3b8>)
    1184:	2013      	movs	r0, #19
    1186:	4798      	blx	r3
	uint32_t addr = 0;
#  endif

#  if CONF_SPI_MASTER_ENABLE == true
	/* Find baud value and compare it */
	if (config->mode == SPI_MODE_MASTER) {
    1188:	7823      	ldrb	r3, [r4, #0]
	}

#  if CONF_SPI_MASTER_ENABLE == true
	/* Value to read BAUD register */
	uint16_t baud;
	uint32_t external_clock = system_gclk_chan_get_hz(SERCOM_GCLK_ID);
    118a:	1c01      	adds	r1, r0, #0
	uint32_t addr = 0;
#  endif

#  if CONF_SPI_MASTER_ENABLE == true
	/* Find baud value and compare it */
	if (config->mode == SPI_MODE_MASTER) {
    118c:	2b01      	cmp	r3, #1
    118e:	d100      	bne.n	1192 <spi_init+0x172>
    1190:	e177      	b.n	1482 <spi_init+0x462>
    1192:	1c1a      	adds	r2, r3, #0
	/* Value to read BAUD register */
	uint16_t baud;
	uint32_t external_clock = system_gclk_chan_get_hz(SERCOM_GCLK_ID);
#  endif
	/* Value to read CTRLA, CTRLB and ADDR register */
	uint32_t ctrla = 0;
    1194:	2300      	movs	r3, #0
    1196:	469c      	mov	ip, r3
		ctrla |= SERCOM_SPI_CTRLA_MODE(0x3);
	}
#  endif

#  if CONF_SPI_SLAVE_ENABLE == true
	if (config->mode == SPI_MODE_SLAVE) {
    1198:	2a00      	cmp	r2, #0
    119a:	d000      	beq.n	119e <spi_init+0x17e>
    119c:	e0bf      	b.n	131e <spi_init+0x2fe>
		/* Set address mode */
		ctrlb |= config->mode_specific.slave.address_mode;

		/* Set address and address mask*/
		addr |= (config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);
    119e:	7fe0      	ldrb	r0, [r4, #31]

#  if CONF_SPI_SLAVE_ENABLE == true
	if (config->mode == SPI_MODE_SLAVE) {

		/* Set frame format */
		ctrla |= config->mode_specific.slave.frame_format;
    11a0:	69a3      	ldr	r3, [r4, #24]

		/* Set address mode */
		ctrlb |= config->mode_specific.slave.address_mode;

		/* Set address and address mask*/
		addr |= (config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
    11a2:	7fa7      	ldrb	r7, [r4, #30]
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);
		if (spi_module->CTRLA.reg != addr) {
    11a4:	6831      	ldr	r1, [r6, #0]
		/* Set address mode */
		ctrlb |= config->mode_specific.slave.address_mode;

		/* Set address and address mask*/
		addr |= (config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);
    11a6:	0400      	lsls	r0, r0, #16

#  if CONF_SPI_SLAVE_ENABLE == true
	if (config->mode == SPI_MODE_SLAVE) {

		/* Set frame format */
		ctrla |= config->mode_specific.slave.frame_format;
    11a8:	4698      	mov	r8, r3

		/* Set address mode */
		ctrlb |= config->mode_specific.slave.address_mode;

		/* Set address and address mask*/
		addr |= (config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
    11aa:	4338      	orrs	r0, r7

		/* Set frame format */
		ctrla |= config->mode_specific.slave.frame_format;

		/* Set address mode */
		ctrlb |= config->mode_specific.slave.address_mode;
    11ac:	8ba3      	ldrh	r3, [r4, #28]

		/* Set address and address mask*/
		addr |= (config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);
		if (spi_module->CTRLA.reg != addr) {
    11ae:	4288      	cmp	r0, r1
    11b0:	d100      	bne.n	11b4 <spi_init+0x194>
    11b2:	e145      	b.n	1440 <spi_init+0x420>
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
		}

		if (spi_module->BAUD.reg !=  (uint8_t)baud) {
			return STATUS_ERR_DENIED;
    11b4:	201c      	movs	r0, #28
    11b6:	e747      	b.n	1048 <spi_init+0x28>
	/* Compare the current SERCOM pins against the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];

		if (current_pinmux == PINMUX_DEFAULT) {
			current_pinmux = _sercom_get_default_pad(hw, pad);
    11b8:	1c08      	adds	r0, r1, #0
    11ba:	4b88      	ldr	r3, [pc, #544]	; (13dc <spi_init+0x3bc>)
    11bc:	2100      	movs	r1, #0
    11be:	4798      	blx	r3
    11c0:	e756      	b.n	1070 <spi_init+0x50>
    11c2:	1c30      	adds	r0, r6, #0
    11c4:	2101      	movs	r1, #1
    11c6:	4b85      	ldr	r3, [pc, #532]	; (13dc <spi_init+0x3bc>)
    11c8:	4798      	blx	r3
    11ca:	e774      	b.n	10b6 <spi_init+0x96>
 */
static inline uint8_t system_pinmux_pin_get_mux_position(
		const uint8_t gpio_pin)
{
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_index = (gpio_pin % 32);
    11cc:	221f      	movs	r2, #31
    11ce:	4013      	ands	r3, r2

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
    11d0:	3340      	adds	r3, #64	; 0x40
    11d2:	781b      	ldrb	r3, [r3, #0]
    11d4:	deff      	udf	#255	; 0xff
	/* Check if reset is in progress. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
		return STATUS_BUSY;
	}

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    11d6:	1c08      	adds	r0, r1, #0
    11d8:	4b81      	ldr	r3, [pc, #516]	; (13e0 <spi_init+0x3c0>)
    11da:	4798      	blx	r3
	}
#elif (SAMC20)
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
    11dc:	1c81      	adds	r1, r0, #2
#  endif
	} else {
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
	}
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
    11de:	408f      	lsls	r7, r1
    11e0:	4a80      	ldr	r2, [pc, #512]	; (13e4 <spi_init+0x3c4>)
#elif (SAMC20)
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    11e2:	3014      	adds	r0, #20
    11e4:	6a13      	ldr	r3, [r2, #32]

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    11e6:	4669      	mov	r1, sp
    11e8:	431f      	orrs	r7, r3
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
    11ea:	2324      	movs	r3, #36	; 0x24
    11ec:	6217      	str	r7, [r2, #32]
    11ee:	466a      	mov	r2, sp
    11f0:	4698      	mov	r8, r3
    11f2:	5ce3      	ldrb	r3, [r4, r3]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    11f4:	b2c7      	uxtb	r7, r0
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
    11f6:	7013      	strb	r3, [r2, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    11f8:	1c38      	adds	r0, r7, #0
    11fa:	4b7b      	ldr	r3, [pc, #492]	; (13e8 <spi_init+0x3c8>)
    11fc:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    11fe:	1c38      	adds	r0, r7, #0
    1200:	4b7a      	ldr	r3, [pc, #488]	; (13ec <spi_init+0x3cc>)
    1202:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    1204:	4643      	mov	r3, r8
    1206:	2100      	movs	r1, #0
    1208:	5ce0      	ldrb	r0, [r4, r3]
    120a:	4b79      	ldr	r3, [pc, #484]	; (13f0 <spi_init+0x3d0>)
    120c:	4798      	blx	r3

#  if CONF_SPI_MASTER_ENABLE == true
	if (config->mode == SPI_MODE_MASTER) {
    120e:	7823      	ldrb	r3, [r4, #0]
    1210:	2b01      	cmp	r3, #1
    1212:	d100      	bne.n	1216 <spi_init+0x1f6>
    1214:	e122      	b.n	145c <spi_init+0x43c>
		spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_MODE(0x3);
	}
#  endif

#  if CONF_SPI_SLAVE_ENABLE == true
	if (config->mode == SPI_MODE_SLAVE) {
    1216:	2b00      	cmp	r3, #0
    1218:	d000      	beq.n	121c <spi_init+0x1fc>
    121a:	e0a8      	b.n	136e <spi_init+0x34e>
		/* Set the SERCOM in SPI slave mode */
		spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_MODE(0x2);
    121c:	2208      	movs	r2, #8
    121e:	6831      	ldr	r1, [r6, #0]
    1220:	430a      	orrs	r2, r1
    1222:	6032      	str	r2, [r6, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(config);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1224:	6829      	ldr	r1, [r5, #0]
    1226:	7822      	ldrb	r2, [r4, #0]
    1228:	4689      	mov	r9, r1
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    122a:	a901      	add	r1, sp, #4
    122c:	4688      	mov	r8, r1
    122e:	2180      	movs	r1, #128	; 0x80
    1230:	4640      	mov	r0, r8
    1232:	7001      	strb	r1, [r0, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    1234:	2101      	movs	r1, #1
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    1236:	7043      	strb	r3, [r0, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    1238:	7081      	strb	r1, [r0, #2]
	config->powersave    = false;
    123a:	70c3      	strb	r3, [r0, #3]
	Sercom *const hw = module->hw;

	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	if(config->mode == SPI_MODE_SLAVE) {
    123c:	2a00      	cmp	r2, #0
    123e:	d100      	bne.n	1242 <spi_init+0x222>
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    1240:	7083      	strb	r3, [r0, #2]
	}

	uint32_t pad_pinmuxes[] = {
    1242:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    1244:	af02      	add	r7, sp, #8
    1246:	9302      	str	r3, [sp, #8]
    1248:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    124a:	2600      	movs	r6, #0
    124c:	607b      	str	r3, [r7, #4]
    124e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1250:	60bb      	str	r3, [r7, #8]
    1252:	6b63      	ldr	r3, [r4, #52]	; 0x34
    1254:	60fb      	str	r3, [r7, #12]
	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];

		if (current_pinmux == PINMUX_DEFAULT) {
			current_pinmux = _sercom_get_default_pad(hw, pad);
    1256:	4b61      	ldr	r3, [pc, #388]	; (13dc <spi_init+0x3bc>)
    1258:	469b      	mov	fp, r3
		}

		if (current_pinmux != PINMUX_UNUSED) {
			pin_conf.mux_position = current_pinmux & 0xFFFF;
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
    125a:	4b66      	ldr	r3, [pc, #408]	; (13f4 <spi_init+0x3d4>)
    125c:	469a      	mov	sl, r3
    125e:	00b3      	lsls	r3, r6, #2
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
    1260:	58f8      	ldr	r0, [r7, r3]
    1262:	b2f1      	uxtb	r1, r6

		if (current_pinmux == PINMUX_DEFAULT) {
    1264:	2800      	cmp	r0, #0
    1266:	d057      	beq.n	1318 <spi_init+0x2f8>
			current_pinmux = _sercom_get_default_pad(hw, pad);
		}

		if (current_pinmux != PINMUX_UNUSED) {
    1268:	1c43      	adds	r3, r0, #1
    126a:	d005      	beq.n	1278 <spi_init+0x258>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    126c:	4643      	mov	r3, r8
    126e:	7018      	strb	r0, [r3, #0]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
    1270:	0c00      	lsrs	r0, r0, #16
    1272:	b2c0      	uxtb	r0, r0
    1274:	4641      	mov	r1, r8
    1276:	47d0      	blx	sl
    1278:	3601      	adds	r6, #1
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
    127a:	2e04      	cmp	r6, #4
    127c:	d1ef      	bne.n	125e <spi_init+0x23e>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
		}
	}

	module->mode             = config->mode;
    127e:	7823      	ldrb	r3, [r4, #0]
	module->master_slave_select_enable = config->master_slave_select_enable;
#  endif

#  if CONF_SPI_MASTER_ENABLE == true
	/* Value to write to BAUD register */
	uint16_t baud = 0;
    1280:	466a      	mov	r2, sp
			pin_conf.mux_position = current_pinmux & 0xFFFF;
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
		}
	}

	module->mode             = config->mode;
    1282:	716b      	strb	r3, [r5, #5]
	module->character_size   = config->character_size;
    1284:	7c23      	ldrb	r3, [r4, #16]
    1286:	71ab      	strb	r3, [r5, #6]
	module->receiver_enabled = config->receiver_enable;
    1288:	7ca3      	ldrb	r3, [r4, #18]
    128a:	71eb      	strb	r3, [r5, #7]
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	module->master_slave_select_enable = config->master_slave_select_enable;
    128c:	7d23      	ldrb	r3, [r4, #20]
    128e:	722b      	strb	r3, [r5, #8]
#  endif

#  if CONF_SPI_MASTER_ENABLE == true
	/* Value to write to BAUD register */
	uint16_t baud = 0;
    1290:	2300      	movs	r3, #0
    1292:	8053      	strh	r3, [r2, #2]
	/* Value to write to CTRLB register */
	uint32_t ctrlb = 0;

# if CONF_SPI_MASTER_ENABLE == true
	/* Find baud value and write it */
	if (config->mode == SPI_MODE_MASTER) {
    1294:	7823      	ldrb	r3, [r4, #0]
    1296:	2b01      	cmp	r3, #1
    1298:	d100      	bne.n	129c <spi_init+0x27c>
    129a:	e105      	b.n	14a8 <spi_init+0x488>

		spi_module->BAUD.reg = (uint8_t)baud;
	}
# endif
# if CONF_SPI_SLAVE_ENABLE == true
	if (config->mode == SPI_MODE_SLAVE) {
    129c:	2b00      	cmp	r3, #0
    129e:	d174      	bne.n	138a <spi_init+0x36a>

		/* Set address mode */
		ctrlb = config->mode_specific.slave.address_mode;

		/* Set address and address mask*/
		spi_module->ADDR.reg |=
    12a0:	464a      	mov	r2, r9
				(config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);
    12a2:	7fe1      	ldrb	r1, [r4, #31]
		/* Set address mode */
		ctrlb = config->mode_specific.slave.address_mode;

		/* Set address and address mask*/
		spi_module->ADDR.reg |=
				(config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
    12a4:	7fa5      	ldrb	r5, [r4, #30]

		/* Set address mode */
		ctrlb = config->mode_specific.slave.address_mode;

		/* Set address and address mask*/
		spi_module->ADDR.reg |=
    12a6:	6a50      	ldr	r0, [r2, #36]	; 0x24
				(config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);
    12a8:	0409      	lsls	r1, r1, #16
		/* Set address mode */
		ctrlb = config->mode_specific.slave.address_mode;

		/* Set address and address mask*/
		spi_module->ADDR.reg |=
				(config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
    12aa:	4329      	orrs	r1, r5

		/* Set address mode */
		ctrlb = config->mode_specific.slave.address_mode;

		/* Set address and address mask*/
		spi_module->ADDR.reg |=
    12ac:	4301      	orrs	r1, r0
	}
# endif
# if CONF_SPI_SLAVE_ENABLE == true
	if (config->mode == SPI_MODE_SLAVE) {
		/* Set frame format */
		ctrla = config->mode_specific.slave.frame_format;
    12ae:	69a6      	ldr	r6, [r4, #24]

		/* Set address mode */
		ctrlb = config->mode_specific.slave.address_mode;
    12b0:	8ba3      	ldrh	r3, [r4, #28]

		/* Set address and address mask*/
		spi_module->ADDR.reg |=
    12b2:	6251      	str	r1, [r2, #36]	; 0x24
				(config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);

		if (config->mode_specific.slave.preload_enable) {
    12b4:	2220      	movs	r2, #32
    12b6:	5ca2      	ldrb	r2, [r4, r2]
    12b8:	2a00      	cmp	r2, #0
    12ba:	d177      	bne.n	13ac <spi_init+0x38c>
    12bc:	6861      	ldr	r1, [r4, #4]
    12be:	68a2      	ldr	r2, [r4, #8]
    12c0:	430a      	orrs	r2, r1
    12c2:	68e1      	ldr	r1, [r4, #12]
    12c4:	430a      	orrs	r2, r1

	/* Set MUX setting */
	ctrla |= config->mux_setting;

	/* Set SPI character size */
	ctrlb |= config->character_size;
    12c6:	7c21      	ldrb	r1, [r4, #16]

	/* Set clock polarity and clock phase */
	ctrla |= config->transfer_mode;

	/* Set MUX setting */
	ctrla |= config->mux_setting;
    12c8:	4332      	orrs	r2, r6

	/* Set SPI character size */
	ctrlb |= config->character_size;
    12ca:	430b      	orrs	r3, r1

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
    12cc:	7c61      	ldrb	r1, [r4, #17]
    12ce:	2900      	cmp	r1, #0
    12d0:	d11f      	bne.n	1312 <spi_init+0x2f2>
    12d2:	4949      	ldr	r1, [pc, #292]	; (13f8 <spi_init+0x3d8>)
    12d4:	7889      	ldrb	r1, [r1, #2]
    12d6:	0789      	lsls	r1, r1, #30
    12d8:	d41b      	bmi.n	1312 <spi_init+0x2f2>
		ctrla |= SERCOM_SPI_CTRLA_RUNSTDBY;
	}

	if (config->receiver_enable) {
    12da:	7ca1      	ldrb	r1, [r4, #18]
    12dc:	2900      	cmp	r1, #0
    12de:	d002      	beq.n	12e6 <spi_init+0x2c6>
		/* Enable receiver */
		ctrlb |= SERCOM_SPI_CTRLB_RXEN;
    12e0:	2180      	movs	r1, #128	; 0x80
    12e2:	0289      	lsls	r1, r1, #10
    12e4:	430b      	orrs	r3, r1
	}
#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	if (config->select_slave_low_detect_enable) {
    12e6:	7ce1      	ldrb	r1, [r4, #19]
    12e8:	2900      	cmp	r1, #0
    12ea:	d002      	beq.n	12f2 <spi_init+0x2d2>
		/* Enable Slave Select Low Detect */
		ctrlb |= SERCOM_SPI_CTRLB_SSDE;
    12ec:	2180      	movs	r1, #128	; 0x80
    12ee:	0089      	lsls	r1, r1, #2
    12f0:	430b      	orrs	r3, r1
	}
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if (config->master_slave_select_enable) {
    12f2:	7d21      	ldrb	r1, [r4, #20]
    12f4:	2900      	cmp	r1, #0
    12f6:	d002      	beq.n	12fe <spi_init+0x2de>
		/* Enable Master Slave Select */
		ctrlb |= SERCOM_SPI_CTRLB_MSSEN;
    12f8:	2180      	movs	r1, #128	; 0x80
    12fa:	0189      	lsls	r1, r1, #6
    12fc:	430b      	orrs	r3, r1
	}
#  endif
	/* Write CTRLA register */
	spi_module->CTRLA.reg |= ctrla;
    12fe:	4649      	mov	r1, r9
    1300:	6809      	ldr	r1, [r1, #0]

	/* Write CTRLB register */
	spi_module->CTRLB.reg |= ctrlb;

	return STATUS_OK;
    1302:	2000      	movs	r0, #0
		/* Enable Master Slave Select */
		ctrlb |= SERCOM_SPI_CTRLB_MSSEN;
	}
#  endif
	/* Write CTRLA register */
	spi_module->CTRLA.reg |= ctrla;
    1304:	430a      	orrs	r2, r1
    1306:	4649      	mov	r1, r9
    1308:	600a      	str	r2, [r1, #0]

	/* Write CTRLB register */
	spi_module->CTRLB.reg |= ctrlb;
    130a:	684a      	ldr	r2, [r1, #4]
    130c:	4313      	orrs	r3, r2
    130e:	604b      	str	r3, [r1, #4]
    1310:	e69a      	b.n	1048 <spi_init+0x28>
	/* Set SPI character size */
	ctrlb |= config->character_size;

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
		ctrla |= SERCOM_SPI_CTRLA_RUNSTDBY;
    1312:	2180      	movs	r1, #128	; 0x80
    1314:	430a      	orrs	r2, r1
    1316:	e7e0      	b.n	12da <spi_init+0x2ba>
	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];

		if (current_pinmux == PINMUX_DEFAULT) {
			current_pinmux = _sercom_get_default_pad(hw, pad);
    1318:	4648      	mov	r0, r9
    131a:	47d8      	blx	fp
    131c:	e7a4      	b.n	1268 <spi_init+0x248>
	uint16_t baud;
	uint32_t external_clock = system_gclk_chan_get_hz(SERCOM_GCLK_ID);
#  endif
	/* Value to read CTRLA, CTRLB and ADDR register */
	uint32_t ctrla = 0;
	uint32_t ctrlb = 0;
    131e:	2300      	movs	r3, #0
    1320:	6860      	ldr	r0, [r4, #4]
    1322:	68a1      	ldr	r1, [r4, #8]
    1324:	4301      	orrs	r1, r0
    1326:	68e0      	ldr	r0, [r4, #12]
    1328:	4301      	orrs	r1, r0

	/* Set clock polarity and clock phase */
	ctrla |= config->transfer_mode;

	/* Set MUX setting */
	ctrla |= config->mux_setting;
    132a:	4660      	mov	r0, ip
    132c:	4301      	orrs	r1, r0

	/* Set SPI character size */
	ctrlb |= config->character_size;
    132e:	7c20      	ldrb	r0, [r4, #16]
    1330:	4303      	orrs	r3, r0

	if (config->run_in_standby) {
    1332:	7c60      	ldrb	r0, [r4, #17]
    1334:	2800      	cmp	r0, #0
    1336:	d001      	beq.n	133c <spi_init+0x31c>
		/* Enable in sleep mode */
		ctrla |= SERCOM_SPI_CTRLA_RUNSTDBY;
    1338:	2080      	movs	r0, #128	; 0x80
    133a:	4301      	orrs	r1, r0
	}

	if (config->receiver_enable) {
    133c:	7ca0      	ldrb	r0, [r4, #18]
    133e:	2800      	cmp	r0, #0
    1340:	d002      	beq.n	1348 <spi_init+0x328>
		/* Enable receiver */
		ctrlb |= SERCOM_SPI_CTRLB_RXEN;
    1342:	2080      	movs	r0, #128	; 0x80
    1344:	0280      	lsls	r0, r0, #10
    1346:	4303      	orrs	r3, r0
	}

#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	if (config->select_slave_low_detect_enable) {
    1348:	7ce0      	ldrb	r0, [r4, #19]
    134a:	2800      	cmp	r0, #0
    134c:	d002      	beq.n	1354 <spi_init+0x334>
		/* Enable Slave Select Low Detect */
		ctrlb |= SERCOM_SPI_CTRLB_SSDE;
    134e:	2080      	movs	r0, #128	; 0x80
    1350:	0080      	lsls	r0, r0, #2
    1352:	4303      	orrs	r3, r0
	}
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if (config->master_slave_select_enable) {
    1354:	7d20      	ldrb	r0, [r4, #20]
    1356:	2800      	cmp	r0, #0
    1358:	d124      	bne.n	13a4 <spi_init+0x384>
		/* Enable Master Slave Select */
		ctrlb |= SERCOM_SPI_CTRLB_MSSEN;
	}
#  endif

	ctrla |= SERCOM_SPI_CTRLA_ENABLE;
    135a:	2002      	movs	r0, #2

	/* Check that same config is set */
	if (spi_module->CTRLA.reg == ctrla &&
    135c:	6837      	ldr	r7, [r6, #0]
		/* Enable Master Slave Select */
		ctrlb |= SERCOM_SPI_CTRLB_MSSEN;
	}
#  endif

	ctrla |= SERCOM_SPI_CTRLA_ENABLE;
    135e:	4301      	orrs	r1, r0

	/* Check that same config is set */
	if (spi_module->CTRLA.reg == ctrla &&
    1360:	42b9      	cmp	r1, r7
    1362:	d100      	bne.n	1366 <spi_init+0x346>
    1364:	e0b8      	b.n	14d8 <spi_init+0x4b8>
			continue;
		}

		if ((current_pinmux & 0xFFFF) !=
				system_pinmux_pin_get_mux_position(current_pinmux >> 16)) {
			module->hw = NULL;
    1366:	2300      	movs	r3, #0
			return STATUS_ERR_DENIED;
    1368:	201c      	movs	r0, #28
			continue;
		}

		if ((current_pinmux & 0xFFFF) !=
				system_pinmux_pin_get_mux_position(current_pinmux >> 16)) {
			module->hw = NULL;
    136a:	602b      	str	r3, [r5, #0]
    136c:	e66c      	b.n	1048 <spi_init+0x28>
	/* Sanity check arguments */
	Assert(module);
	Assert(config);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    136e:	682b      	ldr	r3, [r5, #0]
    1370:	4699      	mov	r9, r3
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    1372:	ab01      	add	r3, sp, #4
    1374:	4698      	mov	r8, r3
    1376:	2380      	movs	r3, #128	; 0x80
    1378:	4642      	mov	r2, r8
    137a:	7013      	strb	r3, [r2, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    137c:	2300      	movs	r3, #0
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    137e:	4641      	mov	r1, r8
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    1380:	7053      	strb	r3, [r2, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    1382:	2201      	movs	r2, #1
	config->powersave    = false;
    1384:	70cb      	strb	r3, [r1, #3]
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    1386:	708a      	strb	r2, [r1, #2]
    1388:	e75b      	b.n	1242 <spi_init+0x222>
	uint16_t baud = 0;
#  endif
	/* Value to write to CTRLA register */
	uint32_t ctrla = 0;
	/* Value to write to CTRLB register */
	uint32_t ctrlb = 0;
    138a:	2300      	movs	r3, #0
#  if CONF_SPI_MASTER_ENABLE == true
	/* Value to write to BAUD register */
	uint16_t baud = 0;
#  endif
	/* Value to write to CTRLA register */
	uint32_t ctrla = 0;
    138c:	2600      	movs	r6, #0
    138e:	e795      	b.n	12bc <spi_init+0x29c>
	/* Compare the current SERCOM pins against the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];

		if (current_pinmux == PINMUX_DEFAULT) {
			current_pinmux = _sercom_get_default_pad(hw, pad);
    1390:	1c30      	adds	r0, r6, #0
    1392:	2102      	movs	r1, #2
    1394:	4b11      	ldr	r3, [pc, #68]	; (13dc <spi_init+0x3bc>)
    1396:	4798      	blx	r3
    1398:	e6b0      	b.n	10fc <spi_init+0xdc>
    139a:	1c30      	adds	r0, r6, #0
    139c:	2103      	movs	r1, #3
    139e:	4b0f      	ldr	r3, [pc, #60]	; (13dc <spi_init+0x3bc>)
    13a0:	4798      	blx	r3
    13a2:	e6cd      	b.n	1140 <spi_init+0x120>
	}
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if (config->master_slave_select_enable) {
		/* Enable Master Slave Select */
		ctrlb |= SERCOM_SPI_CTRLB_MSSEN;
    13a4:	2080      	movs	r0, #128	; 0x80
    13a6:	0180      	lsls	r0, r0, #6
    13a8:	4303      	orrs	r3, r0
    13aa:	e7d6      	b.n	135a <spi_init+0x33a>
				(config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);

		if (config->mode_specific.slave.preload_enable) {
			/* Enable pre-loading of shift register */
			ctrlb |= SERCOM_SPI_CTRLB_PLOADEN;
    13ac:	2140      	movs	r1, #64	; 0x40
    13ae:	430b      	orrs	r3, r1
    13b0:	e784      	b.n	12bc <spi_init+0x29c>

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
		return SYSTEM_PINMUX_GPIO;
	}

	uint32_t pmux_reg = port->PMUX[pin_index / 2].reg;
    13b2:	4660      	mov	r0, ip
    13b4:	0840      	lsrs	r0, r0, #1
    13b6:	1c02      	adds	r2, r0, #0
    13b8:	4452      	add	r2, sl
    13ba:	3230      	adds	r2, #48	; 0x30
    13bc:	7810      	ldrb	r0, [r2, #0]
    13be:	b2c2      	uxtb	r2, r0

	if (pin_index & 1) {
    13c0:	4640      	mov	r0, r8

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
		return SYSTEM_PINMUX_GPIO;
	}

	uint32_t pmux_reg = port->PMUX[pin_index / 2].reg;
    13c2:	4694      	mov	ip, r2

	if (pin_index & 1) {
		return (pmux_reg & PORT_PMUX_PMUXO_Msk) >> PORT_PMUX_PMUXO_Pos;
    13c4:	0912      	lsrs	r2, r2, #4
		return SYSTEM_PINMUX_GPIO;
	}

	uint32_t pmux_reg = port->PMUX[pin_index / 2].reg;

	if (pin_index & 1) {
    13c6:	4218      	tst	r0, r3
    13c8:	d000      	beq.n	13cc <spi_init+0x3ac>
    13ca:	e66d      	b.n	10a8 <spi_init+0x88>
    13cc:	220f      	movs	r2, #15
    13ce:	4663      	mov	r3, ip
    13d0:	401a      	ands	r2, r3
    13d2:	e669      	b.n	10a8 <spi_init+0x88>
    13d4:	41004400 	.word	0x41004400
    13d8:	00001e2d 	.word	0x00001e2d
    13dc:	00000371 	.word	0x00000371
    13e0:	000004d1 	.word	0x000004d1
    13e4:	40000400 	.word	0x40000400
    13e8:	00001d99 	.word	0x00001d99
    13ec:	00001dfd 	.word	0x00001dfd
    13f0:	00000329 	.word	0x00000329
    13f4:	00001ed1 	.word	0x00001ed1
    13f8:	41002000 	.word	0x41002000

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
		return SYSTEM_PINMUX_GPIO;
	}

	uint32_t pmux_reg = port->PMUX[pin_index / 2].reg;
    13fc:	4660      	mov	r0, ip
    13fe:	0840      	lsrs	r0, r0, #1
    1400:	1c02      	adds	r2, r0, #0
    1402:	4452      	add	r2, sl
    1404:	3230      	adds	r2, #48	; 0x30
    1406:	7810      	ldrb	r0, [r2, #0]
    1408:	b2c2      	uxtb	r2, r0

	if (pin_index & 1) {
    140a:	4640      	mov	r0, r8

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
		return SYSTEM_PINMUX_GPIO;
	}

	uint32_t pmux_reg = port->PMUX[pin_index / 2].reg;
    140c:	4694      	mov	ip, r2

	if (pin_index & 1) {
		return (pmux_reg & PORT_PMUX_PMUXO_Msk) >> PORT_PMUX_PMUXO_Pos;
    140e:	0912      	lsrs	r2, r2, #4
		return SYSTEM_PINMUX_GPIO;
	}

	uint32_t pmux_reg = port->PMUX[pin_index / 2].reg;

	if (pin_index & 1) {
    1410:	4218      	tst	r0, r3
    1412:	d000      	beq.n	1416 <spi_init+0x3f6>
    1414:	e66b      	b.n	10ee <spi_init+0xce>
    1416:	220f      	movs	r2, #15
    1418:	4663      	mov	r3, ip
    141a:	401a      	ands	r2, r3
    141c:	e667      	b.n	10ee <spi_init+0xce>

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
		return SYSTEM_PINMUX_GPIO;
	}

	uint32_t pmux_reg = port->PMUX[pin_index / 2].reg;
    141e:	4660      	mov	r0, ip
    1420:	0840      	lsrs	r0, r0, #1
    1422:	1c02      	adds	r2, r0, #0
    1424:	4452      	add	r2, sl
    1426:	3230      	adds	r2, #48	; 0x30
    1428:	7810      	ldrb	r0, [r2, #0]
    142a:	b2c2      	uxtb	r2, r0

	if (pin_index & 1) {
    142c:	4640      	mov	r0, r8

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
		return SYSTEM_PINMUX_GPIO;
	}

	uint32_t pmux_reg = port->PMUX[pin_index / 2].reg;
    142e:	4694      	mov	ip, r2

	if (pin_index & 1) {
		return (pmux_reg & PORT_PMUX_PMUXO_Msk) >> PORT_PMUX_PMUXO_Pos;
    1430:	0912      	lsrs	r2, r2, #4
		return SYSTEM_PINMUX_GPIO;
	}

	uint32_t pmux_reg = port->PMUX[pin_index / 2].reg;

	if (pin_index & 1) {
    1432:	4218      	tst	r0, r3
    1434:	d000      	beq.n	1438 <spi_init+0x418>
    1436:	e67c      	b.n	1132 <spi_init+0x112>
    1438:	220f      	movs	r2, #15
    143a:	4663      	mov	r3, ip
    143c:	401a      	ands	r2, r3
    143e:	e678      	b.n	1132 <spi_init+0x112>
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);
		if (spi_module->CTRLA.reg != addr) {
			return STATUS_ERR_DENIED;
		}

		if (config->mode_specific.slave.preload_enable) {
    1440:	2120      	movs	r1, #32
    1442:	5c61      	ldrb	r1, [r4, r1]
    1444:	2900      	cmp	r1, #0
    1446:	d001      	beq.n	144c <spi_init+0x42c>
			/* Enable pre-loading of shift register */
			ctrlb |= SERCOM_SPI_CTRLB_PLOADEN;
    1448:	2040      	movs	r0, #64	; 0x40
    144a:	4303      	orrs	r3, r0
    144c:	2108      	movs	r1, #8
    144e:	4640      	mov	r0, r8
    1450:	4308      	orrs	r0, r1
    1452:	1c01      	adds	r1, r0, #0
		}
		ctrla |= SERCOM_SPI_CTRLA_MODE(0x2);
    1454:	4660      	mov	r0, ip
    1456:	4308      	orrs	r0, r1
    1458:	4684      	mov	ip, r0
    145a:	e761      	b.n	1320 <spi_init+0x300>
	sercom_set_gclk_generator(config->generator_source, false);

#  if CONF_SPI_MASTER_ENABLE == true
	if (config->mode == SPI_MODE_MASTER) {
		/* Set the SERCOM in SPI master mode */
		spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_MODE(0x3);
    145c:	6832      	ldr	r2, [r6, #0]
    145e:	330b      	adds	r3, #11
    1460:	4313      	orrs	r3, r2
    1462:	6033      	str	r3, [r6, #0]
    1464:	7823      	ldrb	r3, [r4, #0]
    1466:	e6d6      	b.n	1216 <spi_init+0x1f6>

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
		return SYSTEM_PINMUX_GPIO;
	}

	uint32_t pmux_reg = port->PMUX[pin_index / 2].reg;
    1468:	464a      	mov	r2, r9
    146a:	0850      	lsrs	r0, r2, #1
    146c:	1c02      	adds	r2, r0, #0
    146e:	4452      	add	r2, sl
    1470:	3230      	adds	r2, #48	; 0x30
    1472:	7817      	ldrb	r7, [r2, #0]

	if (pin_index & 1) {
    1474:	4662      	mov	r2, ip

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
		return SYSTEM_PINMUX_GPIO;
	}

	uint32_t pmux_reg = port->PMUX[pin_index / 2].reg;
    1476:	b2ff      	uxtb	r7, r7

	if (pin_index & 1) {
    1478:	421a      	tst	r2, r3
    147a:	d136      	bne.n	14ea <spi_init+0x4ca>
    147c:	230f      	movs	r3, #15
    147e:	401f      	ands	r7, r3
    1480:	e67c      	b.n	117c <spi_init+0x15c>
#  endif

#  if CONF_SPI_MASTER_ENABLE == true
	/* Find baud value and compare it */
	if (config->mode == SPI_MODE_MASTER) {
		enum status_code error_code = _sercom_get_sync_baud_val(
    1482:	4b1b      	ldr	r3, [pc, #108]	; (14f0 <spi_init+0x4d0>)
    1484:	69a0      	ldr	r0, [r4, #24]
    1486:	aa01      	add	r2, sp, #4
    1488:	4798      	blx	r3
    148a:	1c03      	adds	r3, r0, #0
				config->mode_specific.master.baudrate,
				external_clock, &baud);

		if (error_code != STATUS_OK) {
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
    148c:	2017      	movs	r0, #23
	if (config->mode == SPI_MODE_MASTER) {
		enum status_code error_code = _sercom_get_sync_baud_val(
				config->mode_specific.master.baudrate,
				external_clock, &baud);

		if (error_code != STATUS_OK) {
    148e:	2b00      	cmp	r3, #0
    1490:	d000      	beq.n	1494 <spi_init+0x474>
    1492:	e5d9      	b.n	1048 <spi_init+0x28>
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
		}

		if (spi_module->BAUD.reg !=  (uint8_t)baud) {
    1494:	466a      	mov	r2, sp
    1496:	7b33      	ldrb	r3, [r6, #12]
    1498:	7912      	ldrb	r2, [r2, #4]
    149a:	429a      	cmp	r2, r3
    149c:	d000      	beq.n	14a0 <spi_init+0x480>
    149e:	e689      	b.n	11b4 <spi_init+0x194>
			return STATUS_ERR_DENIED;
		}

		ctrla |= SERCOM_SPI_CTRLA_MODE(0x3);
    14a0:	230c      	movs	r3, #12
    14a2:	7822      	ldrb	r2, [r4, #0]
    14a4:	469c      	mov	ip, r3
    14a6:	e677      	b.n	1198 <spi_init+0x178>

# if CONF_SPI_MASTER_ENABLE == true
	/* Find baud value and write it */
	if (config->mode == SPI_MODE_MASTER) {
		/* Find frequency of the internal SERCOMi_GCLK_ID_CORE */
		uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    14a8:	4b12      	ldr	r3, [pc, #72]	; (14f4 <spi_init+0x4d4>)
    14aa:	6828      	ldr	r0, [r5, #0]
    14ac:	4798      	blx	r3
		uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    14ae:	3014      	adds	r0, #20
		uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
    14b0:	4b11      	ldr	r3, [pc, #68]	; (14f8 <spi_init+0x4d8>)
    14b2:	b2c0      	uxtb	r0, r0
    14b4:	4798      	blx	r3

		/* Get baud value, based on baudrate and the internal clock frequency */
		enum status_code error_code = _sercom_get_sync_baud_val(
    14b6:	466b      	mov	r3, sp
	/* Find baud value and write it */
	if (config->mode == SPI_MODE_MASTER) {
		/* Find frequency of the internal SERCOMi_GCLK_ID_CORE */
		uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
		uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
		uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
    14b8:	1c01      	adds	r1, r0, #0

		/* Get baud value, based on baudrate and the internal clock frequency */
		enum status_code error_code = _sercom_get_sync_baud_val(
    14ba:	1c9a      	adds	r2, r3, #2
    14bc:	69a0      	ldr	r0, [r4, #24]
    14be:	4b0c      	ldr	r3, [pc, #48]	; (14f0 <spi_init+0x4d0>)
    14c0:	4798      	blx	r3
    14c2:	1c03      	adds	r3, r0, #0
				config->mode_specific.master.baudrate,
				internal_clock, &baud);

		if (error_code != STATUS_OK) {
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
    14c4:	2017      	movs	r0, #23
		/* Get baud value, based on baudrate and the internal clock frequency */
		enum status_code error_code = _sercom_get_sync_baud_val(
				config->mode_specific.master.baudrate,
				internal_clock, &baud);

		if (error_code != STATUS_OK) {
    14c6:	2b00      	cmp	r3, #0
    14c8:	d000      	beq.n	14cc <spi_init+0x4ac>
    14ca:	e5bd      	b.n	1048 <spi_init+0x28>
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
		}

		spi_module->BAUD.reg = (uint8_t)baud;
    14cc:	466b      	mov	r3, sp
    14ce:	464a      	mov	r2, r9
    14d0:	789b      	ldrb	r3, [r3, #2]
    14d2:	7313      	strb	r3, [r2, #12]
    14d4:	7823      	ldrb	r3, [r4, #0]
    14d6:	e6e1      	b.n	129c <spi_init+0x27c>

	ctrla |= SERCOM_SPI_CTRLA_ENABLE;

	/* Check that same config is set */
	if (spi_module->CTRLA.reg == ctrla &&
			spi_module->CTRLB.reg == ctrlb) {
    14d8:	6871      	ldr	r1, [r6, #4]
#  endif

	ctrla |= SERCOM_SPI_CTRLA_ENABLE;

	/* Check that same config is set */
	if (spi_module->CTRLA.reg == ctrla &&
    14da:	4299      	cmp	r1, r3
    14dc:	d000      	beq.n	14e0 <spi_init+0x4c0>
    14de:	e742      	b.n	1366 <spi_init+0x346>
			spi_module->CTRLB.reg == ctrlb) {
		module->mode           = config->mode;
    14e0:	716a      	strb	r2, [r5, #5]
		module->character_size = config->character_size;
    14e2:	7c23      	ldrb	r3, [r4, #16]
		return STATUS_OK;
    14e4:	2000      	movs	r0, #0

	/* Check that same config is set */
	if (spi_module->CTRLA.reg == ctrla &&
			spi_module->CTRLB.reg == ctrlb) {
		module->mode           = config->mode;
		module->character_size = config->character_size;
    14e6:	71ab      	strb	r3, [r5, #6]
    14e8:	e5ae      	b.n	1048 <spi_init+0x28>
		return (pmux_reg & PORT_PMUX_PMUXO_Msk) >> PORT_PMUX_PMUXO_Pos;
    14ea:	093f      	lsrs	r7, r7, #4
    14ec:	e646      	b.n	117c <spi_init+0x15c>
    14ee:	46c0      	nop			; (mov r8, r8)
    14f0:	00000115 	.word	0x00000115
    14f4:	000004d1 	.word	0x000004d1
    14f8:	00001e2d 	.word	0x00001e2d

000014fc <spi_select_slave>:
 */
enum status_code spi_select_slave(
		struct spi_module *const module,
		struct spi_slave_inst *const slave,
		const bool select)
{
    14fc:	b530      	push	{r4, r5, lr}
	Assert(module);
	Assert(module->hw);
	Assert(slave);

	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
    14fe:	7944      	ldrb	r4, [r0, #5]
 */
enum status_code spi_select_slave(
		struct spi_module *const module,
		struct spi_slave_inst *const slave,
		const bool select)
{
    1500:	1c03      	adds	r3, r0, #0
	Assert(module->hw);
	Assert(slave);

	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
		return STATUS_ERR_UNSUPPORTED_DEV;
    1502:	2015      	movs	r0, #21
	Assert(module);
	Assert(module->hw);
	Assert(slave);

	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
    1504:	2c01      	cmp	r4, #1
    1506:	d000      	beq.n	150a <spi_select_slave+0xe>
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
}
    1508:	bd30      	pop	{r4, r5, pc}
	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
		return STATUS_ERR_UNSUPPORTED_DEV;
	}
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if(!(module->master_slave_select_enable))
    150a:	7a18      	ldrb	r0, [r3, #8]
    150c:	2800      	cmp	r0, #0
    150e:	d122      	bne.n	1556 <spi_select_slave+0x5a>
#  endif
	{
		if (select) {
    1510:	2a00      	cmp	r2, #0
    1512:	d022      	beq.n	155a <spi_select_slave+0x5e>
			/* Check if address recognition is enabled */
			if (slave->address_enabled) {
    1514:	784a      	ldrb	r2, [r1, #1]
    1516:	2a00      	cmp	r2, #0
    1518:	d011      	beq.n	153e <spi_select_slave+0x42>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    151a:	681a      	ldr	r2, [r3, #0]
    151c:	7e12      	ldrb	r2, [r2, #24]
				/* Check if the module is ready to write the address */
				if (!spi_is_ready_to_write(module)) {
    151e:	4022      	ands	r2, r4
    1520:	d12d      	bne.n	157e <spi_select_slave+0x82>
					/* Not ready, do not select slave and return */
					port_pin_set_output_level(slave->ss_pin, true);
    1522:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    1524:	09d9      	lsrs	r1, r3, #7
    1526:	d126      	bne.n	1576 <spi_select_slave+0x7a>
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    1528:	311f      	adds	r1, #31
		return &(ports[port_index]->Group[group_index]);
    152a:	095a      	lsrs	r2, r3, #5
    152c:	400b      	ands	r3, r1
    152e:	409c      	lsls	r4, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    1530:	01d3      	lsls	r3, r2, #7
    1532:	4a27      	ldr	r2, [pc, #156]	; (15d0 <spi_select_slave+0xd4>)
					return STATUS_BUSY;
    1534:	2005      	movs	r0, #5
    1536:	4694      	mov	ip, r2
    1538:	4463      	add	r3, ip
    153a:	619c      	str	r4, [r3, #24]
    153c:	e7e4      	b.n	1508 <spi_select_slave+0xc>
					uint16_t flush = 0;
					spi_read(module, &flush);
				}
			} else {
				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
    153e:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    1540:	09d9      	lsrs	r1, r3, #7
    1542:	d11a      	bne.n	157a <spi_select_slave+0x7e>
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    1544:	311f      	adds	r1, #31
		return &(ports[port_index]->Group[group_index]);
    1546:	095a      	lsrs	r2, r3, #5
    1548:	400b      	ands	r3, r1
    154a:	409c      	lsls	r4, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    154c:	01d3      	lsls	r3, r2, #7
    154e:	4a21      	ldr	r2, [pc, #132]	; (15d4 <spi_select_slave+0xd8>)
    1550:	4694      	mov	ip, r2
    1552:	4463      	add	r3, ip
    1554:	605c      	str	r4, [r3, #4]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    1556:	2000      	movs	r0, #0
    1558:	e7d6      	b.n	1508 <spi_select_slave+0xc>
				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
			}
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
    155a:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    155c:	09d9      	lsrs	r1, r3, #7
    155e:	d10a      	bne.n	1576 <spi_select_slave+0x7a>
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    1560:	311f      	adds	r1, #31
		return &(ports[port_index]->Group[group_index]);
    1562:	095a      	lsrs	r2, r3, #5
    1564:	400b      	ands	r3, r1
    1566:	409c      	lsls	r4, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    1568:	01d3      	lsls	r3, r2, #7
    156a:	4a19      	ldr	r2, [pc, #100]	; (15d0 <spi_select_slave+0xd4>)
		}
	}
	return STATUS_OK;
    156c:	2000      	movs	r0, #0
    156e:	4694      	mov	ip, r2
    1570:	4463      	add	r3, ip
    1572:	619c      	str	r4, [r3, #24]
    1574:	e7c8      	b.n	1508 <spi_select_slave+0xc>
    1576:	6192      	str	r2, [r2, #24]
    1578:	deff      	udf	#255	; 0xff
	} else {
		port_base->OUTCLR.reg = pin_mask;
    157a:	6152      	str	r2, [r2, #20]
    157c:	deff      	udf	#255	; 0xff
					port_pin_set_output_level(slave->ss_pin, true);
					return STATUS_BUSY;
				}

				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
    157e:	780a      	ldrb	r2, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    1580:	09d5      	lsrs	r5, r2, #7
    1582:	d123      	bne.n	15cc <spi_select_slave+0xd0>
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    1584:	351f      	adds	r5, #31
		return &(ports[port_index]->Group[group_index]);
    1586:	0950      	lsrs	r0, r2, #5
    1588:	402a      	ands	r2, r5
    158a:	1c25      	adds	r5, r4, #0
    158c:	4095      	lsls	r5, r2
    158e:	1c2a      	adds	r2, r5, #0

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    1590:	4d10      	ldr	r5, [pc, #64]	; (15d4 <spi_select_slave+0xd8>)
    1592:	01c0      	lsls	r0, r0, #7
    1594:	46ac      	mov	ip, r5
    1596:	4460      	add	r0, ip
    1598:	6042      	str	r2, [r0, #4]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    159a:	681a      	ldr	r2, [r3, #0]

				/* Write address to slave */
				spi_write(module, slave->address);
    159c:	7889      	ldrb	r1, [r1, #2]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    159e:	7e10      	ldrb	r0, [r2, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    15a0:	4204      	tst	r4, r0
    15a2:	d000      	beq.n	15a6 <spi_select_slave+0xaa>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    15a4:	6291      	str	r1, [r2, #40]	; 0x28

				if (!(module->receiver_enabled)) {
    15a6:	79da      	ldrb	r2, [r3, #7]
    15a8:	2a00      	cmp	r2, #0
    15aa:	d1d4      	bne.n	1556 <spi_select_slave+0x5a>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    15ac:	2404      	movs	r4, #4
    15ae:	6819      	ldr	r1, [r3, #0]
    15b0:	7e0a      	ldrb	r2, [r1, #24]
    15b2:	2004      	movs	r0, #4
					/* Flush contents of shift register shifted back from slave */
					while (!spi_is_ready_to_read(module)) {
    15b4:	4214      	tst	r4, r2
    15b6:	d0fb      	beq.n	15b0 <spi_select_slave+0xb4>
    15b8:	7e0a      	ldrb	r2, [r1, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    15ba:	4210      	tst	r0, r2
    15bc:	d0cb      	beq.n	1556 <spi_select_slave+0x5a>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    15be:	8b4a      	ldrh	r2, [r1, #26]
    15c0:	4210      	tst	r0, r2
    15c2:	d000      	beq.n	15c6 <spi_select_slave+0xca>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
    15c4:	8348      	strh	r0, [r1, #26]

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    15c6:	6a8b      	ldr	r3, [r1, #40]	; 0x28
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    15c8:	2000      	movs	r0, #0
    15ca:	e79d      	b.n	1508 <spi_select_slave+0xc>
    15cc:	6140      	str	r0, [r0, #20]
    15ce:	deff      	udf	#255	; 0xff
    15d0:	41004400 	.word	0x41004400
    15d4:	41004410 	.word	0x41004410

000015d8 <spi_write_buffer_wait>:
 */
enum status_code spi_write_buffer_wait(
		struct spi_module *const module,
		const uint8_t *tx_data,
		uint16_t length)
{
    15d8:	b5f0      	push	{r4, r5, r6, r7, lr}
    15da:	4644      	mov	r4, r8
    15dc:	465f      	mov	r7, fp
    15de:	4656      	mov	r6, sl
    15e0:	464d      	mov	r5, r9
    15e2:	b4f0      	push	{r4, r5, r6, r7}
    15e4:	4688      	mov	r8, r1
    15e6:	b085      	sub	sp, #20
		return STATUS_BUSY;
	}
#  endif

	if (length == 0) {
		return STATUS_ERR_INVALID_ARG;
    15e8:	2317      	movs	r3, #23
		/* Check if the SPI module is busy with a job */
		return STATUS_BUSY;
	}
#  endif

	if (length == 0) {
    15ea:	2a00      	cmp	r2, #0
    15ec:	d107      	bne.n	15fe <spi_write_buffer_wait+0x26>
			}
		}
	}
#  endif
	return STATUS_OK;
}
    15ee:	1c18      	adds	r0, r3, #0
    15f0:	b005      	add	sp, #20
    15f2:	bc3c      	pop	{r2, r3, r4, r5}
    15f4:	4690      	mov	r8, r2
    15f6:	4699      	mov	r9, r3
    15f8:	46a2      	mov	sl, r4
    15fa:	46ab      	mov	fp, r5
    15fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (length == 0) {
		return STATUS_ERR_INVALID_ARG;
	}

#  if CONF_SPI_SLAVE_ENABLE == true
	if ((module->mode == SPI_MODE_SLAVE) && (spi_is_write_complete(module))) {
    15fe:	7943      	ldrb	r3, [r0, #5]
    1600:	469c      	mov	ip, r3
    1602:	2b00      	cmp	r3, #0
    1604:	d107      	bne.n	1616 <spi_write_buffer_wait+0x3e>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    1606:	2102      	movs	r1, #2
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1608:	6803      	ldr	r3, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    160a:	7e1c      	ldrb	r4, [r3, #24]
    160c:	4221      	tst	r1, r4
    160e:	d002      	beq.n	1616 <spi_write_buffer_wait+0x3e>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Clear interrupt flag */
	spi_module->INTFLAG.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
    1610:	7619      	strb	r1, [r3, #24]
    1612:	7943      	ldrb	r3, [r0, #5]
    1614:	469c      	mov	ip, r3
    1616:	2102      	movs	r1, #2
    1618:	1c13      	adds	r3, r2, #0
    161a:	9202      	str	r2, [sp, #8]

	uint16_t tx_pos = 0;
	uint16_t flush_length = length;

	/* Write block */
	while (length--) {
    161c:	4a67      	ldr	r2, [pc, #412]	; (17bc <spi_write_buffer_wait+0x1e4>)
    161e:	468a      	mov	sl, r1
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    1620:	3102      	adds	r1, #2
    1622:	4691      	mov	r9, r2
    1624:	2500      	movs	r5, #0
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    1626:	2201      	movs	r2, #1
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    1628:	468b      	mov	fp, r1
    162a:	4667      	mov	r7, ip
    162c:	3b01      	subs	r3, #1
    162e:	b29e      	uxth	r6, r3
    1630:	454e      	cmp	r6, r9
    1632:	d02f      	beq.n	1694 <spi_write_buffer_wait+0xbc>
    1634:	6803      	ldr	r3, [r0, #0]
#  if CONF_SPI_SLAVE_ENABLE == true
		/* Start timeout period for slave */
		if (module->mode == SPI_MODE_SLAVE) {
    1636:	2f00      	cmp	r7, #0
    1638:	d10f      	bne.n	165a <spi_write_buffer_wait+0x82>
    163a:	4961      	ldr	r1, [pc, #388]	; (17c0 <spi_write_buffer_wait+0x1e8>)
    163c:	e002      	b.n	1644 <spi_write_buffer_wait+0x6c>
    163e:	3901      	subs	r1, #1
			for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
    1640:	2900      	cmp	r1, #0
    1642:	d002      	beq.n	164a <spi_write_buffer_wait+0x72>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    1644:	7e1c      	ldrb	r4, [r3, #24]
				if (spi_is_ready_to_write(module)) {
    1646:	4222      	tst	r2, r4
    1648:	d0f9      	beq.n	163e <spi_write_buffer_wait+0x66>
					break;
				}
			}
			/* Check if master has ended the transaction */
			if (spi_is_write_complete(module)) {
    164a:	4654      	mov	r4, sl
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    164c:	7e19      	ldrb	r1, [r3, #24]
    164e:	420c      	tst	r4, r1
    1650:	d000      	beq.n	1654 <spi_write_buffer_wait+0x7c>
    1652:	e090      	b.n	1776 <spi_write_buffer_wait+0x19e>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    1654:	7e19      	ldrb	r1, [r3, #24]
				_spi_clear_tx_complete_flag(module);
				return STATUS_ABORTED;
			}

			if (!spi_is_ready_to_write(module)) {
    1656:	420a      	tst	r2, r1
    1658:	d045      	beq.n	16e6 <spi_write_buffer_wait+0x10e>
    165a:	7e19      	ldrb	r1, [r3, #24]
			}
		}
#  endif

		/* Wait until the module is ready to write a character */
		while (!spi_is_ready_to_write(module)) {
    165c:	420a      	tst	r2, r1
    165e:	d0fc      	beq.n	165a <spi_write_buffer_wait+0x82>
		}

		/* Write value will be at least 8-bits long */
		uint16_t data_to_send = tx_data[tx_pos++];
    1660:	4641      	mov	r1, r8
    1662:	5d49      	ldrb	r1, [r1, r5]
    1664:	1c6c      	adds	r4, r5, #1
    1666:	9101      	str	r1, [sp, #4]

		/* If 9-bit data, get next byte to send from the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    1668:	7981      	ldrb	r1, [r0, #6]
		/* Wait until the module is ready to write a character */
		while (!spi_is_ready_to_write(module)) {
		}

		/* Write value will be at least 8-bits long */
		uint16_t data_to_send = tx_data[tx_pos++];
    166a:	b2a4      	uxth	r4, r4

		/* If 9-bit data, get next byte to send from the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    166c:	2901      	cmp	r1, #1
    166e:	d032      	beq.n	16d6 <spi_write_buffer_wait+0xfe>
		/* Wait until the module is ready to write a character */
		while (!spi_is_ready_to_write(module)) {
		}

		/* Write value will be at least 8-bits long */
		uint16_t data_to_send = tx_data[tx_pos++];
    1670:	4669      	mov	r1, sp
    1672:	1c25      	adds	r5, r4, #0
    1674:	8889      	ldrh	r1, [r1, #4]
    1676:	7e1c      	ldrb	r4, [r3, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    1678:	4222      	tst	r2, r4
    167a:	d003      	beq.n	1684 <spi_write_buffer_wait+0xac>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    167c:	05c9      	lsls	r1, r1, #23
    167e:	0dc9      	lsrs	r1, r1, #23
    1680:	6299      	str	r1, [r3, #40]	; 0x28
    1682:	7947      	ldrb	r7, [r0, #5]
		}

		/* Write the data to send */
		spi_write(module, data_to_send);

		if (module->receiver_enabled) {
    1684:	79c1      	ldrb	r1, [r0, #7]
    1686:	1e73      	subs	r3, r6, #1
    1688:	b29c      	uxth	r4, r3
    168a:	2900      	cmp	r1, #0
    168c:	d133      	bne.n	16f6 <spi_write_buffer_wait+0x11e>
    168e:	1e26      	subs	r6, r4, #0

	uint16_t tx_pos = 0;
	uint16_t flush_length = length;

	/* Write block */
	while (length--) {
    1690:	454e      	cmp	r6, r9
    1692:	d1cf      	bne.n	1634 <spi_write_buffer_wait+0x5c>
    1694:	9a02      	ldr	r2, [sp, #8]
			flush_length--;
		}
	}

#  if CONF_SPI_MASTER_ENABLE == true
	if (module->mode == SPI_MODE_MASTER) {
    1696:	2f01      	cmp	r7, #1
    1698:	d100      	bne.n	169c <spi_write_buffer_wait+0xc4>
    169a:	e083      	b.n	17a4 <spi_write_buffer_wait+0x1cc>
		}
	}
#  endif

#  if CONF_SPI_SLAVE_ENABLE == true
	if (module->mode == SPI_MODE_SLAVE) {
    169c:	2f00      	cmp	r7, #0
    169e:	d118      	bne.n	16d2 <spi_write_buffer_wait+0xfa>
		if (module->receiver_enabled) {
    16a0:	79c3      	ldrb	r3, [r0, #7]
    16a2:	2b00      	cmp	r3, #0
    16a4:	d015      	beq.n	16d2 <spi_write_buffer_wait+0xfa>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    16a6:	2504      	movs	r5, #4
			while (flush_length) {
    16a8:	2a00      	cmp	r2, #0
    16aa:	d012      	beq.n	16d2 <spi_write_buffer_wait+0xfa>
    16ac:	6804      	ldr	r4, [r0, #0]
    16ae:	4b44      	ldr	r3, [pc, #272]	; (17c0 <spi_write_buffer_wait+0x1e8>)
    16b0:	e002      	b.n	16b8 <spi_write_buffer_wait+0xe0>
    16b2:	3b01      	subs	r3, #1
				/* Start timeout period for slave */
				for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
    16b4:	2b00      	cmp	r3, #0
    16b6:	d002      	beq.n	16be <spi_write_buffer_wait+0xe6>
    16b8:	7e21      	ldrb	r1, [r4, #24]
					if (spi_is_ready_to_read(module)) {
    16ba:	420d      	tst	r5, r1
    16bc:	d0f9      	beq.n	16b2 <spi_write_buffer_wait+0xda>
    16be:	7e23      	ldrb	r3, [r4, #24]
						break;
					}
				}
				if (!spi_is_ready_to_read(module)) {
    16c0:	421d      	tst	r5, r3
    16c2:	d010      	beq.n	16e6 <spi_write_buffer_wait+0x10e>
    16c4:	7e23      	ldrb	r3, [r4, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    16c6:	421d      	tst	r5, r3
    16c8:	d10f      	bne.n	16ea <spi_write_buffer_wait+0x112>
					return STATUS_ERR_TIMEOUT;
				}
				/* Flush read buffer */
				uint16_t flush;
				spi_read(module, &flush);
				flush_length--;
    16ca:	3a01      	subs	r2, #1
    16cc:	b292      	uxth	r2, r2
#  endif

#  if CONF_SPI_SLAVE_ENABLE == true
	if (module->mode == SPI_MODE_SLAVE) {
		if (module->receiver_enabled) {
			while (flush_length) {
    16ce:	2a00      	cmp	r2, #0
    16d0:	d1ec      	bne.n	16ac <spi_write_buffer_wait+0xd4>
				flush_length--;
			}
		}
	}
#  endif
	return STATUS_OK;
    16d2:	2300      	movs	r3, #0
    16d4:	e78b      	b.n	15ee <spi_write_buffer_wait+0x16>
		/* Write value will be at least 8-bits long */
		uint16_t data_to_send = tx_data[tx_pos++];

		/* If 9-bit data, get next byte to send from the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
			data_to_send |= (tx_data[tx_pos++] << 8);
    16d6:	4641      	mov	r1, r8
    16d8:	5d0c      	ldrb	r4, [r1, r4]
    16da:	9901      	ldr	r1, [sp, #4]
    16dc:	3502      	adds	r5, #2
    16de:	0224      	lsls	r4, r4, #8
    16e0:	b2ad      	uxth	r5, r5
    16e2:	4321      	orrs	r1, r4
    16e4:	e7c7      	b.n	1676 <spi_write_buffer_wait+0x9e>
				return STATUS_ABORTED;
			}

			if (!spi_is_ready_to_write(module)) {
				/* Not ready to write data within timeout period */
				return STATUS_ERR_TIMEOUT;
    16e6:	2312      	movs	r3, #18
    16e8:	e781      	b.n	15ee <spi_write_buffer_wait+0x16>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    16ea:	8b63      	ldrh	r3, [r4, #26]
    16ec:	421d      	tst	r5, r3
    16ee:	d000      	beq.n	16f2 <spi_write_buffer_wait+0x11a>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
    16f0:	8365      	strh	r5, [r4, #26]

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    16f2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    16f4:	e7e9      	b.n	16ca <spi_write_buffer_wait+0xf2>
		spi_write(module, data_to_send);

		if (module->receiver_enabled) {
#  if CONF_SPI_SLAVE_ENABLE == true
			/* Start timeout period for slave */
			if (module->mode == SPI_MODE_SLAVE) {
    16f6:	2f00      	cmp	r7, #0
    16f8:	d00e      	beq.n	1718 <spi_write_buffer_wait+0x140>
    16fa:	6804      	ldr	r4, [r0, #0]
					return STATUS_ERR_TIMEOUT;
				}
			}
#  endif

			while (!spi_is_ready_to_read(module)) {
    16fc:	465f      	mov	r7, fp
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    16fe:	7e21      	ldrb	r1, [r4, #24]
    1700:	2604      	movs	r6, #4
    1702:	420f      	tst	r7, r1
    1704:	d0fa      	beq.n	16fc <spi_write_buffer_wait+0x124>
    1706:	7e21      	ldrb	r1, [r4, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    1708:	420e      	tst	r6, r1
    170a:	d145      	bne.n	1798 <spi_write_buffer_wait+0x1c0>
			}

			/* Flush read buffer */
			uint16_t flush;
			spi_read(module, &flush);
			flush_length--;
    170c:	9902      	ldr	r1, [sp, #8]
    170e:	3901      	subs	r1, #1
    1710:	b289      	uxth	r1, r1
    1712:	9102      	str	r1, [sp, #8]
    1714:	7947      	ldrb	r7, [r0, #5]
    1716:	e78a      	b.n	162e <spi_write_buffer_wait+0x56>
		spi_write(module, data_to_send);

		if (module->receiver_enabled) {
#  if CONF_SPI_SLAVE_ENABLE == true
			/* Start timeout period for slave */
			if (module->mode == SPI_MODE_SLAVE) {
    1718:	4644      	mov	r4, r8
    171a:	6801      	ldr	r1, [r0, #0]
    171c:	4b28      	ldr	r3, [pc, #160]	; (17c0 <spi_write_buffer_wait+0x1e8>)
    171e:	9403      	str	r4, [sp, #12]
    1720:	e012      	b.n	1748 <spi_write_buffer_wait+0x170>
				for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
					if (length && spi_is_ready_to_write(module)) {
						data_to_send = tx_data[tx_pos++];
    1722:	466c      	mov	r4, sp
    1724:	4665      	mov	r5, ip
    1726:	88a4      	ldrh	r4, [r4, #4]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    1728:	7e0f      	ldrb	r7, [r1, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    172a:	423a      	tst	r2, r7
    172c:	d003      	beq.n	1736 <spi_write_buffer_wait+0x15e>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    172e:	05e4      	lsls	r4, r4, #23
    1730:	0de4      	lsrs	r4, r4, #23
    1732:	628c      	str	r4, [r1, #40]	; 0x28
    1734:	6801      	ldr	r1, [r0, #0]
							data_to_send |= (tx_data[tx_pos++] << 8);
						}

						/* Write the data to send */
						spi_write(module, data_to_send);
						length--;
    1736:	3e01      	subs	r6, #1
    1738:	b2b6      	uxth	r6, r6
					}
					if (spi_is_ready_to_read(module)) {
    173a:	465f      	mov	r7, fp
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    173c:	7e0c      	ldrb	r4, [r1, #24]
    173e:	4227      	tst	r7, r4
    1740:	d11d      	bne.n	177e <spi_write_buffer_wait+0x1a6>
    1742:	3b01      	subs	r3, #1

		if (module->receiver_enabled) {
#  if CONF_SPI_SLAVE_ENABLE == true
			/* Start timeout period for slave */
			if (module->mode == SPI_MODE_SLAVE) {
				for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
    1744:	2b00      	cmp	r3, #0
    1746:	d01a      	beq.n	177e <spi_write_buffer_wait+0x1a6>
					if (length && spi_is_ready_to_write(module)) {
    1748:	2e00      	cmp	r6, #0
    174a:	d0f6      	beq.n	173a <spi_write_buffer_wait+0x162>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    174c:	7e0c      	ldrb	r4, [r1, #24]
    174e:	4222      	tst	r2, r4
    1750:	d0f3      	beq.n	173a <spi_write_buffer_wait+0x162>
						data_to_send = tx_data[tx_pos++];
    1752:	1c6c      	adds	r4, r5, #1
    1754:	b2a4      	uxth	r4, r4
    1756:	46a4      	mov	ip, r4
    1758:	9c03      	ldr	r4, [sp, #12]
    175a:	5d64      	ldrb	r4, [r4, r5]
    175c:	9401      	str	r4, [sp, #4]
						/* If 9-bit data, get next byte to send from the buffer */
						if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    175e:	7987      	ldrb	r7, [r0, #6]
    1760:	2f01      	cmp	r7, #1
    1762:	d1de      	bne.n	1722 <spi_write_buffer_wait+0x14a>
							data_to_send |= (tx_data[tx_pos++] << 8);
    1764:	4667      	mov	r7, ip
    1766:	9c03      	ldr	r4, [sp, #12]
    1768:	3502      	adds	r5, #2
    176a:	5de7      	ldrb	r7, [r4, r7]
    176c:	9c01      	ldr	r4, [sp, #4]
    176e:	023f      	lsls	r7, r7, #8
    1770:	b2ad      	uxth	r5, r5
    1772:	433c      	orrs	r4, r7
    1774:	e7d8      	b.n	1728 <spi_write_buffer_wait+0x150>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Clear interrupt flag */
	spi_module->INTFLAG.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
    1776:	2202      	movs	r2, #2
    1778:	761a      	strb	r2, [r3, #24]
				}
			}
			/* Check if master has ended the transaction */
			if (spi_is_write_complete(module)) {
				_spi_clear_tx_complete_flag(module);
				return STATUS_ABORTED;
    177a:	2304      	movs	r3, #4
    177c:	e737      	b.n	15ee <spi_write_buffer_wait+0x16>
						break;
					}
				}

				/* Check if master has ended the transaction */
				if (spi_is_write_complete(module)) {
    177e:	4657      	mov	r7, sl
    1780:	9b03      	ldr	r3, [sp, #12]
    1782:	1c0c      	adds	r4, r1, #0
    1784:	4698      	mov	r8, r3
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    1786:	7e0b      	ldrb	r3, [r1, #24]
    1788:	421f      	tst	r7, r3
    178a:	d112      	bne.n	17b2 <spi_write_buffer_wait+0x1da>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    178c:	7e0b      	ldrb	r3, [r1, #24]
					_spi_clear_tx_complete_flag(module);
					return STATUS_ABORTED;
				}

				if (!spi_is_ready_to_read(module)) {
    178e:	4659      	mov	r1, fp
    1790:	4219      	tst	r1, r3
    1792:	d0a8      	beq.n	16e6 <spi_write_buffer_wait+0x10e>
    1794:	1e73      	subs	r3, r6, #1
    1796:	e7b1      	b.n	16fc <spi_write_buffer_wait+0x124>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    1798:	8b61      	ldrh	r1, [r4, #26]
    179a:	420f      	tst	r7, r1
    179c:	d000      	beq.n	17a0 <spi_write_buffer_wait+0x1c8>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
    179e:	8366      	strh	r6, [r4, #26]

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    17a0:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    17a2:	e7b3      	b.n	170c <spi_write_buffer_wait+0x134>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    17a4:	2202      	movs	r2, #2
    17a6:	6801      	ldr	r1, [r0, #0]
    17a8:	7e0b      	ldrb	r3, [r1, #24]
	}

#  if CONF_SPI_MASTER_ENABLE == true
	if (module->mode == SPI_MODE_MASTER) {
		/* Wait for last byte to be transferred */
		while (!spi_is_write_complete(module)) {
    17aa:	421a      	tst	r2, r3
    17ac:	d0fc      	beq.n	17a8 <spi_write_buffer_wait+0x1d0>
				flush_length--;
			}
		}
	}
#  endif
	return STATUS_OK;
    17ae:	2300      	movs	r3, #0
    17b0:	e71d      	b.n	15ee <spi_write_buffer_wait+0x16>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Clear interrupt flag */
	spi_module->INTFLAG.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
    17b2:	2302      	movs	r3, #2
    17b4:	760b      	strb	r3, [r1, #24]
				}

				/* Check if master has ended the transaction */
				if (spi_is_write_complete(module)) {
					_spi_clear_tx_complete_flag(module);
					return STATUS_ABORTED;
    17b6:	3302      	adds	r3, #2
    17b8:	e719      	b.n	15ee <spi_write_buffer_wait+0x16>
    17ba:	46c0      	nop			; (mov r8, r8)
    17bc:	0000ffff 	.word	0x0000ffff
    17c0:	00002711 	.word	0x00002711

000017c4 <_sercom_default_handler>:
 */
static void _sercom_default_handler(
		const uint8_t instance)
{
	Assert(false);
}
    17c4:	4770      	bx	lr
    17c6:	46c0      	nop			; (mov r8, r8)

000017c8 <_sercom_set_handler>:
 * \param[in]  interrupt_handler  Pointer to instance callback handler.
 */
void _sercom_set_handler(
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
    17c8:	b530      	push	{r4, r5, lr}
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
    17ca:	4d0c      	ldr	r5, [pc, #48]	; (17fc <_sercom_set_handler+0x34>)
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    17cc:	4b0c      	ldr	r3, [pc, #48]	; (1800 <_sercom_set_handler+0x38>)
void _sercom_set_handler(
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
    17ce:	782a      	ldrb	r2, [r5, #0]
    17d0:	2a00      	cmp	r2, #0
    17d2:	d10f      	bne.n	17f4 <_sercom_set_handler+0x2c>
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    17d4:	4c0b      	ldr	r4, [pc, #44]	; (1804 <_sercom_set_handler+0x3c>)
    17d6:	601c      	str	r4, [r3, #0]
    17d8:	605c      	str	r4, [r3, #4]
    17da:	609c      	str	r4, [r3, #8]
    17dc:	60dc      	str	r4, [r3, #12]
    17de:	611c      	str	r4, [r3, #16]
    17e0:	615c      	str	r4, [r3, #20]
    17e2:	4c09      	ldr	r4, [pc, #36]	; (1808 <_sercom_set_handler+0x40>)
    17e4:	6022      	str	r2, [r4, #0]
    17e6:	6062      	str	r2, [r4, #4]
    17e8:	60a2      	str	r2, [r4, #8]
    17ea:	60e2      	str	r2, [r4, #12]
    17ec:	6122      	str	r2, [r4, #16]
    17ee:	6162      	str	r2, [r4, #20]
			_sercom_instances[i] = NULL;
		}

		_handler_table_initialized = true;
    17f0:	2201      	movs	r2, #1
    17f2:	702a      	strb	r2, [r5, #0]
	}

	/* Save interrupt handler */
	_sercom_interrupt_handlers[instance] = interrupt_handler;
    17f4:	0080      	lsls	r0, r0, #2
    17f6:	5019      	str	r1, [r3, r0]
}
    17f8:	bd30      	pop	{r4, r5, pc}
    17fa:	46c0      	nop			; (mov r8, r8)
    17fc:	20000128 	.word	0x20000128
    1800:	2000012c 	.word	0x2000012c
    1804:	000017c5 	.word	0x000017c5
    1808:	200001b0 	.word	0x200001b0

0000180c <_sercom_get_interrupt_vector>:
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM6
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM7
 */
enum system_interrupt_vector _sercom_get_interrupt_vector(
		Sercom *const sercom_instance)
{
    180c:	b510      	push	{r4, lr}
    180e:	1c04      	adds	r4, r0, #0
    1810:	b082      	sub	sp, #8
	const uint8_t sercom_int_vectors[SERCOM_INST_NUM] =
    1812:	4906      	ldr	r1, [pc, #24]	; (182c <_sercom_get_interrupt_vector+0x20>)
    1814:	2206      	movs	r2, #6
    1816:	4668      	mov	r0, sp
    1818:	4b05      	ldr	r3, [pc, #20]	; (1830 <_sercom_get_interrupt_vector+0x24>)
    181a:	4798      	blx	r3
		{
			MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_VECT_NUM, ~)
		};

	/* Retrieve the index of the SERCOM being requested */
	uint8_t instance_index = _sercom_get_sercom_inst_index(sercom_instance);
    181c:	1c20      	adds	r0, r4, #0
    181e:	4b05      	ldr	r3, [pc, #20]	; (1834 <_sercom_get_interrupt_vector+0x28>)
    1820:	4798      	blx	r3

	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
    1822:	466b      	mov	r3, sp
    1824:	5618      	ldrsb	r0, [r3, r0]
}
    1826:	b002      	add	sp, #8
    1828:	bd10      	pop	{r4, pc}
    182a:	46c0      	nop			; (mov r8, r8)
    182c:	00003274 	.word	0x00003274
    1830:	000027f9 	.word	0x000027f9
    1834:	000004d1 	.word	0x000004d1

00001838 <SERCOM0_Handler>:

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
    1838:	b508      	push	{r3, lr}
    183a:	4b02      	ldr	r3, [pc, #8]	; (1844 <SERCOM0_Handler+0xc>)
    183c:	2000      	movs	r0, #0
    183e:	681b      	ldr	r3, [r3, #0]
    1840:	4798      	blx	r3
    1842:	bd08      	pop	{r3, pc}
    1844:	2000012c 	.word	0x2000012c

00001848 <SERCOM1_Handler>:
    1848:	b508      	push	{r3, lr}
    184a:	4b02      	ldr	r3, [pc, #8]	; (1854 <SERCOM1_Handler+0xc>)
    184c:	2001      	movs	r0, #1
    184e:	685b      	ldr	r3, [r3, #4]
    1850:	4798      	blx	r3
    1852:	bd08      	pop	{r3, pc}
    1854:	2000012c 	.word	0x2000012c

00001858 <SERCOM2_Handler>:
    1858:	b508      	push	{r3, lr}
    185a:	4b02      	ldr	r3, [pc, #8]	; (1864 <SERCOM2_Handler+0xc>)
    185c:	2002      	movs	r0, #2
    185e:	689b      	ldr	r3, [r3, #8]
    1860:	4798      	blx	r3
    1862:	bd08      	pop	{r3, pc}
    1864:	2000012c 	.word	0x2000012c

00001868 <SERCOM3_Handler>:
    1868:	b508      	push	{r3, lr}
    186a:	4b02      	ldr	r3, [pc, #8]	; (1874 <SERCOM3_Handler+0xc>)
    186c:	2003      	movs	r0, #3
    186e:	68db      	ldr	r3, [r3, #12]
    1870:	4798      	blx	r3
    1872:	bd08      	pop	{r3, pc}
    1874:	2000012c 	.word	0x2000012c

00001878 <SERCOM4_Handler>:
    1878:	b508      	push	{r3, lr}
    187a:	4b02      	ldr	r3, [pc, #8]	; (1884 <SERCOM4_Handler+0xc>)
    187c:	2004      	movs	r0, #4
    187e:	691b      	ldr	r3, [r3, #16]
    1880:	4798      	blx	r3
    1882:	bd08      	pop	{r3, pc}
    1884:	2000012c 	.word	0x2000012c

00001888 <SERCOM5_Handler>:
    1888:	b508      	push	{r3, lr}
    188a:	4b02      	ldr	r3, [pc, #8]	; (1894 <SERCOM5_Handler+0xc>)
    188c:	2005      	movs	r0, #5
    188e:	695b      	ldr	r3, [r3, #20]
    1890:	4798      	blx	r3
    1892:	bd08      	pop	{r3, pc}
    1894:	2000012c 	.word	0x2000012c

00001898 <cpu_irq_enter_critical>:
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
    1898:	4b0b      	ldr	r3, [pc, #44]	; (18c8 <cpu_irq_enter_critical+0x30>)
    189a:	681a      	ldr	r2, [r3, #0]
    189c:	2a00      	cmp	r2, #0
    189e:	d105      	bne.n	18ac <cpu_irq_enter_critical+0x14>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    18a0:	f3ef 8110 	mrs	r1, PRIMASK
		if (cpu_irq_is_enabled()) {
    18a4:	2900      	cmp	r1, #0
    18a6:	d005      	beq.n	18b4 <cpu_irq_enter_critical+0x1c>
			cpu_irq_disable();
			cpu_irq_prev_interrupt_state = true;
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
    18a8:	4908      	ldr	r1, [pc, #32]	; (18cc <cpu_irq_enter_critical+0x34>)
    18aa:	700a      	strb	r2, [r1, #0]
		}

	}

	cpu_irq_critical_section_counter++;
    18ac:	681a      	ldr	r2, [r3, #0]
    18ae:	3201      	adds	r2, #1
    18b0:	601a      	str	r2, [r3, #0]
}
    18b2:	4770      	bx	lr
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    18b4:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
    18b6:	f3bf 8f5f 	dmb	sy

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
		if (cpu_irq_is_enabled()) {
			cpu_irq_disable();
    18ba:	4a05      	ldr	r2, [pc, #20]	; (18d0 <cpu_irq_enter_critical+0x38>)
    18bc:	7011      	strb	r1, [r2, #0]
			cpu_irq_prev_interrupt_state = true;
    18be:	4a03      	ldr	r2, [pc, #12]	; (18cc <cpu_irq_enter_critical+0x34>)
    18c0:	3101      	adds	r1, #1
    18c2:	7011      	strb	r1, [r2, #0]
    18c4:	e7f2      	b.n	18ac <cpu_irq_enter_critical+0x14>
    18c6:	46c0      	nop			; (mov r8, r8)
    18c8:	20000144 	.word	0x20000144
    18cc:	20000148 	.word	0x20000148
    18d0:	20000004 	.word	0x20000004

000018d4 <cpu_irq_leave_critical>:
void cpu_irq_leave_critical(void)
{
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
    18d4:	4b08      	ldr	r3, [pc, #32]	; (18f8 <cpu_irq_leave_critical+0x24>)
    18d6:	681a      	ldr	r2, [r3, #0]
    18d8:	3a01      	subs	r2, #1
    18da:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
    18dc:	681b      	ldr	r3, [r3, #0]
    18de:	2b00      	cmp	r3, #0
    18e0:	d109      	bne.n	18f6 <cpu_irq_leave_critical+0x22>
    18e2:	4b06      	ldr	r3, [pc, #24]	; (18fc <cpu_irq_leave_critical+0x28>)
    18e4:	781b      	ldrb	r3, [r3, #0]
    18e6:	2b00      	cmp	r3, #0
    18e8:	d005      	beq.n	18f6 <cpu_irq_leave_critical+0x22>
		cpu_irq_enable();
    18ea:	2201      	movs	r2, #1
    18ec:	4b04      	ldr	r3, [pc, #16]	; (1900 <cpu_irq_leave_critical+0x2c>)
    18ee:	701a      	strb	r2, [r3, #0]
    18f0:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    18f4:	b662      	cpsie	i
	}
}
    18f6:	4770      	bx	lr
    18f8:	20000144 	.word	0x20000144
    18fc:	20000148 	.word	0x20000148
    1900:	20000004 	.word	0x20000004

00001904 <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
    1904:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
    1906:	2501      	movs	r5, #1
	config->powersave  = false;
    1908:	2700      	movs	r7, #0
    190a:	b083      	sub	sp, #12
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
    190c:	ac01      	add	r4, sp, #4
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Configure LEDs as outputs, turn them off */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
	port_pin_set_config(LED_0_PIN, &pin_conf);
    190e:	1c21      	adds	r1, r4, #0
    1910:	4e08      	ldr	r6, [pc, #32]	; (1934 <system_board_init+0x30>)
    1912:	203e      	movs	r0, #62	; 0x3e
    1914:	7065      	strb	r5, [r4, #1]
	config->powersave  = false;
    1916:	70a7      	strb	r7, [r4, #2]
{
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Configure LEDs as outputs, turn them off */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
    1918:	7025      	strb	r5, [r4, #0]
	port_pin_set_config(LED_0_PIN, &pin_conf);
    191a:	47b0      	blx	r6
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    191c:	2280      	movs	r2, #128	; 0x80
    191e:	4b06      	ldr	r3, [pc, #24]	; (1938 <system_board_init+0x34>)
    1920:	05d2      	lsls	r2, r2, #23
    1922:	619a      	str	r2, [r3, #24]
	port_pin_set_output_level(LED_0_PIN, LED_0_INACTIVE);

	/* Set buttons as inputs */
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
	pin_conf.input_pull = PORT_PIN_PULL_UP;
	port_pin_set_config(BUTTON_0_PIN, &pin_conf);
    1924:	200f      	movs	r0, #15
    1926:	1c21      	adds	r1, r4, #0
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
	port_pin_set_config(LED_0_PIN, &pin_conf);
	port_pin_set_output_level(LED_0_PIN, LED_0_INACTIVE);

	/* Set buttons as inputs */
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
    1928:	7027      	strb	r7, [r4, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
    192a:	7065      	strb	r5, [r4, #1]
	port_pin_set_config(BUTTON_0_PIN, &pin_conf);
    192c:	47b0      	blx	r6
	port_pin_set_output_level(AT86RFX_RST_PIN, true);
	port_pin_set_output_level(AT86RFX_SLP_PIN, true);
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
	port_pin_set_config(AT86RFX_SPI_MISO, &pin_conf);
#endif	
}
    192e:	b003      	add	sp, #12
    1930:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1932:	46c0      	nop			; (mov r8, r8)
    1934:	0000193d 	.word	0x0000193d
    1938:	41004480 	.word	0x41004480

0000193c <port_pin_set_config>:
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    193c:	2280      	movs	r2, #128	; 0x80
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
    193e:	b500      	push	{lr}
    1940:	b083      	sub	sp, #12
    1942:	ab01      	add	r3, sp, #4
    1944:	701a      	strb	r2, [r3, #0]

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
    1946:	780a      	ldrb	r2, [r1, #0]
    1948:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
    194a:	784a      	ldrb	r2, [r1, #1]
    194c:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
    194e:	788a      	ldrb	r2, [r1, #2]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
    1950:	1c19      	adds	r1, r3, #0
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
	pinmux_config.powersave    = config->powersave;
    1952:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
    1954:	4b01      	ldr	r3, [pc, #4]	; (195c <port_pin_set_config+0x20>)
    1956:	4798      	blx	r3
}
    1958:	b003      	add	sp, #12
    195a:	bd00      	pop	{pc}
    195c:	00001ed1 	.word	0x00001ed1

00001960 <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
    1960:	b510      	push	{r4, lr}
	switch (clock_source) {
    1962:	2808      	cmp	r0, #8
    1964:	d82c      	bhi.n	19c0 <system_clock_source_get_hz+0x60>
    1966:	4b1b      	ldr	r3, [pc, #108]	; (19d4 <system_clock_source_get_hz+0x74>)
    1968:	0080      	lsls	r0, r0, #2
    196a:	581b      	ldr	r3, [r3, r0]
    196c:	469f      	mov	pc, r3

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		return 32768UL;
    196e:	2080      	movs	r0, #128	; 0x80
    1970:	0200      	lsls	r0, r0, #8
#endif

	default:
		return 0;
	}
}
    1972:	bd10      	pop	{r4, pc}

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		return 32768UL;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		return _system_clock_inst.xosc32k.frequency;
    1974:	4b18      	ldr	r3, [pc, #96]	; (19d8 <system_clock_source_get_hz+0x78>)
    1976:	6958      	ldr	r0, [r3, #20]
    1978:	e7fb      	b.n	1972 <system_clock_source_get_hz+0x12>
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_XOSC:
		return _system_clock_inst.xosc.frequency;

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;
    197a:	4b18      	ldr	r3, [pc, #96]	; (19dc <system_clock_source_get_hz+0x7c>)
    197c:	6a18      	ldr	r0, [r3, #32]
    197e:	4b18      	ldr	r3, [pc, #96]	; (19e0 <system_clock_source_get_hz+0x80>)
    1980:	0580      	lsls	r0, r0, #22
    1982:	0f80      	lsrs	r0, r0, #30
    1984:	40c3      	lsrs	r3, r0
    1986:	1c18      	adds	r0, r3, #0
    1988:	e7f3      	b.n	1972 <system_clock_source_get_hz+0x12>
		return _system_clock_inst.xosc32k.frequency;

	case SYSTEM_CLOCK_SOURCE_DFLL:

		/* Check if the DFLL has been configured */
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
    198a:	2002      	movs	r0, #2
    198c:	4c12      	ldr	r4, [pc, #72]	; (19d8 <system_clock_source_get_hz+0x78>)
    198e:	6823      	ldr	r3, [r4, #0]
    1990:	4018      	ands	r0, r3
    1992:	d0ee      	beq.n	1972 <system_clock_source_get_hz+0x12>
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    1994:	2210      	movs	r2, #16
    1996:	4911      	ldr	r1, [pc, #68]	; (19dc <system_clock_source_get_hz+0x7c>)
    1998:	68cb      	ldr	r3, [r1, #12]
    199a:	421a      	tst	r2, r3
    199c:	d0fc      	beq.n	1998 <system_clock_source_get_hz+0x38>

		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
    199e:	6823      	ldr	r3, [r4, #0]
    19a0:	075b      	lsls	r3, r3, #29
    19a2:	d40f      	bmi.n	19c4 <system_clock_source_get_hz+0x64>
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
					(_system_clock_inst.dfll.mul & 0xffff);
		}

		return 48000000UL;
    19a4:	480f      	ldr	r0, [pc, #60]	; (19e4 <system_clock_source_get_hz+0x84>)
    19a6:	e7e4      	b.n	1972 <system_clock_source_get_hz+0x12>
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_XOSC:
		return _system_clock_inst.xosc.frequency;
    19a8:	4b0b      	ldr	r3, [pc, #44]	; (19d8 <system_clock_source_get_hz+0x78>)
    19aa:	6918      	ldr	r0, [r3, #16]
    19ac:	e7e1      	b.n	1972 <system_clock_source_get_hz+0x12>

		return 48000000UL;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
    19ae:	2350      	movs	r3, #80	; 0x50
    19b0:	4a0a      	ldr	r2, [pc, #40]	; (19dc <system_clock_source_get_hz+0x7c>)

	case SYSTEM_CLOCK_SOURCE_DFLL:

		/* Check if the DFLL has been configured */
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
			return 0;
    19b2:	2000      	movs	r0, #0

		return 48000000UL;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
    19b4:	5cd3      	ldrb	r3, [r2, r3]
    19b6:	075b      	lsls	r3, r3, #29
    19b8:	d5db      	bpl.n	1972 <system_clock_source_get_hz+0x12>
			return 0;
		}

		return _system_clock_inst.dpll.frequency;
    19ba:	4b07      	ldr	r3, [pc, #28]	; (19d8 <system_clock_source_get_hz+0x78>)
    19bc:	68d8      	ldr	r0, [r3, #12]
    19be:	e7d8      	b.n	1972 <system_clock_source_get_hz+0x12>
#endif

	default:
		return 0;
    19c0:	2000      	movs	r0, #0
    19c2:	e7d6      	b.n	1972 <system_clock_source_get_hz+0x12>
		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    19c4:	4b08      	ldr	r3, [pc, #32]	; (19e8 <system_clock_source_get_hz+0x88>)
    19c6:	2000      	movs	r0, #0
    19c8:	4798      	blx	r3
					(_system_clock_inst.dfll.mul & 0xffff);
    19ca:	68a3      	ldr	r3, [r4, #8]
    19cc:	041b      	lsls	r3, r3, #16
    19ce:	0c1b      	lsrs	r3, r3, #16
		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    19d0:	4358      	muls	r0, r3
    19d2:	e7ce      	b.n	1972 <system_clock_source_get_hz+0x12>
    19d4:	0000327c 	.word	0x0000327c
    19d8:	2000014c 	.word	0x2000014c
    19dc:	40000800 	.word	0x40000800
    19e0:	007a1200 	.word	0x007a1200
    19e4:	02dc6c00 	.word	0x02dc6c00
    19e8:	00001e2d 	.word	0x00001e2d

000019ec <system_clock_source_xosc32k_set_config>:
 *
 * \param[in] config  XOSC32K configuration structure containing the new config
 */
void system_clock_source_xosc32k_set_config(
		struct system_clock_source_xosc32k_config *const config)
{
    19ec:	b5f0      	push	{r4, r5, r6, r7, lr}
    19ee:	465f      	mov	r7, fp
    19f0:	4656      	mov	r6, sl
    19f2:	464d      	mov	r5, r9
    19f4:	4644      	mov	r4, r8
    19f6:	b4f0      	push	{r4, r5, r6, r7}
	SYSCTRL_XOSC32K_Type temp = SYSCTRL->XOSC32K;
    19f8:	4e2e      	ldr	r6, [pc, #184]	; (1ab4 <system_clock_source_xosc32k_set_config+0xc8>)
 *
 * \param[in] config  XOSC32K configuration structure containing the new config
 */
void system_clock_source_xosc32k_set_config(
		struct system_clock_source_xosc32k_config *const config)
{
    19fa:	b083      	sub	sp, #12
	SYSCTRL_XOSC32K_Type temp = SYSCTRL->XOSC32K;
    19fc:	8ab3      	ldrh	r3, [r6, #20]

	temp.bit.STARTUP = config->startup_time;
    19fe:	7845      	ldrb	r5, [r0, #1]
 * \param[in] config  XOSC32K configuration structure containing the new config
 */
void system_clock_source_xosc32k_set_config(
		struct system_clock_source_xosc32k_config *const config)
{
	SYSCTRL_XOSC32K_Type temp = SYSCTRL->XOSC32K;
    1a00:	469c      	mov	ip, r3

	temp.bit.STARTUP = config->startup_time;

	if (config->external_clock == SYSTEM_CLOCK_EXTERNAL_CRYSTAL) {
    1a02:	7803      	ldrb	r3, [r0, #0]

	temp.bit.AAMPEN = config->auto_gain_control;
	temp.bit.EN1K = config->enable_1khz_output;
	temp.bit.EN32K = config->enable_32khz_output;

	temp.bit.ONDEMAND = config->on_demand;
    1a04:	7b47      	ldrb	r7, [r0, #13]
{
	SYSCTRL_XOSC32K_Type temp = SYSCTRL->XOSC32K;

	temp.bit.STARTUP = config->startup_time;

	if (config->external_clock == SYSTEM_CLOCK_EXTERNAL_CRYSTAL) {
    1a06:	425a      	negs	r2, r3
    1a08:	415a      	adcs	r2, r3
    1a0a:	4691      	mov	r9, r2
		temp.bit.XTALEN = 0;
	}

	temp.bit.AAMPEN = config->auto_gain_control;
	temp.bit.EN1K = config->enable_1khz_output;
	temp.bit.EN32K = config->enable_32khz_output;
    1a0c:	7902      	ldrb	r2, [r0, #4]
		temp.bit.XTALEN = 1;
	} else {
		temp.bit.XTALEN = 0;
	}

	temp.bit.AAMPEN = config->auto_gain_control;
    1a0e:	7883      	ldrb	r3, [r0, #2]
	temp.bit.EN1K = config->enable_1khz_output;
	temp.bit.EN32K = config->enable_32khz_output;
    1a10:	4690      	mov	r8, r2

	temp.bit.ONDEMAND = config->on_demand;
	temp.bit.RUNSTDBY = config->run_in_standby;
    1a12:	7b02      	ldrb	r2, [r0, #12]
		temp.bit.XTALEN = 1;
	} else {
		temp.bit.XTALEN = 0;
	}

	temp.bit.AAMPEN = config->auto_gain_control;
    1a14:	469b      	mov	fp, r3
	temp.bit.EN1K = config->enable_1khz_output;
    1a16:	78c3      	ldrb	r3, [r0, #3]
	temp.bit.EN32K = config->enable_32khz_output;

	temp.bit.ONDEMAND = config->on_demand;
	temp.bit.RUNSTDBY = config->run_in_standby;
    1a18:	9201      	str	r2, [sp, #4]
	temp.bit.WRTLOCK  = config->write_once;
    1a1a:	7b84      	ldrb	r4, [r0, #14]

	/* Cache the new frequency in case the user needs to check the current
	 * operating frequency later */
	_system_clock_inst.xosc32k.frequency = config->frequency;
    1a1c:	6882      	ldr	r2, [r0, #8]
    1a1e:	4826      	ldr	r0, [pc, #152]	; (1ab8 <system_clock_source_xosc32k_set_config+0xcc>)
    1a20:	6142      	str	r2, [r0, #20]

	SYSCTRL->XOSC32K = temp;
    1a22:	464a      	mov	r2, r9
    1a24:	0092      	lsls	r2, r2, #2
    1a26:	4691      	mov	r9, r2
    1a28:	2204      	movs	r2, #4
    1a2a:	4692      	mov	sl, r2
    1a2c:	4662      	mov	r2, ip
    1a2e:	4651      	mov	r1, sl
    1a30:	438a      	bics	r2, r1
    1a32:	4694      	mov	ip, r2
    1a34:	464a      	mov	r2, r9
    1a36:	4661      	mov	r1, ip
    1a38:	430a      	orrs	r2, r1
    1a3a:	2001      	movs	r0, #1
    1a3c:	4694      	mov	ip, r2
    1a3e:	4642      	mov	r2, r8
    1a40:	4002      	ands	r2, r0
    1a42:	00d2      	lsls	r2, r2, #3
    1a44:	4690      	mov	r8, r2
    1a46:	2208      	movs	r2, #8
    1a48:	4691      	mov	r9, r2
    1a4a:	4662      	mov	r2, ip
    1a4c:	4649      	mov	r1, r9
    1a4e:	438a      	bics	r2, r1
    1a50:	4694      	mov	ip, r2
    1a52:	4642      	mov	r2, r8
    1a54:	4661      	mov	r1, ip
    1a56:	430a      	orrs	r2, r1
    1a58:	4694      	mov	ip, r2
    1a5a:	2210      	movs	r2, #16
    1a5c:	4690      	mov	r8, r2
    1a5e:	4662      	mov	r2, ip
    1a60:	4641      	mov	r1, r8
    1a62:	4003      	ands	r3, r0
    1a64:	438a      	bics	r2, r1
    1a66:	011b      	lsls	r3, r3, #4
    1a68:	4659      	mov	r1, fp
    1a6a:	4313      	orrs	r3, r2
    1a6c:	2220      	movs	r2, #32
    1a6e:	4001      	ands	r1, r0
    1a70:	0149      	lsls	r1, r1, #5
    1a72:	4393      	bics	r3, r2
    1a74:	430b      	orrs	r3, r1
    1a76:	2140      	movs	r1, #64	; 0x40
    1a78:	9a01      	ldr	r2, [sp, #4]
    1a7a:	438b      	bics	r3, r1
    1a7c:	4002      	ands	r2, r0
    1a7e:	0192      	lsls	r2, r2, #6
    1a80:	4313      	orrs	r3, r2
    1a82:	2280      	movs	r2, #128	; 0x80
    1a84:	4007      	ands	r7, r0
    1a86:	01ff      	lsls	r7, r7, #7
    1a88:	4393      	bics	r3, r2
    1a8a:	433b      	orrs	r3, r7
    1a8c:	3a79      	subs	r2, #121	; 0x79
    1a8e:	4f0b      	ldr	r7, [pc, #44]	; (1abc <system_clock_source_xosc32k_set_config+0xd0>)
    1a90:	4015      	ands	r5, r2
    1a92:	4004      	ands	r4, r0
    1a94:	0320      	lsls	r0, r4, #12
    1a96:	022d      	lsls	r5, r5, #8
    1a98:	403b      	ands	r3, r7
    1a9a:	4c09      	ldr	r4, [pc, #36]	; (1ac0 <system_clock_source_xosc32k_set_config+0xd4>)
    1a9c:	432b      	orrs	r3, r5
    1a9e:	401c      	ands	r4, r3
    1aa0:	4304      	orrs	r4, r0
    1aa2:	82b4      	strh	r4, [r6, #20]
}
    1aa4:	b003      	add	sp, #12
    1aa6:	bc3c      	pop	{r2, r3, r4, r5}
    1aa8:	4690      	mov	r8, r2
    1aaa:	4699      	mov	r9, r3
    1aac:	46a2      	mov	sl, r4
    1aae:	46ab      	mov	fp, r5
    1ab0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1ab2:	46c0      	nop			; (mov r8, r8)
    1ab4:	40000800 	.word	0x40000800
    1ab8:	2000014c 	.word	0x2000014c
    1abc:	fffff8ff 	.word	0xfffff8ff
    1ac0:	ffffefff 	.word	0xffffefff

00001ac4 <system_clock_source_dfll_set_config>:
 *
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
    1ac4:	b530      	push	{r4, r5, lr}
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
    1ac6:	7a03      	ldrb	r3, [r0, #8]
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
    1ac8:	491b      	ldr	r1, [pc, #108]	; (1b38 <system_clock_source_dfll_set_config+0x74>)
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
    1aca:	069b      	lsls	r3, r3, #26
    1acc:	0c1a      	lsrs	r2, r3, #16
			SYSCTRL_DFLLVAL_FINE(config->fine_value);
    1ace:	8943      	ldrh	r3, [r0, #10]
    1ad0:	059b      	lsls	r3, r3, #22
    1ad2:	0d9b      	lsrs	r3, r3, #22
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
    1ad4:	4313      	orrs	r3, r2
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
    1ad6:	604b      	str	r3, [r1, #4]
    1ad8:	8843      	ldrh	r3, [r0, #2]
    1ada:	8884      	ldrh	r4, [r0, #4]
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
    1adc:	7982      	ldrb	r2, [r0, #6]
    1ade:	431c      	orrs	r4, r3
    1ae0:	79c3      	ldrb	r3, [r0, #7]
    1ae2:	4313      	orrs	r3, r2
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);
    1ae4:	7842      	ldrb	r2, [r0, #1]
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
    1ae6:	4323      	orrs	r3, r4
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);
    1ae8:	01d2      	lsls	r2, r2, #7

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
    1aea:	4313      	orrs	r3, r2
{
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
    1aec:	600b      	str	r3, [r1, #0]
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
    1aee:	7803      	ldrb	r3, [r0, #0]
    1af0:	2b04      	cmp	r3, #4
    1af2:	d011      	beq.n	1b18 <system_clock_source_dfll_set_config+0x54>
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {
    1af4:	2b20      	cmp	r3, #32
    1af6:	d10e      	bne.n	1b16 <system_clock_source_dfll_set_config+0x52>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
    1af8:	7b03      	ldrb	r3, [r0, #12]
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
    1afa:	8a02      	ldrh	r2, [r0, #16]
		_system_clock_inst.dfll.control |= config->loop_mode;
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
    1afc:	069b      	lsls	r3, r3, #26
    1afe:	4313      	orrs	r3, r2
    1b00:	1c1c      	adds	r4, r3, #0
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    1b02:	89c3      	ldrh	r3, [r0, #14]
    1b04:	4a0d      	ldr	r2, [pc, #52]	; (1b3c <system_clock_source_dfll_set_config+0x78>)
    1b06:	041b      	lsls	r3, r3, #16
    1b08:	4013      	ands	r3, r2
    1b0a:	4323      	orrs	r3, r4
		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {

		_system_clock_inst.dfll.mul =
    1b0c:	608b      	str	r3, [r1, #8]
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the USB recovery mode */
		_system_clock_inst.dfll.control |= config->loop_mode |
    1b0e:	680b      	ldr	r3, [r1, #0]
    1b10:	4a0b      	ldr	r2, [pc, #44]	; (1b40 <system_clock_source_dfll_set_config+0x7c>)
    1b12:	4313      	orrs	r3, r2
    1b14:	600b      	str	r3, [r1, #0]
				SYSCTRL_DFLLCTRL_MODE | SYSCTRL_DFLLCTRL_BPLCKC;
	}
}
    1b16:	bd30      	pop	{r4, r5, pc}
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
    1b18:	7b02      	ldrb	r2, [r0, #12]
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
    1b1a:	8a05      	ldrh	r5, [r0, #16]
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
    1b1c:	0692      	lsls	r2, r2, #26
    1b1e:	432a      	orrs	r2, r5
    1b20:	1c14      	adds	r4, r2, #0
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    1b22:	89c2      	ldrh	r2, [r0, #14]
    1b24:	4805      	ldr	r0, [pc, #20]	; (1b3c <system_clock_source_dfll_set_config+0x78>)
    1b26:	0412      	lsls	r2, r2, #16
    1b28:	4002      	ands	r2, r0
    1b2a:	4322      	orrs	r2, r4
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
    1b2c:	608a      	str	r2, [r1, #8]
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
    1b2e:	680a      	ldr	r2, [r1, #0]
    1b30:	4313      	orrs	r3, r2
    1b32:	600b      	str	r3, [r1, #0]
    1b34:	e7ef      	b.n	1b16 <system_clock_source_dfll_set_config+0x52>
    1b36:	46c0      	nop			; (mov r8, r8)
    1b38:	2000014c 	.word	0x2000014c
    1b3c:	03ff0000 	.word	0x03ff0000
    1b40:	00000424 	.word	0x00000424

00001b44 <system_clock_source_enable>:
 * \retval STATUS_ERR_INVALID_ARG  The clock source is not available on this
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
    1b44:	b510      	push	{r4, lr}
	switch (clock_source) {
    1b46:	2808      	cmp	r0, #8
    1b48:	d845      	bhi.n	1bd6 <system_clock_source_enable+0x92>
    1b4a:	4b24      	ldr	r3, [pc, #144]	; (1bdc <system_clock_source_enable+0x98>)
    1b4c:	0080      	lsls	r0, r0, #2
    1b4e:	581b      	ldr	r3, [r3, r0]
    1b50:	469f      	mov	pc, r3
		break;
#endif

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Always enabled */
		return STATUS_OK;
    1b52:	2000      	movs	r0, #0
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
}
    1b54:	bd10      	pop	{r4, pc}
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
		return STATUS_OK;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
    1b56:	2302      	movs	r3, #2
    1b58:	4a21      	ldr	r2, [pc, #132]	; (1be0 <system_clock_source_enable+0x9c>)
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    1b5a:	2000      	movs	r0, #0
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
		return STATUS_OK;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
    1b5c:	6991      	ldr	r1, [r2, #24]
    1b5e:	430b      	orrs	r3, r1
    1b60:	6193      	str	r3, [r2, #24]
		break;
    1b62:	e7f7      	b.n	1b54 <system_clock_source_enable+0x10>
	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
    1b64:	2302      	movs	r3, #2
    1b66:	4a1e      	ldr	r2, [pc, #120]	; (1be0 <system_clock_source_enable+0x9c>)
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    1b68:	2000      	movs	r0, #0
	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
    1b6a:	8a91      	ldrh	r1, [r2, #20]
    1b6c:	430b      	orrs	r3, r1
    1b6e:	8293      	strh	r3, [r2, #20]
		break;
    1b70:	e7f0      	b.n	1b54 <system_clock_source_enable+0x10>
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
    1b72:	2302      	movs	r3, #2
    1b74:	4a1a      	ldr	r2, [pc, #104]	; (1be0 <system_clock_source_enable+0x9c>)
		return STATUS_OK;
    1b76:	2000      	movs	r0, #0
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
    1b78:	6a11      	ldr	r1, [r2, #32]
    1b7a:	430b      	orrs	r3, r1
    1b7c:	6213      	str	r3, [r2, #32]
		return STATUS_OK;
    1b7e:	e7e9      	b.n	1b54 <system_clock_source_enable+0x10>
	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
    1b80:	2202      	movs	r2, #2
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    1b82:	2010      	movs	r0, #16
	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
    1b84:	4c17      	ldr	r4, [pc, #92]	; (1be4 <system_clock_source_enable+0xa0>)

static inline void _system_clock_source_dfll_set_config_errata_9905(void)
{

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
    1b86:	4916      	ldr	r1, [pc, #88]	; (1be0 <system_clock_source_enable+0x9c>)
	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
    1b88:	6823      	ldr	r3, [r4, #0]
    1b8a:	4313      	orrs	r3, r2
    1b8c:	6023      	str	r3, [r4, #0]

static inline void _system_clock_source_dfll_set_config_errata_9905(void)
{

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
    1b8e:	848a      	strh	r2, [r1, #36]	; 0x24
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    1b90:	68ca      	ldr	r2, [r1, #12]
    1b92:	4b13      	ldr	r3, [pc, #76]	; (1be0 <system_clock_source_enable+0x9c>)
    1b94:	4210      	tst	r0, r2
    1b96:	d0fb      	beq.n	1b90 <system_clock_source_enable+0x4c>

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
	_system_dfll_wait_for_sync();

	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
    1b98:	68a2      	ldr	r2, [r4, #8]
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    1b9a:	2110      	movs	r1, #16

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
	_system_dfll_wait_for_sync();

	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
    1b9c:	62da      	str	r2, [r3, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
    1b9e:	6862      	ldr	r2, [r4, #4]
    1ba0:	629a      	str	r2, [r3, #40]	; 0x28

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = 0;
    1ba2:	2200      	movs	r2, #0
    1ba4:	849a      	strh	r2, [r3, #36]	; 0x24
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    1ba6:	68da      	ldr	r2, [r3, #12]
    1ba8:	4211      	tst	r1, r2
    1baa:	d0fc      	beq.n	1ba6 <system_clock_source_enable+0x62>
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = 0;
	_system_dfll_wait_for_sync();
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
    1bac:	6823      	ldr	r3, [r4, #0]
    1bae:	4a0c      	ldr	r2, [pc, #48]	; (1be0 <system_clock_source_enable+0x9c>)
    1bb0:	b29b      	uxth	r3, r3
    1bb2:	8493      	strh	r3, [r2, #36]	; 0x24
    1bb4:	2000      	movs	r0, #0
    1bb6:	e7cd      	b.n	1b54 <system_clock_source_enable+0x10>
		_system_clock_source_dfll_set_config_errata_9905();
		break;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
    1bb8:	2244      	movs	r2, #68	; 0x44
    1bba:	2302      	movs	r3, #2
    1bbc:	4908      	ldr	r1, [pc, #32]	; (1be0 <system_clock_source_enable+0x9c>)
    1bbe:	5c88      	ldrb	r0, [r1, r2]
    1bc0:	4303      	orrs	r3, r0
    1bc2:	548b      	strb	r3, [r1, r2]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    1bc4:	2000      	movs	r0, #0
		break;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
		break;
    1bc6:	e7c5      	b.n	1b54 <system_clock_source_enable+0x10>
	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
    1bc8:	2302      	movs	r3, #2
    1bca:	4a05      	ldr	r2, [pc, #20]	; (1be0 <system_clock_source_enable+0x9c>)
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    1bcc:	2000      	movs	r0, #0
	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
    1bce:	8a11      	ldrh	r1, [r2, #16]
    1bd0:	430b      	orrs	r3, r1
    1bd2:	8213      	strh	r3, [r2, #16]
		break;
    1bd4:	e7be      	b.n	1b54 <system_clock_source_enable+0x10>
		/* Always enabled */
		return STATUS_OK;

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    1bd6:	2017      	movs	r0, #23
    1bd8:	e7bc      	b.n	1b54 <system_clock_source_enable+0x10>
    1bda:	46c0      	nop			; (mov r8, r8)
    1bdc:	000032a0 	.word	0x000032a0
    1be0:	40000800 	.word	0x40000800
    1be4:	2000014c 	.word	0x2000014c

00001be8 <system_clock_init>:
 */
void system_clock_init(void)
{
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
    1be8:	22c2      	movs	r2, #194	; 0xc2
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
    1bea:	211e      	movs	r1, #30
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
    1bec:	b570      	push	{r4, r5, r6, lr}
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
    1bee:	4b1c      	ldr	r3, [pc, #112]	; (1c60 <system_clock_init+0x78>)
    1bf0:	00d2      	lsls	r2, r2, #3
    1bf2:	609a      	str	r2, [r3, #8]
    1bf4:	4a1b      	ldr	r2, [pc, #108]	; (1c64 <system_clock_init+0x7c>)
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    1bf6:	2400      	movs	r4, #0
    1bf8:	6853      	ldr	r3, [r2, #4]
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
    1bfa:	b084      	sub	sp, #16
    1bfc:	438b      	bics	r3, r1
    1bfe:	6053      	str	r3, [r2, #4]
{
	uint32_t gclk_id;
	struct system_gclk_chan_config gclk_conf;

#if CONF_CLOCK_GCLK_1_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_1;
    1c00:	2301      	movs	r3, #1
    1c02:	ad01      	add	r5, sp, #4
    1c04:	4e18      	ldr	r6, [pc, #96]	; (1c68 <system_clock_init+0x80>)
    1c06:	702b      	strb	r3, [r5, #0]
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
    1c08:	b2e0      	uxtb	r0, r4
    1c0a:	1c29      	adds	r1, r5, #0
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    1c0c:	3401      	adds	r4, #1
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
    1c0e:	47b0      	blx	r6
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    1c10:	2c25      	cmp	r4, #37	; 0x25
    1c12:	d1f9      	bne.n	1c08 <system_clock_init+0x20>
	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
	temp.bit.ONDEMAND = config->on_demand;
	temp.bit.RUNSTDBY = config->run_in_standby;

	SYSCTRL->OSC8M = temp;
    1c14:	2140      	movs	r1, #64	; 0x40
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
    1c16:	4b12      	ldr	r3, [pc, #72]	; (1c60 <system_clock_init+0x78>)
    1c18:	6a1a      	ldr	r2, [r3, #32]
	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
	temp.bit.ONDEMAND = config->on_demand;
	temp.bit.RUNSTDBY = config->run_in_standby;

	SYSCTRL->OSC8M = temp;
    1c1a:	438a      	bics	r2, r1
    1c1c:	3140      	adds	r1, #64	; 0x40
    1c1e:	430a      	orrs	r2, r1
    1c20:	4912      	ldr	r1, [pc, #72]	; (1c6c <system_clock_init+0x84>)
    1c22:	400a      	ands	r2, r1
    1c24:	621a      	str	r2, [r3, #32]
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
    1c26:	2202      	movs	r2, #2
    1c28:	6a19      	ldr	r1, [r3, #32]
    1c2a:	430a      	orrs	r2, r1
    1c2c:	621a      	str	r2, [r3, #32]
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
    1c2e:	4b10      	ldr	r3, [pc, #64]	; (1c70 <system_clock_init+0x88>)
    1c30:	4798      	blx	r3
 */
static inline void system_cpu_clock_set_divider(
		const enum system_main_clock_div divider)
{
	Assert(((uint32_t)divider & PM_CPUSEL_CPUDIV_Msk) == divider);
	PM->CPUSEL.reg = (uint32_t)divider;
    1c32:	2300      	movs	r3, #0
    1c34:	4a0f      	ldr	r2, [pc, #60]	; (1c74 <system_clock_init+0x8c>)
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBC, CONF_CLOCK_APBC_DIVIDER);

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
    1c36:	1c29      	adds	r1, r5, #0
    1c38:	7213      	strb	r3, [r2, #8]
		const enum system_clock_apb_bus bus,
		const enum system_main_clock_div divider)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBASEL.reg = (uint32_t)divider;
    1c3a:	7253      	strb	r3, [r2, #9]
			break;
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBSEL.reg = (uint32_t)divider;
    1c3c:	7293      	strb	r3, [r2, #10]
			break;
		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCSEL.reg = (uint32_t)divider;
    1c3e:	72d3      	strb	r3, [r2, #11]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    1c40:	2201      	movs	r2, #1
	config->high_when_disabled = false;
    1c42:	706b      	strb	r3, [r5, #1]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    1c44:	606a      	str	r2, [r5, #4]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    1c46:	722b      	strb	r3, [r5, #8]
#if SAML21 || SAML22
	config->source_clock       = GCLK_SOURCE_OSC16M;
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
    1c48:	3205      	adds	r2, #5
#endif
	config->run_in_standby     = false;
	config->output_enable      = false;
    1c4a:	726b      	strb	r3, [r5, #9]
    1c4c:	2000      	movs	r0, #0
    1c4e:	4b0a      	ldr	r3, [pc, #40]	; (1c78 <system_clock_init+0x90>)
#if SAML21 || SAML22
	config->source_clock       = GCLK_SOURCE_OSC16M;
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
    1c50:	702a      	strb	r2, [r5, #0]
    1c52:	4798      	blx	r3
    1c54:	2000      	movs	r0, #0
    1c56:	4b09      	ldr	r3, [pc, #36]	; (1c7c <system_clock_init+0x94>)
    1c58:	4798      	blx	r3
#endif
}
    1c5a:	b004      	add	sp, #16
    1c5c:	bd70      	pop	{r4, r5, r6, pc}
    1c5e:	46c0      	nop			; (mov r8, r8)
    1c60:	40000800 	.word	0x40000800
    1c64:	41004000 	.word	0x41004000
    1c68:	00001d99 	.word	0x00001d99
    1c6c:	fffffcff 	.word	0xfffffcff
    1c70:	00001c81 	.word	0x00001c81
    1c74:	40000400 	.word	0x40000400
    1c78:	00001ca5 	.word	0x00001ca5
    1c7c:	00001d55 	.word	0x00001d55

00001c80 <system_gclk_init>:
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    1c80:	2308      	movs	r3, #8
    1c82:	4a06      	ldr	r2, [pc, #24]	; (1c9c <system_gclk_init+0x1c>)
    1c84:	6991      	ldr	r1, [r2, #24]
    1c86:	430b      	orrs	r3, r1
    1c88:	6193      	str	r3, [r2, #24]
{
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
    1c8a:	2301      	movs	r3, #1
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
    1c8c:	2101      	movs	r1, #1
{
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
    1c8e:	4a04      	ldr	r2, [pc, #16]	; (1ca0 <system_gclk_init+0x20>)
    1c90:	7013      	strb	r3, [r2, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
    1c92:	7813      	ldrb	r3, [r2, #0]
    1c94:	4219      	tst	r1, r3
    1c96:	d1fc      	bne.n	1c92 <system_gclk_init+0x12>
		/* Wait for reset to complete */
	}
}
    1c98:	4770      	bx	lr
    1c9a:	46c0      	nop			; (mov r8, r8)
    1c9c:	40000400 	.word	0x40000400
    1ca0:	40000c00 	.word	0x40000c00

00001ca4 <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
    1ca4:	b570      	push	{r4, r5, r6, lr}
	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
    1ca6:	780d      	ldrb	r5, [r1, #0]

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
    1ca8:	784b      	ldrb	r3, [r1, #1]
	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
    1caa:	022d      	lsls	r5, r5, #8
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
    1cac:	1c06      	adds	r6, r0, #0
	/* Sanity check arguments */
	Assert(config);

	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
    1cae:	1c04      	adds	r4, r0, #0
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
    1cb0:	4305      	orrs	r5, r0

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
    1cb2:	2b00      	cmp	r3, #0
    1cb4:	d002      	beq.n	1cbc <system_gclk_gen_set_config+0x18>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
    1cb6:	2380      	movs	r3, #128	; 0x80
    1cb8:	02db      	lsls	r3, r3, #11
    1cba:	431d      	orrs	r5, r3
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
    1cbc:	7a4b      	ldrb	r3, [r1, #9]
    1cbe:	2b00      	cmp	r3, #0
    1cc0:	d002      	beq.n	1cc8 <system_gclk_gen_set_config+0x24>
		new_genctrl_config |= GCLK_GENCTRL_OE;
    1cc2:	2380      	movs	r3, #128	; 0x80
    1cc4:	031b      	lsls	r3, r3, #12
    1cc6:	431d      	orrs	r5, r3
	}

	/* Set division factor */
	if (config->division_factor > 1) {
    1cc8:	6848      	ldr	r0, [r1, #4]
    1cca:	2801      	cmp	r0, #1
    1ccc:	d90f      	bls.n	1cee <system_gclk_gen_set_config+0x4a>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
    1cce:	1e43      	subs	r3, r0, #1
    1cd0:	4003      	ands	r3, r0
    1cd2:	d131      	bne.n	1d38 <system_gclk_gen_set_config+0x94>
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    1cd4:	2802      	cmp	r0, #2
    1cd6:	d005      	beq.n	1ce4 <system_gclk_gen_set_config+0x40>
    1cd8:	2202      	movs	r2, #2
						mask <<= 1) {
				div2_count++;
    1cda:	3301      	adds	r3, #1

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
						mask <<= 1) {
    1cdc:	0052      	lsls	r2, r2, #1
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    1cde:	4290      	cmp	r0, r2
    1ce0:	d8fb      	bhi.n	1cda <system_gclk_gen_set_config+0x36>
    1ce2:	021b      	lsls	r3, r3, #8
						mask <<= 1) {
				div2_count++;
			}

			/* Set binary divider power of 2 division factor */
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
    1ce4:	4333      	orrs	r3, r6
    1ce6:	1c1c      	adds	r4, r3, #0
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
    1ce8:	2380      	movs	r3, #128	; 0x80
    1cea:	035b      	lsls	r3, r3, #13
    1cec:	431d      	orrs	r5, r3
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
    1cee:	7a0b      	ldrb	r3, [r1, #8]
    1cf0:	2b00      	cmp	r3, #0
    1cf2:	d002      	beq.n	1cfa <system_gclk_gen_set_config+0x56>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
    1cf4:	2380      	movs	r3, #128	; 0x80
    1cf6:	039b      	lsls	r3, r3, #14
    1cf8:	431d      	orrs	r5, r3
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1cfa:	4a12      	ldr	r2, [pc, #72]	; (1d44 <system_gclk_gen_set_config+0xa0>)
    1cfc:	7853      	ldrb	r3, [r2, #1]
    1cfe:	b25b      	sxtb	r3, r3
    1d00:	2b00      	cmp	r3, #0
    1d02:	dbfb      	blt.n	1cfc <system_gclk_gen_set_config+0x58>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1d04:	4b10      	ldr	r3, [pc, #64]	; (1d48 <system_gclk_gen_set_config+0xa4>)
    1d06:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    1d08:	4b10      	ldr	r3, [pc, #64]	; (1d4c <system_gclk_gen_set_config+0xa8>)
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1d0a:	490e      	ldr	r1, [pc, #56]	; (1d44 <system_gclk_gen_set_config+0xa0>)
	};

	system_interrupt_enter_critical_section();

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    1d0c:	701e      	strb	r6, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1d0e:	784a      	ldrb	r2, [r1, #1]
    1d10:	4b0c      	ldr	r3, [pc, #48]	; (1d44 <system_gclk_gen_set_config+0xa0>)
    1d12:	b252      	sxtb	r2, r2
    1d14:	2a00      	cmp	r2, #0
    1d16:	dbfa      	blt.n	1d0e <system_gclk_gen_set_config+0x6a>
    1d18:	1c1a      	adds	r2, r3, #0

	/* Write the new generator configuration */
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;
    1d1a:	609c      	str	r4, [r3, #8]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1d1c:	7853      	ldrb	r3, [r2, #1]
    1d1e:	4909      	ldr	r1, [pc, #36]	; (1d44 <system_gclk_gen_set_config+0xa0>)
    1d20:	b25b      	sxtb	r3, r3
    1d22:	2b00      	cmp	r3, #0
    1d24:	dbfa      	blt.n	1d1c <system_gclk_gen_set_config+0x78>
	GCLK->GENDIV.reg  = new_gendiv_config;

	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
    1d26:	2380      	movs	r3, #128	; 0x80
    1d28:	684a      	ldr	r2, [r1, #4]
    1d2a:	025b      	lsls	r3, r3, #9
    1d2c:	4013      	ands	r3, r2
    1d2e:	431d      	orrs	r5, r3
    1d30:	604d      	str	r5, [r1, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1d32:	4b07      	ldr	r3, [pc, #28]	; (1d50 <system_gclk_gen_set_config+0xac>)
    1d34:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    1d36:	bd70      	pop	{r4, r5, r6, pc}

			new_gendiv_config  |=
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    1d38:	2380      	movs	r3, #128	; 0x80
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;
    1d3a:	0204      	lsls	r4, r0, #8

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    1d3c:	029b      	lsls	r3, r3, #10
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
    1d3e:	4334      	orrs	r4, r6
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    1d40:	431d      	orrs	r5, r3
    1d42:	e7d4      	b.n	1cee <system_gclk_gen_set_config+0x4a>
    1d44:	40000c00 	.word	0x40000c00
    1d48:	00001899 	.word	0x00001899
    1d4c:	40000c08 	.word	0x40000c08
    1d50:	000018d5 	.word	0x000018d5

00001d54 <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
    1d54:	b510      	push	{r4, lr}
    1d56:	1c04      	adds	r4, r0, #0
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1d58:	4a0b      	ldr	r2, [pc, #44]	; (1d88 <system_gclk_gen_enable+0x34>)
    1d5a:	7853      	ldrb	r3, [r2, #1]
    1d5c:	b25b      	sxtb	r3, r3
    1d5e:	2b00      	cmp	r3, #0
    1d60:	dbfb      	blt.n	1d5a <system_gclk_gen_enable+0x6>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1d62:	4b0a      	ldr	r3, [pc, #40]	; (1d8c <system_gclk_gen_enable+0x38>)
    1d64:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    1d66:	4b0a      	ldr	r3, [pc, #40]	; (1d90 <system_gclk_gen_enable+0x3c>)
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1d68:	4907      	ldr	r1, [pc, #28]	; (1d88 <system_gclk_gen_enable+0x34>)
	};

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    1d6a:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1d6c:	784b      	ldrb	r3, [r1, #1]
    1d6e:	4a06      	ldr	r2, [pc, #24]	; (1d88 <system_gclk_gen_enable+0x34>)
    1d70:	b25b      	sxtb	r3, r3
    1d72:	2b00      	cmp	r3, #0
    1d74:	dbfa      	blt.n	1d6c <system_gclk_gen_enable+0x18>
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
    1d76:	2180      	movs	r1, #128	; 0x80
    1d78:	6853      	ldr	r3, [r2, #4]
    1d7a:	0249      	lsls	r1, r1, #9
    1d7c:	430b      	orrs	r3, r1
    1d7e:	6053      	str	r3, [r2, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1d80:	4b04      	ldr	r3, [pc, #16]	; (1d94 <system_gclk_gen_enable+0x40>)
    1d82:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    1d84:	bd10      	pop	{r4, pc}
    1d86:	46c0      	nop			; (mov r8, r8)
    1d88:	40000c00 	.word	0x40000c00
    1d8c:	00001899 	.word	0x00001899
    1d90:	40000c04 	.word	0x40000c04
    1d94:	000018d5 	.word	0x000018d5

00001d98 <system_gclk_chan_set_config>:
 *
 */
void system_gclk_chan_set_config(
		const uint8_t channel,
		struct system_gclk_chan_config *const config)
{
    1d98:	b538      	push	{r3, r4, r5, lr}
    1d9a:	1c04      	adds	r4, r0, #0

	/* Cache the new config to reduce sync requirements */
	uint32_t new_clkctrl_config = (channel << GCLK_CLKCTRL_ID_Pos);

	/* Select the desired generic clock generator */
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
    1d9c:	780d      	ldrb	r5, [r1, #0]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1d9e:	4b11      	ldr	r3, [pc, #68]	; (1de4 <system_gclk_chan_set_config+0x4c>)
    1da0:	022d      	lsls	r5, r5, #8
    1da2:	4305      	orrs	r5, r0
    1da4:	4798      	blx	r3
		const uint8_t channel)
{
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    1da6:	4b10      	ldr	r3, [pc, #64]	; (1de8 <system_gclk_chan_set_config+0x50>)

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    1da8:	4a10      	ldr	r2, [pc, #64]	; (1dec <system_gclk_chan_set_config+0x54>)
		const uint8_t channel)
{
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    1daa:	701c      	strb	r4, [r3, #0]

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    1dac:	8850      	ldrh	r0, [r2, #2]
	GCLK->CLKCTRL.bit.GEN = 0;
    1dae:	4b10      	ldr	r3, [pc, #64]	; (1df0 <system_gclk_chan_set_config+0x58>)
    1db0:	8851      	ldrh	r1, [r2, #2]

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    1db2:	0500      	lsls	r0, r0, #20
	GCLK->CLKCTRL.bit.GEN = 0;
    1db4:	400b      	ands	r3, r1
    1db6:	8053      	strh	r3, [r2, #2]

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
    1db8:	8851      	ldrh	r1, [r2, #2]
    1dba:	4b0e      	ldr	r3, [pc, #56]	; (1df4 <system_gclk_chan_set_config+0x5c>)

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    1dbc:	0f00      	lsrs	r0, r0, #28
	GCLK->CLKCTRL.bit.GEN = 0;

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
    1dbe:	400b      	ands	r3, r1
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
    1dc0:	2180      	movs	r1, #128	; 0x80
	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
	GCLK->CLKCTRL.bit.GEN = 0;

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
    1dc2:	8053      	strh	r3, [r2, #2]
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
    1dc4:	01c9      	lsls	r1, r1, #7
    1dc6:	8853      	ldrh	r3, [r2, #2]
    1dc8:	4c08      	ldr	r4, [pc, #32]	; (1dec <system_gclk_chan_set_config+0x54>)
    1dca:	420b      	tst	r3, r1
    1dcc:	d1fb      	bne.n	1dc6 <system_gclk_chan_set_config+0x2e>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
    1dce:	8861      	ldrh	r1, [r4, #2]
    1dd0:	4b07      	ldr	r3, [pc, #28]	; (1df0 <system_gclk_chan_set_config+0x58>)
    1dd2:	0202      	lsls	r2, r0, #8
    1dd4:	400b      	ands	r3, r1
    1dd6:	4313      	orrs	r3, r2
    1dd8:	8063      	strh	r3, [r4, #2]

	/* Disable generic clock channel */
	system_gclk_chan_disable(channel);

	/* Write the new configuration */
	GCLK->CLKCTRL.reg = new_clkctrl_config;
    1dda:	b2ad      	uxth	r5, r5
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1ddc:	4b06      	ldr	r3, [pc, #24]	; (1df8 <system_gclk_chan_set_config+0x60>)
    1dde:	4798      	blx	r3
    1de0:	8065      	strh	r5, [r4, #2]
}
    1de2:	bd38      	pop	{r3, r4, r5, pc}
    1de4:	00001899 	.word	0x00001899
    1de8:	40000c02 	.word	0x40000c02
    1dec:	40000c00 	.word	0x40000c00
    1df0:	fffff0ff 	.word	0xfffff0ff
    1df4:	ffffbfff 	.word	0xffffbfff
    1df8:	000018d5 	.word	0x000018d5

00001dfc <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
    1dfc:	b510      	push	{r4, lr}
    1dfe:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1e00:	4b06      	ldr	r3, [pc, #24]	; (1e1c <system_gclk_chan_enable+0x20>)
    1e02:	4798      	blx	r3

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
    1e04:	2180      	movs	r1, #128	; 0x80
		const uint8_t channel)
{
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    1e06:	4b06      	ldr	r3, [pc, #24]	; (1e20 <system_gclk_chan_enable+0x24>)

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
    1e08:	4a06      	ldr	r2, [pc, #24]	; (1e24 <system_gclk_chan_enable+0x28>)
		const uint8_t channel)
{
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    1e0a:	701c      	strb	r4, [r3, #0]

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
    1e0c:	8853      	ldrh	r3, [r2, #2]
    1e0e:	01c9      	lsls	r1, r1, #7
    1e10:	430b      	orrs	r3, r1
    1e12:	8053      	strh	r3, [r2, #2]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1e14:	4b04      	ldr	r3, [pc, #16]	; (1e28 <system_gclk_chan_enable+0x2c>)
    1e16:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    1e18:	bd10      	pop	{r4, pc}
    1e1a:	46c0      	nop			; (mov r8, r8)
    1e1c:	00001899 	.word	0x00001899
    1e20:	40000c02 	.word	0x40000c02
    1e24:	40000c00 	.word	0x40000c00
    1e28:	000018d5 	.word	0x000018d5

00001e2c <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
    1e2c:	b5f0      	push	{r4, r5, r6, r7, lr}
    1e2e:	4647      	mov	r7, r8
    1e30:	1c04      	adds	r4, r0, #0
    1e32:	b480      	push	{r7}
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1e34:	4e1e      	ldr	r6, [pc, #120]	; (1eb0 <system_gclk_chan_get_hz+0x84>)
    1e36:	47b0      	blx	r6
	uint8_t gen_id;

	system_interrupt_enter_critical_section();

	/* Select the requested generic clock channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    1e38:	4b1e      	ldr	r3, [pc, #120]	; (1eb4 <system_gclk_chan_get_hz+0x88>)
    1e3a:	701c      	strb	r4, [r3, #0]
	gen_id = GCLK->CLKCTRL.bit.GEN;
    1e3c:	4c1e      	ldr	r4, [pc, #120]	; (1eb8 <system_gclk_chan_get_hz+0x8c>)
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1e3e:	4b1f      	ldr	r3, [pc, #124]	; (1ebc <system_gclk_chan_get_hz+0x90>)
    1e40:	8865      	ldrh	r5, [r4, #2]
    1e42:	4698      	mov	r8, r3
    1e44:	052d      	lsls	r5, r5, #20
    1e46:	0f2d      	lsrs	r5, r5, #28
    1e48:	4798      	blx	r3
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1e4a:	7863      	ldrb	r3, [r4, #1]
    1e4c:	b25b      	sxtb	r3, r3
    1e4e:	2b00      	cmp	r3, #0
    1e50:	dbfb      	blt.n	1e4a <system_gclk_chan_get_hz+0x1e>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1e52:	47b0      	blx	r6
	};

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    1e54:	4b1a      	ldr	r3, [pc, #104]	; (1ec0 <system_gclk_chan_get_hz+0x94>)
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1e56:	4a18      	ldr	r2, [pc, #96]	; (1eb8 <system_gclk_chan_get_hz+0x8c>)
	};

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    1e58:	701d      	strb	r5, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1e5a:	7853      	ldrb	r3, [r2, #1]
    1e5c:	4c16      	ldr	r4, [pc, #88]	; (1eb8 <system_gclk_chan_get_hz+0x8c>)
    1e5e:	b25b      	sxtb	r3, r3
    1e60:	2b00      	cmp	r3, #0
    1e62:	dbfa      	blt.n	1e5a <system_gclk_chan_get_hz+0x2e>
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);
    1e64:	6860      	ldr	r0, [r4, #4]
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
    1e66:	4b17      	ldr	r3, [pc, #92]	; (1ec4 <system_gclk_chan_get_hz+0x98>)
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);
    1e68:	04c0      	lsls	r0, r0, #19
    1e6a:	0ec0      	lsrs	r0, r0, #27
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
    1e6c:	4798      	blx	r3
    1e6e:	1c07      	adds	r7, r0, #0
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);

	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    1e70:	4b13      	ldr	r3, [pc, #76]	; (1ec0 <system_gclk_chan_get_hz+0x94>)
    1e72:	701d      	strb	r5, [r3, #0]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;
    1e74:	6866      	ldr	r6, [r4, #4]

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    1e76:	4b14      	ldr	r3, [pc, #80]	; (1ec8 <system_gclk_chan_get_hz+0x9c>)
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);

	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;
    1e78:	02f6      	lsls	r6, r6, #11
    1e7a:	0ff6      	lsrs	r6, r6, #31

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    1e7c:	701d      	strb	r5, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1e7e:	7863      	ldrb	r3, [r4, #1]
    1e80:	b25b      	sxtb	r3, r3
    1e82:	2b00      	cmp	r3, #0
    1e84:	dbfb      	blt.n	1e7e <system_gclk_chan_get_hz+0x52>
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};

	uint32_t divider = GCLK->GENDIV.bit.DIV;
    1e86:	4b0c      	ldr	r3, [pc, #48]	; (1eb8 <system_gclk_chan_get_hz+0x8c>)
    1e88:	6899      	ldr	r1, [r3, #8]
    1e8a:	0a09      	lsrs	r1, r1, #8
    1e8c:	b28c      	uxth	r4, r1
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1e8e:	47c0      	blx	r8

	system_interrupt_leave_critical_section();

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
    1e90:	2e00      	cmp	r6, #0
    1e92:	d005      	beq.n	1ea0 <system_gclk_chan_get_hz+0x74>
		gen_input_hz /= divider;
	} else if (divsel) {
		gen_input_hz >>= (divider+1);
    1e94:	1c61      	adds	r1, r4, #1
    1e96:	40cf      	lsrs	r7, r1

	system_interrupt_leave_critical_section();

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
}
    1e98:	1c38      	adds	r0, r7, #0
    1e9a:	bc04      	pop	{r2}
    1e9c:	4690      	mov	r8, r2
    1e9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uint32_t divider = GCLK->GENDIV.bit.DIV;

	system_interrupt_leave_critical_section();

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
    1ea0:	2c01      	cmp	r4, #1
    1ea2:	d9f9      	bls.n	1e98 <system_gclk_chan_get_hz+0x6c>
		gen_input_hz /= divider;
    1ea4:	1c38      	adds	r0, r7, #0
    1ea6:	1c21      	adds	r1, r4, #0
    1ea8:	4b08      	ldr	r3, [pc, #32]	; (1ecc <system_gclk_chan_get_hz+0xa0>)
    1eaa:	4798      	blx	r3
    1eac:	1c07      	adds	r7, r0, #0
    1eae:	e7f3      	b.n	1e98 <system_gclk_chan_get_hz+0x6c>
    1eb0:	00001899 	.word	0x00001899
    1eb4:	40000c02 	.word	0x40000c02
    1eb8:	40000c00 	.word	0x40000c00
    1ebc:	000018d5 	.word	0x000018d5
    1ec0:	40000c04 	.word	0x40000c04
    1ec4:	00001961 	.word	0x00001961
    1ec8:	40000c08 	.word	0x40000c08
    1ecc:	00002635 	.word	0x00002635

00001ed0 <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
    1ed0:	b570      	push	{r4, r5, r6, lr}
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    1ed2:	09c2      	lsrs	r2, r0, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    1ed4:	2300      	movs	r3, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    1ed6:	2a00      	cmp	r2, #0
    1ed8:	d104      	bne.n	1ee4 <system_pinmux_pin_set_config+0x14>
		return &(ports[port_index]->Group[group_index]);
    1eda:	4a2f      	ldr	r2, [pc, #188]	; (1f98 <system_pinmux_pin_set_config+0xc8>)
    1edc:	0943      	lsrs	r3, r0, #5
    1ede:	4694      	mov	ip, r2
    1ee0:	01db      	lsls	r3, r3, #7
    1ee2:	4463      	add	r3, ip
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
    1ee4:	221f      	movs	r2, #31
    1ee6:	4010      	ands	r0, r2
    1ee8:	3a1e      	subs	r2, #30
    1eea:	4082      	lsls	r2, r0
    1eec:	1c10      	adds	r0, r2, #0

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
    1eee:	78ca      	ldrb	r2, [r1, #3]
    1ef0:	2a00      	cmp	r2, #0
    1ef2:	d131      	bne.n	1f58 <system_pinmux_pin_set_config+0x88>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    1ef4:	780c      	ldrb	r4, [r1, #0]
    1ef6:	2c80      	cmp	r4, #128	; 0x80
    1ef8:	d047      	beq.n	1f8a <system_pinmux_pin_set_config+0xba>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
    1efa:	2280      	movs	r2, #128	; 0x80
    1efc:	0624      	lsls	r4, r4, #24
    1efe:	0252      	lsls	r2, r2, #9
    1f00:	4314      	orrs	r4, r2
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    1f02:	784a      	ldrb	r2, [r1, #1]
    1f04:	2502      	movs	r5, #2
    1f06:	1c16      	adds	r6, r2, #0
    1f08:	43ae      	bics	r6, r5
    1f0a:	d107      	bne.n	1f1c <system_pinmux_pin_set_config+0x4c>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
    1f0c:	788a      	ldrb	r2, [r1, #2]
    1f0e:	2a00      	cmp	r2, #0
    1f10:	d137      	bne.n	1f82 <system_pinmux_pin_set_config+0xb2>

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;
    1f12:	2280      	movs	r2, #128	; 0x80
    1f14:	0292      	lsls	r2, r2, #10
    1f16:	4314      	orrs	r4, r2
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
				pin_cfg |= PORT_WRCONFIG_PULLEN;
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
    1f18:	6058      	str	r0, [r3, #4]
    1f1a:	784a      	ldrb	r2, [r1, #1]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    1f1c:	3a01      	subs	r2, #1
    1f1e:	2a01      	cmp	r2, #1
    1f20:	d935      	bls.n	1f8e <system_pinmux_pin_set_config+0xbe>
    1f22:	25a0      	movs	r5, #160	; 0xa0
		port->DIRCLR.reg = pin_mask;
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    1f24:	0402      	lsls	r2, r0, #16
    1f26:	05ed      	lsls	r5, r5, #23
    1f28:	0c12      	lsrs	r2, r2, #16
    1f2a:	432a      	orrs	r2, r5
    1f2c:	25d0      	movs	r5, #208	; 0xd0

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    1f2e:	4322      	orrs	r2, r4
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    1f30:	629a      	str	r2, [r3, #40]	; 0x28
    1f32:	062d      	lsls	r5, r5, #24
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
	uint32_t upper_pin_mask = (pin_mask >> 16);
    1f34:	0c02      	lsrs	r2, r0, #16
    1f36:	432a      	orrs	r2, r5

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    1f38:	4322      	orrs	r2, r4
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    1f3a:	629a      	str	r2, [r3, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    1f3c:	78ca      	ldrb	r2, [r1, #3]
    1f3e:	2a00      	cmp	r2, #0
    1f40:	d109      	bne.n	1f56 <system_pinmux_pin_set_config+0x86>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
    1f42:	0362      	lsls	r2, r4, #13
    1f44:	d503      	bpl.n	1f4e <system_pinmux_pin_set_config+0x7e>
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
    1f46:	788a      	ldrb	r2, [r1, #2]
    1f48:	2a01      	cmp	r2, #1
    1f4a:	d023      	beq.n	1f94 <system_pinmux_pin_set_config+0xc4>
				port->OUTSET.reg = pin_mask;
			} else {
				port->OUTCLR.reg = pin_mask;
    1f4c:	6158      	str	r0, [r3, #20]
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    1f4e:	784a      	ldrb	r2, [r1, #1]
    1f50:	3a01      	subs	r2, #1
    1f52:	2a01      	cmp	r2, #1
    1f54:	d913      	bls.n	1f7e <system_pinmux_pin_set_config+0xae>
{
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask = (1UL << (gpio_pin % 32));

	_system_pinmux_config(port, pin_mask, config);
}
    1f56:	bd70      	pop	{r4, r5, r6, pc}

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    1f58:	24a0      	movs	r4, #160	; 0xa0
		port->DIRCLR.reg = pin_mask;
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    1f5a:	0402      	lsls	r2, r0, #16

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    1f5c:	05e4      	lsls	r4, r4, #23
		port->DIRCLR.reg = pin_mask;
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    1f5e:	0c12      	lsrs	r2, r2, #16

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    1f60:	4322      	orrs	r2, r4

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    1f62:	24d0      	movs	r4, #208	; 0xd0
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
		}
	} else {
		port->DIRCLR.reg = pin_mask;
    1f64:	6058      	str	r0, [r3, #4]

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    1f66:	0624      	lsls	r4, r4, #24
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    1f68:	629a      	str	r2, [r3, #40]	; 0x28
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
	uint32_t upper_pin_mask = (pin_mask >> 16);
    1f6a:	0c02      	lsrs	r2, r0, #16

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    1f6c:	4322      	orrs	r2, r4
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    1f6e:	629a      	str	r2, [r3, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    1f70:	78ca      	ldrb	r2, [r1, #3]
    1f72:	2a00      	cmp	r2, #0
    1f74:	d1ef      	bne.n	1f56 <system_pinmux_pin_set_config+0x86>
				port->OUTCLR.reg = pin_mask;
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    1f76:	784a      	ldrb	r2, [r1, #1]
    1f78:	3a01      	subs	r2, #1
    1f7a:	2a01      	cmp	r2, #1
    1f7c:	d8eb      	bhi.n	1f56 <system_pinmux_pin_set_config+0x86>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
    1f7e:	6098      	str	r0, [r3, #8]
    1f80:	e7e9      	b.n	1f56 <system_pinmux_pin_set_config+0x86>
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    1f82:	22c0      	movs	r2, #192	; 0xc0
    1f84:	02d2      	lsls	r2, r2, #11
    1f86:	4314      	orrs	r4, r2
    1f88:	e7c6      	b.n	1f18 <system_pinmux_pin_set_config+0x48>
{
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
    1f8a:	2400      	movs	r4, #0
    1f8c:	e7b9      	b.n	1f02 <system_pinmux_pin_set_config+0x32>
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Cannot use a pull-up if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
    1f8e:	4a03      	ldr	r2, [pc, #12]	; (1f9c <system_pinmux_pin_set_config+0xcc>)
    1f90:	4014      	ands	r4, r2
    1f92:	e7c6      	b.n	1f22 <system_pinmux_pin_set_config+0x52>
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
				port->OUTSET.reg = pin_mask;
    1f94:	6198      	str	r0, [r3, #24]
    1f96:	e7da      	b.n	1f4e <system_pinmux_pin_set_config+0x7e>
    1f98:	41004400 	.word	0x41004400
    1f9c:	fffbffff 	.word	0xfffbffff

00001fa0 <_system_dummy_init>:
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
	return;
}
    1fa0:	4770      	bx	lr
    1fa2:	46c0      	nop			; (mov r8, r8)

00001fa4 <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
    1fa4:	b508      	push	{r3, lr}
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
    1fa6:	4b05      	ldr	r3, [pc, #20]	; (1fbc <system_init+0x18>)
    1fa8:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
    1faa:	4b05      	ldr	r3, [pc, #20]	; (1fc0 <system_init+0x1c>)
    1fac:	4798      	blx	r3

	/* Initialize EVSYS hardware */
	_system_events_init();
    1fae:	4b05      	ldr	r3, [pc, #20]	; (1fc4 <system_init+0x20>)
    1fb0:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
    1fb2:	4b05      	ldr	r3, [pc, #20]	; (1fc8 <system_init+0x24>)
    1fb4:	4798      	blx	r3
	
	/* Initialize DIVAS hardware */
	_system_divas_init();
    1fb6:	4b05      	ldr	r3, [pc, #20]	; (1fcc <system_init+0x28>)
    1fb8:	4798      	blx	r3
}
    1fba:	bd08      	pop	{r3, pc}
    1fbc:	00001be9 	.word	0x00001be9
    1fc0:	00001905 	.word	0x00001905
    1fc4:	00001fa1 	.word	0x00001fa1
    1fc8:	00001fa1 	.word	0x00001fa1
    1fcc:	00001fa1 	.word	0x00001fa1

00001fd0 <Dummy_Handler>:
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
        while (1) {
        }
    1fd0:	e7fe      	b.n	1fd0 <Dummy_Handler>
    1fd2:	46c0      	nop			; (mov r8, r8)

00001fd4 <Reset_Handler>:

        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
    1fd4:	4925      	ldr	r1, [pc, #148]	; (206c <STACK_SIZE+0x6c>)
    1fd6:	4826      	ldr	r0, [pc, #152]	; (2070 <STACK_SIZE+0x70>)
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
    1fd8:	b570      	push	{r4, r5, r6, lr}

        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
    1fda:	4281      	cmp	r1, r0
    1fdc:	d009      	beq.n	1ff2 <Reset_Handler+0x1e>
                for (; pDest < &_erelocate;) {
    1fde:	4b25      	ldr	r3, [pc, #148]	; (2074 <STACK_SIZE+0x74>)
    1fe0:	4298      	cmp	r0, r3
    1fe2:	d206      	bcs.n	1ff2 <Reset_Handler+0x1e>
                        *pDest++ = *pSrc++;
    1fe4:	43c2      	mvns	r2, r0
    1fe6:	18d2      	adds	r2, r2, r3
    1fe8:	0892      	lsrs	r2, r2, #2
    1fea:	3201      	adds	r2, #1
    1fec:	0092      	lsls	r2, r2, #2
    1fee:	4b22      	ldr	r3, [pc, #136]	; (2078 <STACK_SIZE+0x78>)
    1ff0:	4798      	blx	r3
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    1ff2:	4822      	ldr	r0, [pc, #136]	; (207c <STACK_SIZE+0x7c>)
    1ff4:	4b22      	ldr	r3, [pc, #136]	; (2080 <STACK_SIZE+0x80>)
    1ff6:	4298      	cmp	r0, r3
    1ff8:	d207      	bcs.n	200a <STACK_SIZE+0xa>
                *pDest++ = 0;
    1ffa:	43c2      	mvns	r2, r0
    1ffc:	18d2      	adds	r2, r2, r3
    1ffe:	0892      	lsrs	r2, r2, #2
    2000:	3201      	adds	r2, #1
    2002:	0092      	lsls	r2, r2, #2
    2004:	2100      	movs	r1, #0
    2006:	4b1f      	ldr	r3, [pc, #124]	; (2084 <STACK_SIZE+0x84>)
    2008:	4798      	blx	r3
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    200a:	21ff      	movs	r1, #255	; 0xff
    200c:	4b1e      	ldr	r3, [pc, #120]	; (2088 <STACK_SIZE+0x88>)
    200e:	4a1f      	ldr	r2, [pc, #124]	; (208c <STACK_SIZE+0x8c>)
    2010:	438b      	bics	r3, r1
    2012:	6093      	str	r3, [r2, #8]

        /* Change default QOS values to have the best performance and correct USB behaviour */
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    2014:	2390      	movs	r3, #144	; 0x90
    2016:	4a1e      	ldr	r2, [pc, #120]	; (2090 <STACK_SIZE+0x90>)
    2018:	39fd      	subs	r1, #253	; 0xfd
    201a:	005b      	lsls	r3, r3, #1
#if defined(ID_USB)
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    201c:	2403      	movs	r4, #3
        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);

        /* Change default QOS values to have the best performance and correct USB behaviour */
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    201e:	50d1      	str	r1, [r2, r3]
#if defined(ID_USB)
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    2020:	2202      	movs	r2, #2
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
    2022:	260c      	movs	r6, #12
    2024:	2108      	movs	r1, #8
#endif
        DMAC->QOSCTRL.bit.DQOS = 2;
    2026:	2530      	movs	r5, #48	; 0x30
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);

        /* Change default QOS values to have the best performance and correct USB behaviour */
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
#if defined(ID_USB)
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    2028:	481a      	ldr	r0, [pc, #104]	; (2094 <STACK_SIZE+0x94>)
    202a:	78c3      	ldrb	r3, [r0, #3]
    202c:	43a3      	bics	r3, r4
    202e:	4313      	orrs	r3, r2
    2030:	70c3      	strb	r3, [r0, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
    2032:	78c3      	ldrb	r3, [r0, #3]
    2034:	43b3      	bics	r3, r6
    2036:	430b      	orrs	r3, r1
    2038:	70c3      	strb	r3, [r0, #3]
#endif
        DMAC->QOSCTRL.bit.DQOS = 2;
    203a:	4b17      	ldr	r3, [pc, #92]	; (2098 <STACK_SIZE+0x98>)
    203c:	7b98      	ldrb	r0, [r3, #14]
    203e:	43a8      	bics	r0, r5
    2040:	1c05      	adds	r5, r0, #0
    2042:	2020      	movs	r0, #32
    2044:	4328      	orrs	r0, r5
    2046:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
    2048:	7b98      	ldrb	r0, [r3, #14]
    204a:	43b0      	bics	r0, r6
    204c:	4301      	orrs	r1, r0
    204e:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
    2050:	7b99      	ldrb	r1, [r3, #14]
    2052:	43a1      	bics	r1, r4
    2054:	430a      	orrs	r2, r1
    2056:	739a      	strb	r2, [r3, #14]

        /* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */
        NVMCTRL->CTRLB.bit.MANW = 1;
    2058:	2380      	movs	r3, #128	; 0x80
    205a:	4a10      	ldr	r2, [pc, #64]	; (209c <STACK_SIZE+0x9c>)
    205c:	6851      	ldr	r1, [r2, #4]
    205e:	430b      	orrs	r3, r1
    2060:	6053      	str	r3, [r2, #4]

        /* Initialize the C library */
        __libc_init_array();
    2062:	4b0f      	ldr	r3, [pc, #60]	; (20a0 <STACK_SIZE+0xa0>)
    2064:	4798      	blx	r3

        /* Branch to main function */
        main();
    2066:	4b0f      	ldr	r3, [pc, #60]	; (20a4 <STACK_SIZE+0xa4>)
    2068:	4798      	blx	r3

        /* Infinite loop */
        while (1);
    206a:	e7fe      	b.n	206a <STACK_SIZE+0x6a>
    206c:	00003380 	.word	0x00003380
    2070:	20000000 	.word	0x20000000
    2074:	2000006c 	.word	0x2000006c
    2078:	000027f9 	.word	0x000027f9
    207c:	2000006c 	.word	0x2000006c
    2080:	20000268 	.word	0x20000268
    2084:	0000280b 	.word	0x0000280b
    2088:	00000000 	.word	0x00000000
    208c:	e000ed00 	.word	0xe000ed00
    2090:	41007000 	.word	0x41007000
    2094:	41005000 	.word	0x41005000
    2098:	41004800 	.word	0x41004800
    209c:	41004000 	.word	0x41004000
    20a0:	000027ad 	.word	0x000027ad
    20a4:	00002505 	.word	0x00002505

000020a8 <_sbrk>:
extern caddr_t _sbrk(int incr)
{
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;

	if (heap == NULL) {
    20a8:	4a04      	ldr	r2, [pc, #16]	; (20bc <_sbrk+0x14>)
    20aa:	6813      	ldr	r3, [r2, #0]
    20ac:	2b00      	cmp	r3, #0
    20ae:	d003      	beq.n	20b8 <_sbrk+0x10>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;

	heap += incr;
    20b0:	1818      	adds	r0, r3, r0
    20b2:	6010      	str	r0, [r2, #0]

	return (caddr_t) prev_heap;
}
    20b4:	1c18      	adds	r0, r3, #0
    20b6:	4770      	bx	lr
    20b8:	4b01      	ldr	r3, [pc, #4]	; (20c0 <_sbrk+0x18>)
    20ba:	e7f9      	b.n	20b0 <_sbrk+0x8>
    20bc:	20000164 	.word	0x20000164
    20c0:	20002268 	.word	0x20002268

000020c4 <_close>:
}

extern int _close(int file)
{
	return -1;
}
    20c4:	2001      	movs	r0, #1
    20c6:	4240      	negs	r0, r0
    20c8:	4770      	bx	lr
    20ca:	46c0      	nop			; (mov r8, r8)

000020cc <_fstat>:

extern int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
    20cc:	2380      	movs	r3, #128	; 0x80
    20ce:	019b      	lsls	r3, r3, #6

	return 0;
}
    20d0:	2000      	movs	r0, #0
	return -1;
}

extern int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
    20d2:	604b      	str	r3, [r1, #4]

	return 0;
}
    20d4:	4770      	bx	lr
    20d6:	46c0      	nop			; (mov r8, r8)

000020d8 <_isatty>:

extern int _isatty(int file)
{
	return 1;
}
    20d8:	2001      	movs	r0, #1
    20da:	4770      	bx	lr

000020dc <_lseek>:

extern int _lseek(int file, int ptr, int dir)
{
	return 0;
}
    20dc:	2000      	movs	r0, #0
    20de:	4770      	bx	lr

000020e0 <usart_serial_getchar>:
 * \param[out]    c       Destination for the read character.
 */
static inline void usart_serial_getchar(
		struct usart_module *const module,
		uint8_t *c)
{
    20e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    20e2:	b083      	sub	sp, #12
	uint16_t temp = 0;
    20e4:	466b      	mov	r3, sp
    20e6:	1d9c      	adds	r4, r3, #6
    20e8:	2300      	movs	r3, #0
 * \param[out]    c       Destination for the read character.
 */
static inline void usart_serial_getchar(
		struct usart_module *const module,
		uint8_t *c)
{
    20ea:	1c06      	adds	r6, r0, #0
    20ec:	1c0f      	adds	r7, r1, #0
    20ee:	4d05      	ldr	r5, [pc, #20]	; (2104 <usart_serial_getchar+0x24>)
	uint16_t temp = 0;
    20f0:	8023      	strh	r3, [r4, #0]

	while(STATUS_OK != usart_read_wait(module, &temp));
    20f2:	1c30      	adds	r0, r6, #0
    20f4:	1c21      	adds	r1, r4, #0
    20f6:	47a8      	blx	r5
    20f8:	2800      	cmp	r0, #0
    20fa:	d1fa      	bne.n	20f2 <usart_serial_getchar+0x12>

	*c = temp;
    20fc:	8823      	ldrh	r3, [r4, #0]
    20fe:	703b      	strb	r3, [r7, #0]
}
    2100:	b003      	add	sp, #12
    2102:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2104:	00000d8d 	.word	0x00000d8d

00002108 <usart_serial_putchar>:
 * \return Status code
 */
static inline enum status_code usart_serial_putchar(
		struct usart_module *const module,
		uint8_t c)
{
    2108:	b570      	push	{r4, r5, r6, lr}
    210a:	1c06      	adds	r6, r0, #0
    210c:	4d03      	ldr	r5, [pc, #12]	; (211c <usart_serial_putchar+0x14>)
    210e:	b28c      	uxth	r4, r1
	while(STATUS_OK !=usart_write_wait(module, c));
    2110:	1c30      	adds	r0, r6, #0
    2112:	1c21      	adds	r1, r4, #0
    2114:	47a8      	blx	r5
    2116:	2800      	cmp	r0, #0
    2118:	d1fa      	bne.n	2110 <usart_serial_putchar+0x8>

	return STATUS_OK;
}
    211a:	bd70      	pop	{r4, r5, r6, pc}
    211c:	00000d61 	.word	0x00000d61

00002120 <usart_read_callback>:
}

/*****  INTERRUPT HANDLERS  *****/
void usart_read_callback(struct usart_module *const usart_module)
{
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
    2120:	2300      	movs	r3, #0
	spi_set_baudrate(&spi_master_instance, SPI_BAUDRATE);
}

/*****  INTERRUPT HANDLERS  *****/
void usart_read_callback(struct usart_module *const usart_module)
{
    2122:	b510      	push	{r4, lr}
    2124:	b082      	sub	sp, #8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
    2126:	9301      	str	r3, [sp, #4]

	//sets semaphore for secondary handler task to receive
	xSemaphoreGiveFromISR( UARTsem, &xHigherPriorityTaskWoken );
    2128:	4b09      	ldr	r3, [pc, #36]	; (2150 <usart_read_callback+0x30>)
    212a:	2100      	movs	r1, #0
    212c:	6818      	ldr	r0, [r3, #0]
    212e:	aa01      	add	r2, sp, #4
    2130:	2300      	movs	r3, #0
    2132:	4c08      	ldr	r4, [pc, #32]	; (2154 <usart_read_callback+0x34>)
    2134:	47a0      	blx	r4

	portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
    2136:	9b01      	ldr	r3, [sp, #4]
    2138:	2b00      	cmp	r3, #0
    213a:	d003      	beq.n	2144 <usart_read_callback+0x24>
    213c:	2280      	movs	r2, #128	; 0x80
    213e:	4b06      	ldr	r3, [pc, #24]	; (2158 <usart_read_callback+0x38>)
    2140:	0552      	lsls	r2, r2, #21
    2142:	601a      	str	r2, [r3, #0]
	printf( "Interrupt - Semaphore generated.\r\n" );
    2144:	4b05      	ldr	r3, [pc, #20]	; (215c <usart_read_callback+0x3c>)
    2146:	4806      	ldr	r0, [pc, #24]	; (2160 <usart_read_callback+0x40>)
    2148:	4798      	blx	r3
}
    214a:	b002      	add	sp, #8
    214c:	bd10      	pop	{r4, pc}
    214e:	46c0      	nop			; (mov r8, r8)
    2150:	20000250 	.word	0x20000250
    2154:	0000074d 	.word	0x0000074d
    2158:	e000ed04 	.word	0xe000ed04
    215c:	000028dd 	.word	0x000028dd
    2160:	000032c4 	.word	0x000032c4

00002164 <dfll_setup>:
static inline void system_clock_source_dfll_get_config_defaults(
		struct system_clock_source_dfll_config *const config)
{
	Assert(config);

	config->loop_mode       = SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN;
    2164:	2300      	movs	r3, #0


/******  CONFIG FUNCTIONS  ******/
//clock config functions
void dfll_setup( void )
{
    2166:	b5f0      	push	{r4, r5, r6, r7, lr}
	config->quick_lock      = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
    2168:	2500      	movs	r5, #0
	config->chill_cycle     = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
	config->wakeup_lock     = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
	config->stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
	config->on_demand       = true;
    216a:	2601      	movs	r6, #1

	/* Open loop mode calibration value */
	config->coarse_value    = 0x1f / 4; /* Midpoint */
    216c:	2707      	movs	r7, #7
    216e:	b087      	sub	sp, #28
static inline void system_clock_source_dfll_get_config_defaults(
		struct system_clock_source_dfll_config *const config)
{
	Assert(config);

	config->loop_mode       = SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN;
    2170:	ac01      	add	r4, sp, #4
    2172:	7023      	strb	r3, [r4, #0]
	config->quick_lock      = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
    2174:	8063      	strh	r3, [r4, #2]
	config->chill_cycle     = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
    2176:	80a3      	strh	r3, [r4, #4]
	config->stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
	config->on_demand       = true;

	/* Open loop mode calibration value */
	config->coarse_value    = 0x1f / 4; /* Midpoint */
	config->fine_value      = 0xff / 4; /* Midpoint */
    2178:	333f      	adds	r3, #63	; 0x3f
    217a:	8163      	strh	r3, [r4, #10]

	/* Closed loop mode */
	config->coarse_max_step = 1;
	config->fine_max_step   = 1;
	config->multiply_factor = 6; /* Multiply 8MHz by 6 to get 48MHz */
    217c:	3b39      	subs	r3, #57	; 0x39
    217e:	8223      	strh	r3, [r4, #16]
#if (!SAMC21)
void configure_dfll_open_loop( void )
{
	struct  system_clock_source_dfll_config config_dfll;
	system_clock_source_dfll_get_config_defaults(&config_dfll);
	system_clock_source_dfll_set_config(&config_dfll);
    2180:	1c20      	adds	r0, r4, #0
    2182:	4b0e      	ldr	r3, [pc, #56]	; (21bc <dfll_setup+0x58>)
	Assert(config);

	config->loop_mode       = SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN;
	config->quick_lock      = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
	config->chill_cycle     = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
	config->wakeup_lock     = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
    2184:	71a5      	strb	r5, [r4, #6]
	config->stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
    2186:	71e5      	strb	r5, [r4, #7]
	config->on_demand       = true;
    2188:	7066      	strb	r6, [r4, #1]

	/* Open loop mode calibration value */
	config->coarse_value    = 0x1f / 4; /* Midpoint */
    218a:	7227      	strb	r7, [r4, #8]
	config->fine_value      = 0xff / 4; /* Midpoint */

	/* Closed loop mode */
	config->coarse_max_step = 1;
    218c:	7326      	strb	r6, [r4, #12]
	config->fine_max_step   = 1;
    218e:	81e6      	strh	r6, [r4, #14]
    2190:	4798      	blx	r3
{
	#if (!SAMC21)
	/* Configure the DFLL in open loop mode using default values */
	configure_dfll_open_loop();
	/* Enable the DFLL oscillator */
	enum status_code dfll_status =
    2192:	4b0b      	ldr	r3, [pc, #44]	; (21c0 <dfll_setup+0x5c>)
    2194:	2007      	movs	r0, #7
    2196:	4798      	blx	r3
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
    2198:	221e      	movs	r2, #30
    219a:	490a      	ldr	r1, [pc, #40]	; (21c4 <dfll_setup+0x60>)
	/* Change system clock to DFLL */
	struct  system_gclk_gen_config config_gclock_gen;
	system_gclk_gen_get_config_defaults(&config_gclock_gen);
	config_gclock_gen.source_clock = SYSTEM_CLOCK_SOURCE_DFLL;
	config_gclock_gen.division_factor = 1;
	system_gclk_gen_set_config(GCLK_GENERATOR_0, &config_gclock_gen);
    219c:	2000      	movs	r0, #0
    219e:	684b      	ldr	r3, [r1, #4]
    21a0:	4393      	bics	r3, r2
    21a2:	3a1a      	subs	r2, #26
    21a4:	4313      	orrs	r3, r2
    21a6:	604b      	str	r3, [r1, #4]
    21a8:	1c21      	adds	r1, r4, #0
    21aa:	4b07      	ldr	r3, [pc, #28]	; (21c8 <dfll_setup+0x64>)
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    21ac:	6066      	str	r6, [r4, #4]
	config->high_when_disabled = false;
    21ae:	7065      	strb	r5, [r4, #1]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    21b0:	7225      	strb	r5, [r4, #8]
	config->output_enable      = false;
    21b2:	7265      	strb	r5, [r4, #9]
	/* Configure flash wait states before switching to high frequency clock */
	system_flash_set_waitstates(2);
	/* Change system clock to DFLL */
	struct  system_gclk_gen_config config_gclock_gen;
	system_gclk_gen_get_config_defaults(&config_gclock_gen);
	config_gclock_gen.source_clock = SYSTEM_CLOCK_SOURCE_DFLL;
    21b4:	7027      	strb	r7, [r4, #0]
	config_gclock_gen.division_factor = 1;
	system_gclk_gen_set_config(GCLK_GENERATOR_0, &config_gclock_gen);
    21b6:	4798      	blx	r3
	#endif
}
    21b8:	b007      	add	sp, #28
    21ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
    21bc:	00001ac5 	.word	0x00001ac5
    21c0:	00001b45 	.word	0x00001b45
    21c4:	41004000 	.word	0x41004000
    21c8:	00001ca5 	.word	0x00001ca5

000021cc <configure_extosc32k>:
		/* Error enabling the clock source */
	}
}

void configure_extosc32k( void )
{
    21cc:	b500      	push	{lr}
    21ce:	b085      	sub	sp, #20
static inline void system_clock_source_xosc32k_get_config_defaults(
		struct system_clock_source_xosc32k_config *const config)
{
	Assert(config);

	config->external_clock      = SYSTEM_CLOCK_EXTERNAL_CRYSTAL;
    21d0:	2300      	movs	r3, #0
    21d2:	466a      	mov	r2, sp
    21d4:	7013      	strb	r3, [r2, #0]
	config->startup_time        = SYSTEM_XOSC32K_STARTUP_16384;
	config->auto_gain_control   = false;
    21d6:	7093      	strb	r3, [r2, #2]
	config->frequency           = 32768UL;
    21d8:	2280      	movs	r2, #128	; 0x80
    21da:	0212      	lsls	r2, r2, #8
    21dc:	9202      	str	r2, [sp, #8]
	config->enable_1khz_output  = false;
    21de:	466a      	mov	r2, sp
	config->enable_32khz_output = true;
    21e0:	4669      	mov	r1, sp

	config->external_clock      = SYSTEM_CLOCK_EXTERNAL_CRYSTAL;
	config->startup_time        = SYSTEM_XOSC32K_STARTUP_16384;
	config->auto_gain_control   = false;
	config->frequency           = 32768UL;
	config->enable_1khz_output  = false;
    21e2:	70d3      	strb	r3, [r2, #3]
	config->enable_32khz_output = true;
    21e4:	2201      	movs	r2, #1
	config->run_in_standby      = false;
    21e6:	730b      	strb	r3, [r1, #12]
	config->on_demand           = true;
	config->write_once          = false;
    21e8:	738b      	strb	r3, [r1, #14]
	struct  system_clock_source_xosc32k_config config_ext32k;
	system_clock_source_xosc32k_get_config_defaults(&config_ext32k);
	config_ext32k.startup_time = SYSTEM_XOSC32K_STARTUP_4096;
    21ea:	3303      	adds	r3, #3
    21ec:	704b      	strb	r3, [r1, #1]
	system_clock_source_xosc32k_set_config(&config_ext32k);
    21ee:	4668      	mov	r0, sp
    21f0:	4b02      	ldr	r3, [pc, #8]	; (21fc <configure_extosc32k+0x30>)
	config->external_clock      = SYSTEM_CLOCK_EXTERNAL_CRYSTAL;
	config->startup_time        = SYSTEM_XOSC32K_STARTUP_16384;
	config->auto_gain_control   = false;
	config->frequency           = 32768UL;
	config->enable_1khz_output  = false;
	config->enable_32khz_output = true;
    21f2:	710a      	strb	r2, [r1, #4]
	config->run_in_standby      = false;
	config->on_demand           = true;
    21f4:	734a      	strb	r2, [r1, #13]
    21f6:	4798      	blx	r3
}
    21f8:	b005      	add	sp, #20
    21fa:	bd00      	pop	{pc}
    21fc:	000019ed 	.word	0x000019ed

00002200 <configure_gclock_generator>:
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    2200:	2301      	movs	r3, #1
	system_clock_source_dfll_set_config(&config_dfll);
}
#endif

void configure_gclock_generator( void )
{
    2202:	b500      	push	{lr}
    2204:	b085      	sub	sp, #20
    2206:	a901      	add	r1, sp, #4
    2208:	604b      	str	r3, [r1, #4]
	config->high_when_disabled = false;
    220a:	2300      	movs	r3, #0
#if SAML21 || SAML22
	config->source_clock       = GCLK_SOURCE_OSC16M;
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
    220c:	2206      	movs	r2, #6
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
	config->high_when_disabled = false;
    220e:	704b      	strb	r3, [r1, #1]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    2210:	720b      	strb	r3, [r1, #8]
	config->output_enable      = false;
    2212:	724b      	strb	r3, [r1, #9]
	gclock_gen_conf.division_factor = 1;
	#else
	gclock_gen_conf.source_clock = SYSTEM_CLOCK_SOURCE_OSC8M;
	gclock_gen_conf.division_factor = 1;
	#endif
	system_gclk_gen_set_config(GCLK_GENERATOR_2, &gclock_gen_conf);
    2214:	2002      	movs	r0, #2
    2216:	4b04      	ldr	r3, [pc, #16]	; (2228 <configure_gclock_generator+0x28>)
#if SAML21 || SAML22
	config->source_clock       = GCLK_SOURCE_OSC16M;
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
    2218:	700a      	strb	r2, [r1, #0]
    221a:	4798      	blx	r3
	system_gclk_gen_enable(GCLK_GENERATOR_2);
    221c:	2002      	movs	r0, #2
    221e:	4b03      	ldr	r3, [pc, #12]	; (222c <configure_gclock_generator+0x2c>)
    2220:	4798      	blx	r3
}
    2222:	b005      	add	sp, #20
    2224:	bd00      	pop	{pc}
    2226:	46c0      	nop			; (mov r8, r8)
    2228:	00001ca5 	.word	0x00001ca5
    222c:	00001d55 	.word	0x00001d55

00002230 <configure_gclock_channel>:

void configure_gclock_channel( void )
{
	struct  system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = GCLK_GENERATOR_2;
    2230:	2302      	movs	r3, #2
	system_gclk_gen_set_config(GCLK_GENERATOR_2, &gclock_gen_conf);
	system_gclk_gen_enable(GCLK_GENERATOR_2);
}

void configure_gclock_channel( void )
{
    2232:	b500      	push	{lr}
    2234:	b083      	sub	sp, #12
	struct  system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = GCLK_GENERATOR_2;
    2236:	a901      	add	r1, sp, #4
    2238:	700b      	strb	r3, [r1, #0]
	#if (SAMD10) || (SAMD11)
	system_gclk_chan_set_config(TC1_GCLK_ID, &gclk_chan_conf);
	system_gclk_chan_enable(TC1_GCLK_ID);
	#else
	system_gclk_chan_set_config(TC3_GCLK_ID, &gclk_chan_conf);
    223a:	201b      	movs	r0, #27
    223c:	4b03      	ldr	r3, [pc, #12]	; (224c <configure_gclock_channel+0x1c>)
    223e:	4798      	blx	r3
	system_gclk_chan_enable(TC3_GCLK_ID);
    2240:	201b      	movs	r0, #27
    2242:	4b03      	ldr	r3, [pc, #12]	; (2250 <configure_gclock_channel+0x20>)
    2244:	4798      	blx	r3
	#endif
}
    2246:	b003      	add	sp, #12
    2248:	bd00      	pop	{pc}
    224a:	46c0      	nop			; (mov r8, r8)
    224c:	00001d99 	.word	0x00001d99
    2250:	00001dfd 	.word	0x00001dfd

00002254 <configure_usart>:
{
	/* Sanity check arguments */
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
    2254:	2380      	movs	r3, #128	; 0x80

void configure_usart(void)
{
    2256:	b530      	push	{r4, r5, lr}
    2258:	05db      	lsls	r3, r3, #23
    225a:	b091      	sub	sp, #68	; 0x44
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
	config->parity           = USART_PARITY_NONE;
    225c:	4669      	mov	r1, sp
    225e:	22ff      	movs	r2, #255	; 0xff
{
	/* Sanity check arguments */
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
    2260:	9300      	str	r3, [sp, #0]
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
    2262:	2300      	movs	r3, #0
	config->parity           = USART_PARITY_NONE;
	config->stopbits         = USART_STOPBITS_1;
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
	config->baudrate         = 9600;
	config->receiver_enable  = true;
    2264:	4668      	mov	r0, sp
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
	config->parity           = USART_PARITY_NONE;
    2266:	810a      	strh	r2, [r1, #8]
	config->stopbits         = USART_STOPBITS_1;
    2268:	728b      	strb	r3, [r1, #10]
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
    226a:	72cb      	strb	r3, [r1, #11]
	config->baudrate         = 9600;
	config->receiver_enable  = true;
    226c:	2224      	movs	r2, #36	; 0x24
    226e:	2101      	movs	r1, #1
    2270:	5481      	strb	r1, [r0, r2]
	config->transmitter_enable = true;
    2272:	3201      	adds	r2, #1
    2274:	5481      	strb	r1, [r0, r2]
	config->clock_polarity_inverted = false;
    2276:	3201      	adds	r2, #1
    2278:	5483      	strb	r3, [r0, r2]
	config->use_external_clock = false;
    227a:	3201      	adds	r2, #1
    227c:	5483      	strb	r3, [r0, r2]
	config->ext_clock_freq   = 0;
	config->mux_setting      = USART_RX_1_TX_2_XCK_3;
	config->run_in_standby   = false;
    227e:	3205      	adds	r2, #5
    2280:	5483      	strb	r3, [r0, r2]
	/* Sanity check arguments */
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
    2282:	9301      	str	r3, [sp, #4]
	config->baudrate         = 9600;
	config->receiver_enable  = true;
	config->transmitter_enable = true;
	config->clock_polarity_inverted = false;
	config->use_external_clock = false;
	config->ext_clock_freq   = 0;
    2284:	930a      	str	r3, [sp, #40]	; 0x28
	config->pinmux_pad0      = PINMUX_DEFAULT;
	config->pinmux_pad1      = PINMUX_DEFAULT;
	config->pinmux_pad2      = PINMUX_DEFAULT;
	config->pinmux_pad3      = PINMUX_DEFAULT;
#ifdef FEATURE_USART_OVER_SAMPLE
	config->sample_adjustment     = USART_SAMPLE_ADJUSTMENT_7_8_9;
    2286:	9305      	str	r3, [sp, #20]
	config->sample_rate           = USART_SAMPLE_RATE_16X_ARITHMETIC;
    2288:	8203      	strh	r3, [r0, #16]
#ifdef FEATURE_USART_START_FRAME_DECTION
	config->start_frame_detection_enable            = false;
#endif
#ifdef FEATURE_USART_IRDA
	config->encoding_format_enable                  = false;
	config->receive_pulse_length                    = 19;
    228a:	2313      	movs	r3, #19
    228c:	7683      	strb	r3, [r0, #26]
	struct usart_config config_usart;
	usart_get_config_defaults(&config_usart);
	config_usart.baudrate = USART_BAUD_RATE;
    228e:	23e1      	movs	r3, #225	; 0xe1
    2290:	025b      	lsls	r3, r3, #9
    2292:	9308      	str	r3, [sp, #32]
	config_usart.mux_setting = USART_RX_1_TX_0_XCK_1;
    2294:	2380      	movs	r3, #128	; 0x80
    2296:	035b      	lsls	r3, r3, #13
    2298:	9303      	str	r3, [sp, #12]
	config_usart.pinmux_pad0 = PINMUX_PA16C_SERCOM1_PAD0;
    229a:	4b17      	ldr	r3, [pc, #92]	; (22f8 <configure_usart+0xa4>)
	config->pinmux_pad1      = PINMUX_DEFAULT;
	config->pinmux_pad2      = PINMUX_DEFAULT;
	config->pinmux_pad3      = PINMUX_DEFAULT;
#ifdef FEATURE_USART_OVER_SAMPLE
	config->sample_adjustment     = USART_SAMPLE_ADJUSTMENT_7_8_9;
	config->sample_rate           = USART_SAMPLE_RATE_16X_ARITHMETIC;
    229c:	2200      	movs	r2, #0
    229e:	930c      	str	r3, [sp, #48]	; 0x30
	config_usart.pinmux_pad1 = PINMUX_PA17C_SERCOM1_PAD1;
    22a0:	4b16      	ldr	r3, [pc, #88]	; (22fc <configure_usart+0xa8>)
#endif
#ifdef FEATURE_USART_LIN_SLAVE
	config->lin_slave_enable      = false;
    22a2:	76c2      	strb	r2, [r0, #27]
    22a4:	930d      	str	r3, [sp, #52]	; 0x34
	config_usart.pinmux_pad2 = PINMUX_UNUSED;
    22a6:	2301      	movs	r3, #1
    22a8:	425b      	negs	r3, r3
	config->lin_header_delay = LIN_MASTER_HEADER_DELAY_0;
	config->lin_break_length = LIN_MASTER_BREAK_LENGTH_13_BIT;
#endif

#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
	config->immediate_buffer_overflow_notification  = false;
    22aa:	7602      	strb	r2, [r0, #24]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	config->start_frame_detection_enable            = false;
#endif
#ifdef FEATURE_USART_IRDA
	config->encoding_format_enable                  = false;
    22ac:	7642      	strb	r2, [r0, #25]
	config->iso7816_config.inhibit_nack             = ISO7816_INHIBIT_NACK_DISABLE;
	config->iso7816_config.successive_recv_nack     = ISO7816_SUCCESSIVE_RECV_NACK_DISABLE;
	config->iso7816_config.max_iterations           = 7;
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
	config->collision_detection_enable              = false;
    22ae:	7742      	strb	r2, [r0, #29]
    22b0:	930e      	str	r3, [sp, #56]	; 0x38
	config_usart.pinmux_pad3 = PINMUX_UNUSED;
    22b2:	930f      	str	r3, [sp, #60]	; 0x3c
	config_usart.start_frame_detection_enable = true;
	config_usart.generator_source = GCLK_GENERATOR_2;
    22b4:	2202      	movs	r2, #2
    22b6:	232d      	movs	r3, #45	; 0x2d
    22b8:	4c11      	ldr	r4, [pc, #68]	; (2300 <configure_usart+0xac>)
    22ba:	4d12      	ldr	r5, [pc, #72]	; (2304 <configure_usart+0xb0>)
	config_usart.mux_setting = USART_RX_1_TX_0_XCK_1;
	config_usart.pinmux_pad0 = PINMUX_PA16C_SERCOM1_PAD0;
	config_usart.pinmux_pad1 = PINMUX_PA17C_SERCOM1_PAD1;
	config_usart.pinmux_pad2 = PINMUX_UNUSED;
	config_usart.pinmux_pad3 = PINMUX_UNUSED;
	config_usart.start_frame_detection_enable = true;
    22bc:	7701      	strb	r1, [r0, #28]
	config_usart.generator_source = GCLK_GENERATOR_2;
    22be:	54c2      	strb	r2, [r0, r3]
	while (usart_init(&usart_instance, SERCOM1
    22c0:	1c20      	adds	r0, r4, #0
    22c2:	4911      	ldr	r1, [pc, #68]	; (2308 <configure_usart+0xb4>)
    22c4:	466a      	mov	r2, sp
    22c6:	47a8      	blx	r5
    22c8:	2800      	cmp	r0, #0
    22ca:	d1f9      	bne.n	22c0 <configure_usart+0x6c>
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    22cc:	6825      	ldr	r5, [r4, #0]

#if USART_CALLBACK_MODE == true
	/* Enable Global interrupt for module */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    22ce:	4b0f      	ldr	r3, [pc, #60]	; (230c <configure_usart+0xb8>)
    22d0:	1c28      	adds	r0, r5, #0
    22d2:	4798      	blx	r3
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    22d4:	231f      	movs	r3, #31
    22d6:	4018      	ands	r0, r3
    22d8:	3b1e      	subs	r3, #30
    22da:	4083      	lsls	r3, r0
    22dc:	1c18      	adds	r0, r3, #0
    22de:	4b0c      	ldr	r3, [pc, #48]	; (2310 <configure_usart+0xbc>)
    22e0:	6018      	str	r0, [r3, #0]
    22e2:	6822      	ldr	r2, [r4, #0]
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    22e4:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    22e6:	2b00      	cmp	r3, #0
    22e8:	d1fc      	bne.n	22e4 <configure_usart+0x90>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Enable USART module */
	usart_hw->CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    22ea:	682a      	ldr	r2, [r5, #0]
    22ec:	3302      	adds	r3, #2
    22ee:	4313      	orrs	r3, r2
    22f0:	602b      	str	r3, [r5, #0]
	, &config_usart) != STATUS_OK) {
	}
	usart_enable(&usart_instance);
}
    22f2:	b011      	add	sp, #68	; 0x44
    22f4:	bd30      	pop	{r4, r5, pc}
    22f6:	46c0      	nop			; (mov r8, r8)
    22f8:	00100002 	.word	0x00100002
    22fc:	00110002 	.word	0x00110002
    2300:	200001dc 	.word	0x200001dc
    2304:	00000a39 	.word	0x00000a39
    2308:	42000c00 	.word	0x42000c00
    230c:	0000180d 	.word	0x0000180d
    2310:	e000e100 	.word	0xe000e100

00002314 <configure_usart_callbacks>:

void configure_usart_callbacks(void)
{
    2314:	b510      	push	{r4, lr}
	usart_register_callback(&usart_instance,
    2316:	4c06      	ldr	r4, [pc, #24]	; (2330 <configure_usart_callbacks+0x1c>)
    2318:	4906      	ldr	r1, [pc, #24]	; (2334 <configure_usart_callbacks+0x20>)
    231a:	1c20      	adds	r0, r4, #0
    231c:	2205      	movs	r2, #5
    231e:	4b06      	ldr	r3, [pc, #24]	; (2338 <configure_usart_callbacks+0x24>)
    2320:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(module);

	/* Enable callback */
	module->callback_enable_mask |= (1 << callback_type);
    2322:	2231      	movs	r2, #49	; 0x31
    2324:	2320      	movs	r3, #32
    2326:	5ca1      	ldrb	r1, [r4, r2]
    2328:	430b      	orrs	r3, r1
    232a:	54a3      	strb	r3, [r4, r2]
	usart_read_callback, USART_CALLBACK_START_RECEIVED);
	usart_enable_callback(&usart_instance, USART_CALLBACK_START_RECEIVED);
}
    232c:	bd10      	pop	{r4, pc}
    232e:	46c0      	nop			; (mov r8, r8)
    2330:	200001dc 	.word	0x200001dc
    2334:	00002121 	.word	0x00002121
    2338:	00000dfd 	.word	0x00000dfd

0000233c <configure_usart_EDBG>:

void configure_usart_EDBG(void)
{
    233c:	b5f0      	push	{r4, r5, r6, r7, lr}
    233e:	b091      	sub	sp, #68	; 0x44
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
	config->parity           = USART_PARITY_NONE;
    2340:	4669      	mov	r1, sp
    2342:	22ff      	movs	r2, #255	; 0xff
{
	/* Sanity check arguments */
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
    2344:	2380      	movs	r3, #128	; 0x80
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
	config->parity           = USART_PARITY_NONE;
    2346:	810a      	strh	r2, [r1, #8]
	config->stopbits         = USART_STOPBITS_1;
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
	config->baudrate         = 9600;
	config->receiver_enable  = true;
    2348:	2401      	movs	r4, #1
    234a:	2224      	movs	r2, #36	; 0x24
{
	/* Sanity check arguments */
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
    234c:	05db      	lsls	r3, r3, #23
    234e:	9300      	str	r3, [sp, #0]
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
    2350:	2300      	movs	r3, #0
	config->parity           = USART_PARITY_NONE;
	config->stopbits         = USART_STOPBITS_1;
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
	config->baudrate         = 9600;
	config->receiver_enable  = true;
    2352:	548c      	strb	r4, [r1, r2]
	config->transmitter_enable = true;
    2354:	3201      	adds	r2, #1
    2356:	548c      	strb	r4, [r1, r2]
	config->clock_polarity_inverted = false;
    2358:	3201      	adds	r2, #1
    235a:	548b      	strb	r3, [r1, r2]
	config->use_external_clock = false;
    235c:	3201      	adds	r2, #1
    235e:	548b      	strb	r3, [r1, r2]
	config->ext_clock_freq   = 0;
	config->mux_setting      = USART_RX_1_TX_2_XCK_3;
	config->run_in_standby   = false;
    2360:	3205      	adds	r2, #5
    2362:	548b      	strb	r3, [r1, r2]

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
	config->parity           = USART_PARITY_NONE;
	config->stopbits         = USART_STOPBITS_1;
    2364:	728b      	strb	r3, [r1, #10]
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
    2366:	72cb      	strb	r3, [r1, #11]
	config->pinmux_pad1      = PINMUX_DEFAULT;
	config->pinmux_pad2      = PINMUX_DEFAULT;
	config->pinmux_pad3      = PINMUX_DEFAULT;
#ifdef FEATURE_USART_OVER_SAMPLE
	config->sample_adjustment     = USART_SAMPLE_ADJUSTMENT_7_8_9;
	config->sample_rate           = USART_SAMPLE_RATE_16X_ARITHMETIC;
    2368:	820b      	strh	r3, [r1, #16]
	/* Sanity check arguments */
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
    236a:	9301      	str	r3, [sp, #4]
	config->baudrate         = 9600;
	config->receiver_enable  = true;
	config->transmitter_enable = true;
	config->clock_polarity_inverted = false;
	config->use_external_clock = false;
	config->ext_clock_freq   = 0;
    236c:	930a      	str	r3, [sp, #40]	; 0x28
	config->pinmux_pad0      = PINMUX_DEFAULT;
	config->pinmux_pad1      = PINMUX_DEFAULT;
	config->pinmux_pad2      = PINMUX_DEFAULT;
	config->pinmux_pad3      = PINMUX_DEFAULT;
#ifdef FEATURE_USART_OVER_SAMPLE
	config->sample_adjustment     = USART_SAMPLE_ADJUSTMENT_7_8_9;
    236e:	9305      	str	r3, [sp, #20]
#ifdef FEATURE_USART_START_FRAME_DECTION
	config->start_frame_detection_enable            = false;
#endif
#ifdef FEATURE_USART_IRDA
	config->encoding_format_enable                  = false;
	config->receive_pulse_length                    = 19;
    2370:	2313      	movs	r3, #19
    2372:	768b      	strb	r3, [r1, #26]
	struct usart_config config_usart;
	usart_get_config_defaults(&config_usart);
	config_usart.baudrate = USART_BAUD_RATE;
    2374:	23e1      	movs	r3, #225	; 0xe1
    2376:	025b      	lsls	r3, r3, #9
    2378:	9308      	str	r3, [sp, #32]
	config_usart.mux_setting = EDBG_CDC_SERCOM_MUX_SETTING;
    237a:	2380      	movs	r3, #128	; 0x80
	config->pinmux_pad1      = PINMUX_DEFAULT;
	config->pinmux_pad2      = PINMUX_DEFAULT;
	config->pinmux_pad3      = PINMUX_DEFAULT;
#ifdef FEATURE_USART_OVER_SAMPLE
	config->sample_adjustment     = USART_SAMPLE_ADJUSTMENT_7_8_9;
	config->sample_rate           = USART_SAMPLE_RATE_16X_ARITHMETIC;
    237c:	2200      	movs	r2, #0
    237e:	035b      	lsls	r3, r3, #13
    2380:	9303      	str	r3, [sp, #12]
	config_usart.pinmux_pad0 = EDBG_CDC_SERCOM_PINMUX_PAD0;
    2382:	4b1d      	ldr	r3, [pc, #116]	; (23f8 <configure_usart_EDBG+0xbc>)
#endif
#ifdef FEATURE_USART_LIN_SLAVE
	config->lin_slave_enable      = false;
    2384:	76ca      	strb	r2, [r1, #27]
    2386:	930c      	str	r3, [sp, #48]	; 0x30
	config_usart.pinmux_pad1 = EDBG_CDC_SERCOM_PINMUX_PAD1;
    2388:	4b1c      	ldr	r3, [pc, #112]	; (23fc <configure_usart_EDBG+0xc0>)
	config->lin_header_delay = LIN_MASTER_HEADER_DELAY_0;
	config->lin_break_length = LIN_MASTER_BREAK_LENGTH_13_BIT;
#endif

#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
	config->immediate_buffer_overflow_notification  = false;
    238a:	760a      	strb	r2, [r1, #24]
    238c:	930d      	str	r3, [sp, #52]	; 0x34
	config_usart.pinmux_pad2 = EDBG_CDC_SERCOM_PINMUX_PAD2;
    238e:	2301      	movs	r3, #1
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	config->start_frame_detection_enable            = false;
    2390:	770a      	strb	r2, [r1, #28]
#endif
#ifdef FEATURE_USART_IRDA
	config->encoding_format_enable                  = false;
    2392:	764a      	strb	r2, [r1, #25]
	config->iso7816_config.inhibit_nack             = ISO7816_INHIBIT_NACK_DISABLE;
	config->iso7816_config.successive_recv_nack     = ISO7816_SUCCESSIVE_RECV_NACK_DISABLE;
	config->iso7816_config.max_iterations           = 7;
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
	config->collision_detection_enable              = false;
    2394:	774a      	strb	r2, [r1, #29]
	config_usart.pinmux_pad3 = EDBG_CDC_SERCOM_PINMUX_PAD3;
	config_usart.generator_source = GCLK_GENERATOR_2;
    2396:	2202      	movs	r2, #2
	usart_get_config_defaults(&config_usart);
	config_usart.baudrate = USART_BAUD_RATE;
	config_usart.mux_setting = EDBG_CDC_SERCOM_MUX_SETTING;
	config_usart.pinmux_pad0 = EDBG_CDC_SERCOM_PINMUX_PAD0;
	config_usart.pinmux_pad1 = EDBG_CDC_SERCOM_PINMUX_PAD1;
	config_usart.pinmux_pad2 = EDBG_CDC_SERCOM_PINMUX_PAD2;
    2398:	425b      	negs	r3, r3
    239a:	930e      	str	r3, [sp, #56]	; 0x38
	config_usart.pinmux_pad3 = EDBG_CDC_SERCOM_PINMUX_PAD3;
    239c:	930f      	str	r3, [sp, #60]	; 0x3c
	config_usart.generator_source = GCLK_GENERATOR_2;
    239e:	332e      	adds	r3, #46	; 0x2e
static inline void stdio_serial_init(
		struct usart_module *const module,
		usart_inst_t const hw,
		const struct usart_config *const config)
{
	stdio_base = (void *)module;
    23a0:	4d17      	ldr	r5, [pc, #92]	; (2400 <configure_usart_EDBG+0xc4>)
    23a2:	54ca      	strb	r2, [r1, r3]
    23a4:	4b17      	ldr	r3, [pc, #92]	; (2404 <configure_usart_EDBG+0xc8>)
	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
    23a6:	4a18      	ldr	r2, [pc, #96]	; (2408 <configure_usart_EDBG+0xcc>)
static inline void stdio_serial_init(
		struct usart_module *const module,
		usart_inst_t const hw,
		const struct usart_config *const config)
{
	stdio_base = (void *)module;
    23a8:	601d      	str	r5, [r3, #0]
	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
    23aa:	4b18      	ldr	r3, [pc, #96]	; (240c <configure_usart_EDBG+0xd0>)
static inline bool usart_serial_init(
		struct usart_module *const module,
		usart_inst_t const hw,
		const struct usart_config *const config)
{
	if (usart_init(module, hw, config) == STATUS_OK) {
    23ac:	4918      	ldr	r1, [pc, #96]	; (2410 <configure_usart_EDBG+0xd4>)
    23ae:	601a      	str	r2, [r3, #0]
	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
    23b0:	4a18      	ldr	r2, [pc, #96]	; (2414 <configure_usart_EDBG+0xd8>)
    23b2:	4b19      	ldr	r3, [pc, #100]	; (2418 <configure_usart_EDBG+0xdc>)
    23b4:	1c28      	adds	r0, r5, #0
    23b6:	601a      	str	r2, [r3, #0]
    23b8:	466a      	mov	r2, sp
    23ba:	4b18      	ldr	r3, [pc, #96]	; (241c <configure_usart_EDBG+0xe0>)
    23bc:	4798      	blx	r3

	usart_serial_init(module, hw, config);
# if defined(__GNUC__)
	// Specify that stdout and stdin should not be buffered.
	setbuf(stdout, NULL);
    23be:	4f18      	ldr	r7, [pc, #96]	; (2420 <configure_usart_EDBG+0xe4>)
    23c0:	4e18      	ldr	r6, [pc, #96]	; (2424 <configure_usart_EDBG+0xe8>)
    23c2:	683b      	ldr	r3, [r7, #0]
    23c4:	2100      	movs	r1, #0
    23c6:	6898      	ldr	r0, [r3, #8]
    23c8:	47b0      	blx	r6
	setbuf(stdin, NULL);
    23ca:	683b      	ldr	r3, [r7, #0]
    23cc:	2100      	movs	r1, #0
    23ce:	6858      	ldr	r0, [r3, #4]
    23d0:	47b0      	blx	r6
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    23d2:	682e      	ldr	r6, [r5, #0]

#if USART_CALLBACK_MODE == true
	/* Enable Global interrupt for module */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    23d4:	4b14      	ldr	r3, [pc, #80]	; (2428 <configure_usart_EDBG+0xec>)
    23d6:	1c30      	adds	r0, r6, #0
    23d8:	4798      	blx	r3
    23da:	231f      	movs	r3, #31
    23dc:	4018      	ands	r0, r3
    23de:	4084      	lsls	r4, r0
    23e0:	4b12      	ldr	r3, [pc, #72]	; (242c <configure_usart_EDBG+0xf0>)
    23e2:	601c      	str	r4, [r3, #0]
    23e4:	682a      	ldr	r2, [r5, #0]
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    23e6:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    23e8:	2b00      	cmp	r3, #0
    23ea:	d1fc      	bne.n	23e6 <configure_usart_EDBG+0xaa>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Enable USART module */
	usart_hw->CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    23ec:	6832      	ldr	r2, [r6, #0]
    23ee:	3302      	adds	r3, #2
    23f0:	4313      	orrs	r3, r2
    23f2:	6033      	str	r3, [r6, #0]
	
	stdio_serial_init(&usart_instance_EDBG, EDBG_CDC_MODULE, &config_usart);

	usart_enable(&usart_instance_EDBG);
}
    23f4:	b011      	add	sp, #68	; 0x44
    23f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    23f8:	00160002 	.word	0x00160002
    23fc:	00170002 	.word	0x00170002
    2400:	20000210 	.word	0x20000210
    2404:	200001ac 	.word	0x200001ac
    2408:	00002109 	.word	0x00002109
    240c:	200001a8 	.word	0x200001a8
    2410:	42001400 	.word	0x42001400
    2414:	000020e1 	.word	0x000020e1
    2418:	200001a4 	.word	0x200001a4
    241c:	00000a39 	.word	0x00000a39
    2420:	20000068 	.word	0x20000068
    2424:	000028f1 	.word	0x000028f1
    2428:	0000180d 	.word	0x0000180d
    242c:	e000e100 	.word	0xe000e100

00002430 <configure_spi_master>:
		const struct spi_slave_inst_config *const config)
{
	Assert(slave);
	Assert(config);

	slave->ss_pin          = config->ss_pin;
    2430:	2328      	movs	r3, #40	; 0x28

void configure_spi_master(void)
{
    2432:	b570      	push	{r4, r5, r6, lr}
    2434:	4e27      	ldr	r6, [pc, #156]	; (24d4 <configure_spi_master+0xa4>)
    2436:	b08e      	sub	sp, #56	; 0x38
	slave->address_enabled = config->address_enabled;
    2438:	2400      	movs	r4, #0
		const struct spi_slave_inst_config *const config)
{
	Assert(slave);
	Assert(config);

	slave->ss_pin          = config->ss_pin;
    243a:	7033      	strb	r3, [r6, #0]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
    243c:	2501      	movs	r5, #1
    243e:	466b      	mov	r3, sp

	/* Edit config to set the pin as output */
	pin_conf.direction = PORT_PIN_DIR_OUTPUT;

	/* Set config on Slave Select pin */
	port_pin_set_config(slave->ss_pin, &pin_conf);
    2440:	2028      	movs	r0, #40	; 0x28
    2442:	705d      	strb	r5, [r3, #1]
	config->powersave  = false;
    2444:	709c      	strb	r4, [r3, #2]
	/* Get default config for pin */
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Edit config to set the pin as output */
	pin_conf.direction = PORT_PIN_DIR_OUTPUT;
    2446:	701d      	strb	r5, [r3, #0]

	/* Set config on Slave Select pin */
	port_pin_set_config(slave->ss_pin, &pin_conf);
    2448:	4669      	mov	r1, sp
    244a:	4b23      	ldr	r3, [pc, #140]	; (24d8 <configure_spi_master+0xa8>)
{
	Assert(slave);
	Assert(config);

	slave->ss_pin          = config->ss_pin;
	slave->address_enabled = config->address_enabled;
    244c:	7074      	strb	r4, [r6, #1]
	slave->address         = config->address;
    244e:	70b4      	strb	r4, [r6, #2]

	/* Edit config to set the pin as output */
	pin_conf.direction = PORT_PIN_DIR_OUTPUT;

	/* Set config on Slave Select pin */
	port_pin_set_config(slave->ss_pin, &pin_conf);
    2450:	4798      	blx	r3
	port_pin_set_output_level(slave->ss_pin, true);
    2452:	7832      	ldrb	r2, [r6, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    2454:	09d3      	lsrs	r3, r2, #7
    2456:	d13a      	bne.n	24ce <configure_spi_master+0x9e>
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    2458:	201f      	movs	r0, #31
		return &(ports[port_index]->Group[group_index]);
    245a:	0951      	lsrs	r1, r2, #5
    245c:	4002      	ands	r2, r0
    245e:	1c28      	adds	r0, r5, #0
    2460:	4090      	lsls	r0, r2
    2462:	1c02      	adds	r2, r0, #0

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    2464:	481d      	ldr	r0, [pc, #116]	; (24dc <configure_spi_master+0xac>)
    2466:	01c9      	lsls	r1, r1, #7
    2468:	4684      	mov	ip, r0
    246a:	4461      	add	r1, ip
    246c:	618a      	str	r2, [r1, #24]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mode             = SPI_MODE_MASTER;
    246e:	466a      	mov	r2, sp
	config->select_slave_low_detect_enable= true;
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	config->master_slave_select_enable= false;
#  endif
	config->generator_source = GCLK_GENERATOR_0;
    2470:	4669      	mov	r1, sp
	/* Default configuration values */
	config->mode             = SPI_MODE_MASTER;
	config->data_order       = SPI_DATA_ORDER_MSB;
	config->transfer_mode    = SPI_TRANSFER_MODE_0;
	config->mux_setting      = SPI_SIGNAL_MUX_SETTING_D;
	config->character_size   = SPI_CHARACTER_SIZE_8BIT;
    2472:	7413      	strb	r3, [r2, #16]
	config->run_in_standby   = false;
    2474:	7453      	strb	r3, [r2, #17]
	config->receiver_enable  = true;
#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	config->select_slave_low_detect_enable= true;
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	config->master_slave_select_enable= false;
    2476:	7513      	strb	r3, [r2, #20]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mode             = SPI_MODE_MASTER;
    2478:	7015      	strb	r5, [r2, #0]
	config->data_order       = SPI_DATA_ORDER_MSB;
	config->transfer_mode    = SPI_TRANSFER_MODE_0;
	config->mux_setting      = SPI_SIGNAL_MUX_SETTING_D;
	config->character_size   = SPI_CHARACTER_SIZE_8BIT;
	config->run_in_standby   = false;
	config->receiver_enable  = true;
    247a:	7495      	strb	r5, [r2, #18]
#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	config->select_slave_low_detect_enable= true;
    247c:	74d5      	strb	r5, [r2, #19]
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	config->master_slave_select_enable= false;
#  endif
	config->generator_source = GCLK_GENERATOR_0;
    247e:	2224      	movs	r2, #36	; 0x24
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mode             = SPI_MODE_MASTER;
	config->data_order       = SPI_DATA_ORDER_MSB;
    2480:	9301      	str	r3, [sp, #4]
	config->select_slave_low_detect_enable= true;
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	config->master_slave_select_enable= false;
#  endif
	config->generator_source = GCLK_GENERATOR_0;
    2482:	548b      	strb	r3, [r1, r2]
	Assert(config);

	/* Default configuration values */
	config->mode             = SPI_MODE_MASTER;
	config->data_order       = SPI_DATA_ORDER_MSB;
	config->transfer_mode    = SPI_TRANSFER_MODE_0;
    2484:	9302      	str	r3, [sp, #8]
	config->master_slave_select_enable= false;
#  endif
	config->generator_source = GCLK_GENERATOR_0;

	/* Clear mode specific config */
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
    2486:	9307      	str	r3, [sp, #28]
    2488:	9308      	str	r3, [sp, #32]

	/* Master config defaults */
	config->mode_specific.master.baudrate = 100000;
    248a:	4b15      	ldr	r3, [pc, #84]	; (24e0 <configure_spi_master+0xb0>)
	/* Configure pad 2 for data out */
	config_spi_master.pinmux_pad2 = EXT1_SPI_SERCOM_PINMUX_PAD2; //PA06
	/* Configure pad 3 for SCK */
	config_spi_master.pinmux_pad3 = EXT1_SPI_SERCOM_PINMUX_PAD3; //PA07
	config_spi_master.generator_source = GCLK_GENERATOR_0;
	spi_init(&spi_master_instance, EXT1_SPI_MODULE, &config_spi_master);
    248c:	4c15      	ldr	r4, [pc, #84]	; (24e4 <configure_spi_master+0xb4>)
    248e:	9306      	str	r3, [sp, #24]
	spi_slave_inst_get_config_defaults(&slave_dev_config);
	slave_dev_config.ss_pin = PIN_PB08;
	spi_attach_slave(&slave, &slave_dev_config);
	/* Configure, initialize and enable SERCOM SPI module */
	spi_get_config_defaults(&config_spi_master);
	config_spi_master.mux_setting = EXT1_SPI_SERCOM_MUX_SETTING;
    2490:	2380      	movs	r3, #128	; 0x80
    2492:	025b      	lsls	r3, r3, #9
    2494:	9303      	str	r3, [sp, #12]
	/* Configure pad 0 for data in */
	config_spi_master.pinmux_pad0 = EXT1_SPI_SERCOM_PINMUX_PAD0;
    2496:	4b14      	ldr	r3, [pc, #80]	; (24e8 <configure_spi_master+0xb8>)
	/* Configure pad 2 for data out */
	config_spi_master.pinmux_pad2 = EXT1_SPI_SERCOM_PINMUX_PAD2; //PA06
	/* Configure pad 3 for SCK */
	config_spi_master.pinmux_pad3 = EXT1_SPI_SERCOM_PINMUX_PAD3; //PA07
	config_spi_master.generator_source = GCLK_GENERATOR_0;
	spi_init(&spi_master_instance, EXT1_SPI_MODULE, &config_spi_master);
    2498:	466a      	mov	r2, sp
	spi_attach_slave(&slave, &slave_dev_config);
	/* Configure, initialize and enable SERCOM SPI module */
	spi_get_config_defaults(&config_spi_master);
	config_spi_master.mux_setting = EXT1_SPI_SERCOM_MUX_SETTING;
	/* Configure pad 0 for data in */
	config_spi_master.pinmux_pad0 = EXT1_SPI_SERCOM_PINMUX_PAD0;
    249a:	930a      	str	r3, [sp, #40]	; 0x28
	/* Configure pad 1 as unused */
	config_spi_master.pinmux_pad1 = PINMUX_UNUSED;
    249c:	2301      	movs	r3, #1
    249e:	425b      	negs	r3, r3
    24a0:	930b      	str	r3, [sp, #44]	; 0x2c
	/* Configure pad 2 for data out */
	config_spi_master.pinmux_pad2 = EXT1_SPI_SERCOM_PINMUX_PAD2; //PA06
    24a2:	4b12      	ldr	r3, [pc, #72]	; (24ec <configure_spi_master+0xbc>)
	/* Configure pad 3 for SCK */
	config_spi_master.pinmux_pad3 = EXT1_SPI_SERCOM_PINMUX_PAD3; //PA07
	config_spi_master.generator_source = GCLK_GENERATOR_0;
	spi_init(&spi_master_instance, EXT1_SPI_MODULE, &config_spi_master);
    24a4:	1c20      	adds	r0, r4, #0
	/* Configure pad 0 for data in */
	config_spi_master.pinmux_pad0 = EXT1_SPI_SERCOM_PINMUX_PAD0;
	/* Configure pad 1 as unused */
	config_spi_master.pinmux_pad1 = PINMUX_UNUSED;
	/* Configure pad 2 for data out */
	config_spi_master.pinmux_pad2 = EXT1_SPI_SERCOM_PINMUX_PAD2; //PA06
    24a6:	930c      	str	r3, [sp, #48]	; 0x30
	/* Configure pad 3 for SCK */
	config_spi_master.pinmux_pad3 = EXT1_SPI_SERCOM_PINMUX_PAD3; //PA07
    24a8:	4b11      	ldr	r3, [pc, #68]	; (24f0 <configure_spi_master+0xc0>)
	config_spi_master.generator_source = GCLK_GENERATOR_0;
	spi_init(&spi_master_instance, EXT1_SPI_MODULE, &config_spi_master);
    24aa:	4912      	ldr	r1, [pc, #72]	; (24f4 <configure_spi_master+0xc4>)
	/* Configure pad 1 as unused */
	config_spi_master.pinmux_pad1 = PINMUX_UNUSED;
	/* Configure pad 2 for data out */
	config_spi_master.pinmux_pad2 = EXT1_SPI_SERCOM_PINMUX_PAD2; //PA06
	/* Configure pad 3 for SCK */
	config_spi_master.pinmux_pad3 = EXT1_SPI_SERCOM_PINMUX_PAD3; //PA07
    24ac:	930d      	str	r3, [sp, #52]	; 0x34
	config_spi_master.generator_source = GCLK_GENERATOR_0;
	spi_init(&spi_master_instance, EXT1_SPI_MODULE, &config_spi_master);
    24ae:	4b12      	ldr	r3, [pc, #72]	; (24f8 <configure_spi_master+0xc8>)
    24b0:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    24b2:	6822      	ldr	r2, [r4, #0]

	SercomSpi *const spi_module = &(module->hw->SPI);

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
    24b4:	69d3      	ldr	r3, [r2, #28]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#  endif

	while (spi_is_syncing(module)) {
    24b6:	2b00      	cmp	r3, #0
    24b8:	d1fc      	bne.n	24b4 <configure_spi_master+0x84>
		/* Wait until the synchronization is complete */
	}

	/* Enable SPI */
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
    24ba:	6811      	ldr	r1, [r2, #0]
    24bc:	3302      	adds	r3, #2
    24be:	430b      	orrs	r3, r1
    24c0:	6013      	str	r3, [r2, #0]
	spi_enable(&spi_master_instance);
	spi_set_baudrate(&spi_master_instance, SPI_BAUDRATE);
    24c2:	1c20      	adds	r0, r4, #0
    24c4:	490d      	ldr	r1, [pc, #52]	; (24fc <configure_spi_master+0xcc>)
    24c6:	4b0e      	ldr	r3, [pc, #56]	; (2500 <configure_spi_master+0xd0>)
    24c8:	4798      	blx	r3
}
    24ca:	b00e      	add	sp, #56	; 0x38
    24cc:	bd70      	pop	{r4, r5, r6, pc}
    24ce:	61a4      	str	r4, [r4, #24]
    24d0:	deff      	udf	#255	; 0xff
    24d2:	46c0      	nop			; (mov r8, r8)
    24d4:	20000260 	.word	0x20000260
    24d8:	0000193d 	.word	0x0000193d
    24dc:	41004400 	.word	0x41004400
    24e0:	000186a0 	.word	0x000186a0
    24e4:	20000254 	.word	0x20000254
    24e8:	00040003 	.word	0x00040003
    24ec:	00060003 	.word	0x00060003
    24f0:	00070003 	.word	0x00070003
    24f4:	42000800 	.word	0x42000800
    24f8:	00001021 	.word	0x00001021
    24fc:	01312d00 	.word	0x01312d00
    2500:	00000fa5 	.word	0x00000fa5

00002504 <main>:
	}
}

/*******      MAIN     **********/
int main ( void )
{
    2504:	b5f0      	push	{r4, r5, r6, r7, lr}
    2506:	464d      	mov	r5, r9
    2508:	465f      	mov	r7, fp
    250a:	4656      	mov	r6, sl
    250c:	4644      	mov	r4, r8
    250e:	b4f0      	push	{r4, r5, r6, r7}
 *
 * Enables global interrupts in the device to fire any enabled interrupt handlers.
 */
static inline void system_interrupt_enable_global(void)
{
	cpu_irq_enable();
    2510:	2501      	movs	r5, #1
    2512:	b083      	sub	sp, #12
	system_init();
    2514:	4b31      	ldr	r3, [pc, #196]	; (25dc <main+0xd8>)
    2516:	4798      	blx	r3
}

void extosc32k_setup( void )
{
	/* Configure the external 32KHz oscillator */
	configure_extosc32k();
    2518:	4b31      	ldr	r3, [pc, #196]	; (25e0 <main+0xdc>)
    251a:	4798      	blx	r3
	/* Enable the external 32KHz oscillator */
		enum status_code osc32k_status =
    251c:	4b31      	ldr	r3, [pc, #196]	; (25e4 <main+0xe0>)
    251e:	2005      	movs	r0, #5
    2520:	4798      	blx	r3
{
	system_init();


	extosc32k_setup();
	dfll_setup();
    2522:	4b31      	ldr	r3, [pc, #196]	; (25e8 <main+0xe4>)
    2524:	4798      	blx	r3


	configure_gclock_generator();
    2526:	4b31      	ldr	r3, [pc, #196]	; (25ec <main+0xe8>)
    2528:	4798      	blx	r3
	configure_gclock_channel();
    252a:	4b31      	ldr	r3, [pc, #196]	; (25f0 <main+0xec>)
    252c:	4798      	blx	r3


	configure_usart();
    252e:	4b31      	ldr	r3, [pc, #196]	; (25f4 <main+0xf0>)
    2530:	4798      	blx	r3
	configure_usart_EDBG();
    2532:	4b31      	ldr	r3, [pc, #196]	; (25f8 <main+0xf4>)
    2534:	4798      	blx	r3
	configure_usart_callbacks();
    2536:	4b31      	ldr	r3, [pc, #196]	; (25fc <main+0xf8>)
    2538:	4798      	blx	r3
    253a:	4b31      	ldr	r3, [pc, #196]	; (2600 <main+0xfc>)
    253c:	701d      	strb	r5, [r3, #0]
    253e:	f3bf 8f5f 	dmb	sy
    2542:	b662      	cpsie	i


	system_interrupt_enable_global();


	configure_spi_master();
    2544:	4b2f      	ldr	r3, [pc, #188]	; (2604 <main+0x100>)
    2546:	4798      	blx	r3


	printf("PROGRAM START!\r\n");
    2548:	4b2f      	ldr	r3, [pc, #188]	; (2608 <main+0x104>)
    254a:	4830      	ldr	r0, [pc, #192]	; (260c <main+0x108>)
    254c:	4798      	blx	r3

	uint16_t test_sample = fraction_of_FFF(45, 45);

	active_voices[0].v_enable = true;
	active_voices[0].v_type = TRI;
    254e:	2302      	movs	r3, #2

	printf("PROGRAM START!\r\n");

	uint16_t test_sample = fraction_of_FFF(45, 45);

	active_voices[0].v_enable = true;
    2550:	4c2f      	ldr	r4, [pc, #188]	; (2610 <main+0x10c>)
    2552:	4f30      	ldr	r7, [pc, #192]	; (2614 <main+0x110>)
	active_voices[0].v_type = TRI;
    2554:	7063      	strb	r3, [r4, #1]
	active_voices[0].v_counter = 0;
	active_voices[0].v_period = 50;
    2556:	3330      	adds	r3, #48	; 0x30
    2558:	60a3      	str	r3, [r4, #8]

	j=0;
    255a:	4b2f      	ldr	r3, [pc, #188]	; (2618 <main+0x114>)

	printf("PROGRAM START!\r\n");

	uint16_t test_sample = fraction_of_FFF(45, 45);

	active_voices[0].v_enable = true;
    255c:	7025      	strb	r5, [r4, #0]
	active_voices[0].v_type = TRI;
	active_voices[0].v_counter = 0;
	active_voices[0].v_period = 50;

	j=0;
    255e:	4699      	mov	r9, r3
    2560:	2300      	movs	r3, #0
    2562:	464a      	mov	r2, r9
    2564:	4d2d      	ldr	r5, [pc, #180]	; (261c <main+0x118>)
    2566:	46b8      	mov	r8, r7
    2568:	4f2d      	ldr	r7, [pc, #180]	; (2620 <main+0x11c>)
    256a:	6013      	str	r3, [r2, #0]
    256c:	46ab      	mov	fp, r5
    256e:	2032      	movs	r0, #50	; 0x32
    2570:	2200      	movs	r2, #0
    2572:	3332      	adds	r3, #50	; 0x32
    2574:	2100      	movs	r1, #0
    2576:	ae01      	add	r6, sp, #4
    2578:	4d2a      	ldr	r5, [pc, #168]	; (2624 <main+0x120>)
    257a:	46ba      	mov	sl, r7
    257c:	e024      	b.n	25c8 <main+0xc4>

	//SQUARE TEST
	while(1)
	{
		if(active_voices[j].v_counter <= (active_voices[j].v_period)/2)
    257e:	23c0      	movs	r3, #192	; 0xc0
		{
			sample_buffer = (uint16_t) (0xFFF >> 2);
		}
		else sample_buffer = 0;
    2580:	2100      	movs	r1, #0
	j=0;

	//SQUARE TEST
	while(1)
	{
		if(active_voices[j].v_counter <= (active_voices[j].v_period)/2)
    2582:	019b      	lsls	r3, r3, #6
    2584:	465f      	mov	r7, fp
    2586:	8039      	strh	r1, [r7, #0]

		if(active_voices[0].v_counter < active_voices[0].v_period)
		{
			active_voices[0].v_counter++;
		}
		else active_voices[0].v_counter = 0;
    2588:	2100      	movs	r1, #0
		{
			sample_buffer = (uint16_t) (0xFFF >> 2);
		}
		else sample_buffer = 0;

		if(active_voices[0].v_counter < active_voices[0].v_period)
    258a:	4282      	cmp	r2, r0
    258c:	da00      	bge.n	2590 <main+0x8c>
		{
			active_voices[0].v_counter++;
    258e:	1c51      	adds	r1, r2, #1
	uint8_t sent_bytes[2];
	int i;

	sample_to_send.u16 = (input16 & 0xFFF) | (DAC_CMD_MASK);

	sent_bytes[0] = sample_to_send.u8[1];
    2590:	0a1a      	lsrs	r2, r3, #8
    2592:	6061      	str	r1, [r4, #4]
    2594:	7032      	strb	r2, [r6, #0]
	sent_bytes[1] = sample_to_send.u8[0];
    2596:	7073      	strb	r3, [r6, #1]

	//send sample to spi peripheral
	spi_select_slave(&spi_master_instance, &slave, true);
    2598:	4641      	mov	r1, r8
    259a:	4b23      	ldr	r3, [pc, #140]	; (2628 <main+0x124>)
    259c:	2201      	movs	r2, #1
    259e:	1c28      	adds	r0, r5, #0
    25a0:	4798      	blx	r3
	spi_write_buffer_wait(&spi_master_instance, sent_bytes, 2);
    25a2:	1c31      	adds	r1, r6, #0
    25a4:	2202      	movs	r2, #2
    25a6:	1c28      	adds	r0, r5, #0
    25a8:	47d0      	blx	sl
	spi_select_slave(&spi_master_instance, &slave, false);
    25aa:	4641      	mov	r1, r8
    25ac:	2200      	movs	r2, #0
    25ae:	4b1e      	ldr	r3, [pc, #120]	; (2628 <main+0x124>)
    25b0:	1c28      	adds	r0, r5, #0
    25b2:	4798      	blx	r3
    25b4:	464b      	mov	r3, r9
    25b6:	681b      	ldr	r3, [r3, #0]
    25b8:	68a0      	ldr	r0, [r4, #8]
    25ba:	005a      	lsls	r2, r3, #1
    25bc:	18d3      	adds	r3, r2, r3
    25be:	009b      	lsls	r3, r3, #2
    25c0:	18e3      	adds	r3, r4, r3
    25c2:	6859      	ldr	r1, [r3, #4]
    25c4:	6862      	ldr	r2, [r4, #4]
    25c6:	689b      	ldr	r3, [r3, #8]
	j=0;

	//SQUARE TEST
	while(1)
	{
		if(active_voices[j].v_counter <= (active_voices[j].v_period)/2)
    25c8:	0fdf      	lsrs	r7, r3, #31
    25ca:	46bc      	mov	ip, r7
    25cc:	4463      	add	r3, ip
    25ce:	105b      	asrs	r3, r3, #1
    25d0:	428b      	cmp	r3, r1
    25d2:	dbd4      	blt.n	257e <main+0x7a>
    25d4:	4b15      	ldr	r3, [pc, #84]	; (262c <main+0x128>)
		{
			sample_buffer = (uint16_t) (0xFFF >> 2);
    25d6:	4916      	ldr	r1, [pc, #88]	; (2630 <main+0x12c>)
    25d8:	e7d4      	b.n	2584 <main+0x80>
    25da:	46c0      	nop			; (mov r8, r8)
    25dc:	00001fa5 	.word	0x00001fa5
    25e0:	000021cd 	.word	0x000021cd
    25e4:	00001b45 	.word	0x00001b45
    25e8:	00002165 	.word	0x00002165
    25ec:	00002201 	.word	0x00002201
    25f0:	00002231 	.word	0x00002231
    25f4:	00002255 	.word	0x00002255
    25f8:	0000233d 	.word	0x0000233d
    25fc:	00002315 	.word	0x00002315
    2600:	20000004 	.word	0x20000004
    2604:	00002431 	.word	0x00002431
    2608:	000028dd 	.word	0x000028dd
    260c:	000032e8 	.word	0x000032e8
    2610:	2000016c 	.word	0x2000016c
    2614:	20000260 	.word	0x20000260
    2618:	200001d4 	.word	0x200001d4
    261c:	20000168 	.word	0x20000168
    2620:	000015d9 	.word	0x000015d9
    2624:	20000254 	.word	0x20000254
    2628:	000014fd 	.word	0x000014fd
    262c:	000037fe 	.word	0x000037fe
    2630:	000003ff 	.word	0x000003ff

00002634 <__aeabi_uidiv>:
    2634:	2200      	movs	r2, #0
    2636:	0843      	lsrs	r3, r0, #1
    2638:	428b      	cmp	r3, r1
    263a:	d374      	bcc.n	2726 <__aeabi_uidiv+0xf2>
    263c:	0903      	lsrs	r3, r0, #4
    263e:	428b      	cmp	r3, r1
    2640:	d35f      	bcc.n	2702 <__aeabi_uidiv+0xce>
    2642:	0a03      	lsrs	r3, r0, #8
    2644:	428b      	cmp	r3, r1
    2646:	d344      	bcc.n	26d2 <__aeabi_uidiv+0x9e>
    2648:	0b03      	lsrs	r3, r0, #12
    264a:	428b      	cmp	r3, r1
    264c:	d328      	bcc.n	26a0 <__aeabi_uidiv+0x6c>
    264e:	0c03      	lsrs	r3, r0, #16
    2650:	428b      	cmp	r3, r1
    2652:	d30d      	bcc.n	2670 <__aeabi_uidiv+0x3c>
    2654:	22ff      	movs	r2, #255	; 0xff
    2656:	0209      	lsls	r1, r1, #8
    2658:	ba12      	rev	r2, r2
    265a:	0c03      	lsrs	r3, r0, #16
    265c:	428b      	cmp	r3, r1
    265e:	d302      	bcc.n	2666 <__aeabi_uidiv+0x32>
    2660:	1212      	asrs	r2, r2, #8
    2662:	0209      	lsls	r1, r1, #8
    2664:	d065      	beq.n	2732 <__aeabi_uidiv+0xfe>
    2666:	0b03      	lsrs	r3, r0, #12
    2668:	428b      	cmp	r3, r1
    266a:	d319      	bcc.n	26a0 <__aeabi_uidiv+0x6c>
    266c:	e000      	b.n	2670 <__aeabi_uidiv+0x3c>
    266e:	0a09      	lsrs	r1, r1, #8
    2670:	0bc3      	lsrs	r3, r0, #15
    2672:	428b      	cmp	r3, r1
    2674:	d301      	bcc.n	267a <__aeabi_uidiv+0x46>
    2676:	03cb      	lsls	r3, r1, #15
    2678:	1ac0      	subs	r0, r0, r3
    267a:	4152      	adcs	r2, r2
    267c:	0b83      	lsrs	r3, r0, #14
    267e:	428b      	cmp	r3, r1
    2680:	d301      	bcc.n	2686 <__aeabi_uidiv+0x52>
    2682:	038b      	lsls	r3, r1, #14
    2684:	1ac0      	subs	r0, r0, r3
    2686:	4152      	adcs	r2, r2
    2688:	0b43      	lsrs	r3, r0, #13
    268a:	428b      	cmp	r3, r1
    268c:	d301      	bcc.n	2692 <__aeabi_uidiv+0x5e>
    268e:	034b      	lsls	r3, r1, #13
    2690:	1ac0      	subs	r0, r0, r3
    2692:	4152      	adcs	r2, r2
    2694:	0b03      	lsrs	r3, r0, #12
    2696:	428b      	cmp	r3, r1
    2698:	d301      	bcc.n	269e <__aeabi_uidiv+0x6a>
    269a:	030b      	lsls	r3, r1, #12
    269c:	1ac0      	subs	r0, r0, r3
    269e:	4152      	adcs	r2, r2
    26a0:	0ac3      	lsrs	r3, r0, #11
    26a2:	428b      	cmp	r3, r1
    26a4:	d301      	bcc.n	26aa <__aeabi_uidiv+0x76>
    26a6:	02cb      	lsls	r3, r1, #11
    26a8:	1ac0      	subs	r0, r0, r3
    26aa:	4152      	adcs	r2, r2
    26ac:	0a83      	lsrs	r3, r0, #10
    26ae:	428b      	cmp	r3, r1
    26b0:	d301      	bcc.n	26b6 <__aeabi_uidiv+0x82>
    26b2:	028b      	lsls	r3, r1, #10
    26b4:	1ac0      	subs	r0, r0, r3
    26b6:	4152      	adcs	r2, r2
    26b8:	0a43      	lsrs	r3, r0, #9
    26ba:	428b      	cmp	r3, r1
    26bc:	d301      	bcc.n	26c2 <__aeabi_uidiv+0x8e>
    26be:	024b      	lsls	r3, r1, #9
    26c0:	1ac0      	subs	r0, r0, r3
    26c2:	4152      	adcs	r2, r2
    26c4:	0a03      	lsrs	r3, r0, #8
    26c6:	428b      	cmp	r3, r1
    26c8:	d301      	bcc.n	26ce <__aeabi_uidiv+0x9a>
    26ca:	020b      	lsls	r3, r1, #8
    26cc:	1ac0      	subs	r0, r0, r3
    26ce:	4152      	adcs	r2, r2
    26d0:	d2cd      	bcs.n	266e <__aeabi_uidiv+0x3a>
    26d2:	09c3      	lsrs	r3, r0, #7
    26d4:	428b      	cmp	r3, r1
    26d6:	d301      	bcc.n	26dc <__aeabi_uidiv+0xa8>
    26d8:	01cb      	lsls	r3, r1, #7
    26da:	1ac0      	subs	r0, r0, r3
    26dc:	4152      	adcs	r2, r2
    26de:	0983      	lsrs	r3, r0, #6
    26e0:	428b      	cmp	r3, r1
    26e2:	d301      	bcc.n	26e8 <__aeabi_uidiv+0xb4>
    26e4:	018b      	lsls	r3, r1, #6
    26e6:	1ac0      	subs	r0, r0, r3
    26e8:	4152      	adcs	r2, r2
    26ea:	0943      	lsrs	r3, r0, #5
    26ec:	428b      	cmp	r3, r1
    26ee:	d301      	bcc.n	26f4 <__aeabi_uidiv+0xc0>
    26f0:	014b      	lsls	r3, r1, #5
    26f2:	1ac0      	subs	r0, r0, r3
    26f4:	4152      	adcs	r2, r2
    26f6:	0903      	lsrs	r3, r0, #4
    26f8:	428b      	cmp	r3, r1
    26fa:	d301      	bcc.n	2700 <__aeabi_uidiv+0xcc>
    26fc:	010b      	lsls	r3, r1, #4
    26fe:	1ac0      	subs	r0, r0, r3
    2700:	4152      	adcs	r2, r2
    2702:	08c3      	lsrs	r3, r0, #3
    2704:	428b      	cmp	r3, r1
    2706:	d301      	bcc.n	270c <__aeabi_uidiv+0xd8>
    2708:	00cb      	lsls	r3, r1, #3
    270a:	1ac0      	subs	r0, r0, r3
    270c:	4152      	adcs	r2, r2
    270e:	0883      	lsrs	r3, r0, #2
    2710:	428b      	cmp	r3, r1
    2712:	d301      	bcc.n	2718 <__aeabi_uidiv+0xe4>
    2714:	008b      	lsls	r3, r1, #2
    2716:	1ac0      	subs	r0, r0, r3
    2718:	4152      	adcs	r2, r2
    271a:	0843      	lsrs	r3, r0, #1
    271c:	428b      	cmp	r3, r1
    271e:	d301      	bcc.n	2724 <__aeabi_uidiv+0xf0>
    2720:	004b      	lsls	r3, r1, #1
    2722:	1ac0      	subs	r0, r0, r3
    2724:	4152      	adcs	r2, r2
    2726:	1a41      	subs	r1, r0, r1
    2728:	d200      	bcs.n	272c <__aeabi_uidiv+0xf8>
    272a:	4601      	mov	r1, r0
    272c:	4152      	adcs	r2, r2
    272e:	4610      	mov	r0, r2
    2730:	4770      	bx	lr
    2732:	e7ff      	b.n	2734 <__aeabi_uidiv+0x100>
    2734:	b501      	push	{r0, lr}
    2736:	2000      	movs	r0, #0
    2738:	f000 f80c 	bl	2754 <__aeabi_idiv0>
    273c:	bd02      	pop	{r1, pc}
    273e:	46c0      	nop			; (mov r8, r8)

00002740 <__aeabi_uidivmod>:
    2740:	2900      	cmp	r1, #0
    2742:	d0f7      	beq.n	2734 <__aeabi_uidiv+0x100>
    2744:	b503      	push	{r0, r1, lr}
    2746:	f7ff ff75 	bl	2634 <__aeabi_uidiv>
    274a:	bc0e      	pop	{r1, r2, r3}
    274c:	4342      	muls	r2, r0
    274e:	1a89      	subs	r1, r1, r2
    2750:	4718      	bx	r3
    2752:	46c0      	nop			; (mov r8, r8)

00002754 <__aeabi_idiv0>:
    2754:	4770      	bx	lr
    2756:	46c0      	nop			; (mov r8, r8)

00002758 <__aeabi_lmul>:
    2758:	b5f0      	push	{r4, r5, r6, r7, lr}
    275a:	464f      	mov	r7, r9
    275c:	4646      	mov	r6, r8
    275e:	0405      	lsls	r5, r0, #16
    2760:	0c2d      	lsrs	r5, r5, #16
    2762:	1c2c      	adds	r4, r5, #0
    2764:	b4c0      	push	{r6, r7}
    2766:	0417      	lsls	r7, r2, #16
    2768:	0c16      	lsrs	r6, r2, #16
    276a:	0c3f      	lsrs	r7, r7, #16
    276c:	4699      	mov	r9, r3
    276e:	0c03      	lsrs	r3, r0, #16
    2770:	437c      	muls	r4, r7
    2772:	4375      	muls	r5, r6
    2774:	435f      	muls	r7, r3
    2776:	4373      	muls	r3, r6
    2778:	197d      	adds	r5, r7, r5
    277a:	0c26      	lsrs	r6, r4, #16
    277c:	19ad      	adds	r5, r5, r6
    277e:	469c      	mov	ip, r3
    2780:	42af      	cmp	r7, r5
    2782:	d903      	bls.n	278c <__aeabi_lmul+0x34>
    2784:	2380      	movs	r3, #128	; 0x80
    2786:	025b      	lsls	r3, r3, #9
    2788:	4698      	mov	r8, r3
    278a:	44c4      	add	ip, r8
    278c:	464b      	mov	r3, r9
    278e:	4351      	muls	r1, r2
    2790:	4343      	muls	r3, r0
    2792:	0424      	lsls	r4, r4, #16
    2794:	0c2e      	lsrs	r6, r5, #16
    2796:	0c24      	lsrs	r4, r4, #16
    2798:	042d      	lsls	r5, r5, #16
    279a:	4466      	add	r6, ip
    279c:	192c      	adds	r4, r5, r4
    279e:	1859      	adds	r1, r3, r1
    27a0:	1989      	adds	r1, r1, r6
    27a2:	1c20      	adds	r0, r4, #0
    27a4:	bc0c      	pop	{r2, r3}
    27a6:	4690      	mov	r8, r2
    27a8:	4699      	mov	r9, r3
    27aa:	bdf0      	pop	{r4, r5, r6, r7, pc}

000027ac <__libc_init_array>:
    27ac:	4b0e      	ldr	r3, [pc, #56]	; (27e8 <__libc_init_array+0x3c>)
    27ae:	b570      	push	{r4, r5, r6, lr}
    27b0:	2500      	movs	r5, #0
    27b2:	1c1e      	adds	r6, r3, #0
    27b4:	4c0d      	ldr	r4, [pc, #52]	; (27ec <__libc_init_array+0x40>)
    27b6:	1ae4      	subs	r4, r4, r3
    27b8:	10a4      	asrs	r4, r4, #2
    27ba:	42a5      	cmp	r5, r4
    27bc:	d004      	beq.n	27c8 <__libc_init_array+0x1c>
    27be:	00ab      	lsls	r3, r5, #2
    27c0:	58f3      	ldr	r3, [r6, r3]
    27c2:	4798      	blx	r3
    27c4:	3501      	adds	r5, #1
    27c6:	e7f8      	b.n	27ba <__libc_init_array+0xe>
    27c8:	f000 fdca 	bl	3360 <_init>
    27cc:	4b08      	ldr	r3, [pc, #32]	; (27f0 <__libc_init_array+0x44>)
    27ce:	2500      	movs	r5, #0
    27d0:	1c1e      	adds	r6, r3, #0
    27d2:	4c08      	ldr	r4, [pc, #32]	; (27f4 <__libc_init_array+0x48>)
    27d4:	1ae4      	subs	r4, r4, r3
    27d6:	10a4      	asrs	r4, r4, #2
    27d8:	42a5      	cmp	r5, r4
    27da:	d004      	beq.n	27e6 <__libc_init_array+0x3a>
    27dc:	00ab      	lsls	r3, r5, #2
    27de:	58f3      	ldr	r3, [r6, r3]
    27e0:	4798      	blx	r3
    27e2:	3501      	adds	r5, #1
    27e4:	e7f8      	b.n	27d8 <__libc_init_array+0x2c>
    27e6:	bd70      	pop	{r4, r5, r6, pc}
    27e8:	0000336c 	.word	0x0000336c
    27ec:	0000336c 	.word	0x0000336c
    27f0:	0000336c 	.word	0x0000336c
    27f4:	00003370 	.word	0x00003370

000027f8 <memcpy>:
    27f8:	2300      	movs	r3, #0
    27fa:	b510      	push	{r4, lr}
    27fc:	4293      	cmp	r3, r2
    27fe:	d003      	beq.n	2808 <memcpy+0x10>
    2800:	5ccc      	ldrb	r4, [r1, r3]
    2802:	54c4      	strb	r4, [r0, r3]
    2804:	3301      	adds	r3, #1
    2806:	e7f9      	b.n	27fc <memcpy+0x4>
    2808:	bd10      	pop	{r4, pc}

0000280a <memset>:
    280a:	1c03      	adds	r3, r0, #0
    280c:	1882      	adds	r2, r0, r2
    280e:	4293      	cmp	r3, r2
    2810:	d002      	beq.n	2818 <memset+0xe>
    2812:	7019      	strb	r1, [r3, #0]
    2814:	3301      	adds	r3, #1
    2816:	e7fa      	b.n	280e <memset+0x4>
    2818:	4770      	bx	lr

0000281a <_puts_r>:
    281a:	b570      	push	{r4, r5, r6, lr}
    281c:	1c05      	adds	r5, r0, #0
    281e:	1c0e      	adds	r6, r1, #0
    2820:	2800      	cmp	r0, #0
    2822:	d004      	beq.n	282e <_puts_r+0x14>
    2824:	6983      	ldr	r3, [r0, #24]
    2826:	2b00      	cmp	r3, #0
    2828:	d101      	bne.n	282e <_puts_r+0x14>
    282a:	f000 fab5 	bl	2d98 <__sinit>
    282e:	68ac      	ldr	r4, [r5, #8]
    2830:	89a3      	ldrh	r3, [r4, #12]
    2832:	071b      	lsls	r3, r3, #28
    2834:	d502      	bpl.n	283c <_puts_r+0x22>
    2836:	6923      	ldr	r3, [r4, #16]
    2838:	2b00      	cmp	r3, #0
    283a:	d119      	bne.n	2870 <_puts_r+0x56>
    283c:	1c28      	adds	r0, r5, #0
    283e:	1c21      	adds	r1, r4, #0
    2840:	f000 f93e 	bl	2ac0 <__swsetup_r>
    2844:	2800      	cmp	r0, #0
    2846:	d013      	beq.n	2870 <_puts_r+0x56>
    2848:	2001      	movs	r0, #1
    284a:	4240      	negs	r0, r0
    284c:	e045      	b.n	28da <_puts_r+0xc0>
    284e:	7831      	ldrb	r1, [r6, #0]
    2850:	2b00      	cmp	r3, #0
    2852:	da1b      	bge.n	288c <_puts_r+0x72>
    2854:	69a2      	ldr	r2, [r4, #24]
    2856:	4293      	cmp	r3, r2
    2858:	da11      	bge.n	287e <_puts_r+0x64>
    285a:	1c22      	adds	r2, r4, #0
    285c:	1c28      	adds	r0, r5, #0
    285e:	f000 f8d7 	bl	2a10 <__swbuf_r>
    2862:	3001      	adds	r0, #1
    2864:	4242      	negs	r2, r0
    2866:	4142      	adcs	r2, r0
    2868:	b2d0      	uxtb	r0, r2
    286a:	2800      	cmp	r0, #0
    286c:	d1ec      	bne.n	2848 <_puts_r+0x2e>
    286e:	3601      	adds	r6, #1
    2870:	68a3      	ldr	r3, [r4, #8]
    2872:	7832      	ldrb	r2, [r6, #0]
    2874:	3b01      	subs	r3, #1
    2876:	60a3      	str	r3, [r4, #8]
    2878:	2a00      	cmp	r2, #0
    287a:	d1e8      	bne.n	284e <_puts_r+0x34>
    287c:	e00c      	b.n	2898 <_puts_r+0x7e>
    287e:	6823      	ldr	r3, [r4, #0]
    2880:	7019      	strb	r1, [r3, #0]
    2882:	6823      	ldr	r3, [r4, #0]
    2884:	7819      	ldrb	r1, [r3, #0]
    2886:	290a      	cmp	r1, #10
    2888:	d103      	bne.n	2892 <_puts_r+0x78>
    288a:	e7e6      	b.n	285a <_puts_r+0x40>
    288c:	6823      	ldr	r3, [r4, #0]
    288e:	7019      	strb	r1, [r3, #0]
    2890:	6823      	ldr	r3, [r4, #0]
    2892:	3301      	adds	r3, #1
    2894:	6023      	str	r3, [r4, #0]
    2896:	e7ea      	b.n	286e <_puts_r+0x54>
    2898:	2b00      	cmp	r3, #0
    289a:	da17      	bge.n	28cc <_puts_r+0xb2>
    289c:	69a2      	ldr	r2, [r4, #24]
    289e:	4293      	cmp	r3, r2
    28a0:	db08      	blt.n	28b4 <_puts_r+0x9a>
    28a2:	230a      	movs	r3, #10
    28a4:	6822      	ldr	r2, [r4, #0]
    28a6:	7013      	strb	r3, [r2, #0]
    28a8:	6823      	ldr	r3, [r4, #0]
    28aa:	7819      	ldrb	r1, [r3, #0]
    28ac:	290a      	cmp	r1, #10
    28ae:	d111      	bne.n	28d4 <_puts_r+0xba>
    28b0:	1c28      	adds	r0, r5, #0
    28b2:	e001      	b.n	28b8 <_puts_r+0x9e>
    28b4:	1c28      	adds	r0, r5, #0
    28b6:	210a      	movs	r1, #10
    28b8:	1c22      	adds	r2, r4, #0
    28ba:	f000 f8a9 	bl	2a10 <__swbuf_r>
    28be:	3001      	adds	r0, #1
    28c0:	4242      	negs	r2, r0
    28c2:	4142      	adcs	r2, r0
    28c4:	b2d0      	uxtb	r0, r2
    28c6:	2800      	cmp	r0, #0
    28c8:	d006      	beq.n	28d8 <_puts_r+0xbe>
    28ca:	e7bd      	b.n	2848 <_puts_r+0x2e>
    28cc:	230a      	movs	r3, #10
    28ce:	6822      	ldr	r2, [r4, #0]
    28d0:	7013      	strb	r3, [r2, #0]
    28d2:	6823      	ldr	r3, [r4, #0]
    28d4:	3301      	adds	r3, #1
    28d6:	6023      	str	r3, [r4, #0]
    28d8:	200a      	movs	r0, #10
    28da:	bd70      	pop	{r4, r5, r6, pc}

000028dc <puts>:
    28dc:	b508      	push	{r3, lr}
    28de:	4b03      	ldr	r3, [pc, #12]	; (28ec <puts+0x10>)
    28e0:	1c01      	adds	r1, r0, #0
    28e2:	6818      	ldr	r0, [r3, #0]
    28e4:	f7ff ff99 	bl	281a <_puts_r>
    28e8:	bd08      	pop	{r3, pc}
    28ea:	46c0      	nop			; (mov r8, r8)
    28ec:	20000068 	.word	0x20000068

000028f0 <setbuf>:
    28f0:	b508      	push	{r3, lr}
    28f2:	424a      	negs	r2, r1
    28f4:	414a      	adcs	r2, r1
    28f6:	2380      	movs	r3, #128	; 0x80
    28f8:	0052      	lsls	r2, r2, #1
    28fa:	00db      	lsls	r3, r3, #3
    28fc:	f000 f802 	bl	2904 <setvbuf>
    2900:	bd08      	pop	{r3, pc}
	...

00002904 <setvbuf>:
    2904:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    2906:	1c1e      	adds	r6, r3, #0
    2908:	4b3c      	ldr	r3, [pc, #240]	; (29fc <setvbuf+0xf8>)
    290a:	1c04      	adds	r4, r0, #0
    290c:	681d      	ldr	r5, [r3, #0]
    290e:	1c0f      	adds	r7, r1, #0
    2910:	9201      	str	r2, [sp, #4]
    2912:	2d00      	cmp	r5, #0
    2914:	d005      	beq.n	2922 <setvbuf+0x1e>
    2916:	69ab      	ldr	r3, [r5, #24]
    2918:	2b00      	cmp	r3, #0
    291a:	d102      	bne.n	2922 <setvbuf+0x1e>
    291c:	1c28      	adds	r0, r5, #0
    291e:	f000 fa3b 	bl	2d98 <__sinit>
    2922:	4b37      	ldr	r3, [pc, #220]	; (2a00 <setvbuf+0xfc>)
    2924:	429c      	cmp	r4, r3
    2926:	d101      	bne.n	292c <setvbuf+0x28>
    2928:	686c      	ldr	r4, [r5, #4]
    292a:	e008      	b.n	293e <setvbuf+0x3a>
    292c:	4b35      	ldr	r3, [pc, #212]	; (2a04 <setvbuf+0x100>)
    292e:	429c      	cmp	r4, r3
    2930:	d101      	bne.n	2936 <setvbuf+0x32>
    2932:	68ac      	ldr	r4, [r5, #8]
    2934:	e003      	b.n	293e <setvbuf+0x3a>
    2936:	4b34      	ldr	r3, [pc, #208]	; (2a08 <setvbuf+0x104>)
    2938:	429c      	cmp	r4, r3
    293a:	d100      	bne.n	293e <setvbuf+0x3a>
    293c:	68ec      	ldr	r4, [r5, #12]
    293e:	9b01      	ldr	r3, [sp, #4]
    2940:	2b02      	cmp	r3, #2
    2942:	d858      	bhi.n	29f6 <setvbuf+0xf2>
    2944:	2e00      	cmp	r6, #0
    2946:	db56      	blt.n	29f6 <setvbuf+0xf2>
    2948:	1c28      	adds	r0, r5, #0
    294a:	1c21      	adds	r1, r4, #0
    294c:	f000 f9b6 	bl	2cbc <_fflush_r>
    2950:	2300      	movs	r3, #0
    2952:	6063      	str	r3, [r4, #4]
    2954:	61a3      	str	r3, [r4, #24]
    2956:	89a3      	ldrh	r3, [r4, #12]
    2958:	061b      	lsls	r3, r3, #24
    295a:	d503      	bpl.n	2964 <setvbuf+0x60>
    295c:	1c28      	adds	r0, r5, #0
    295e:	6921      	ldr	r1, [r4, #16]
    2960:	f000 fb0e 	bl	2f80 <_free_r>
    2964:	2283      	movs	r2, #131	; 0x83
    2966:	89a3      	ldrh	r3, [r4, #12]
    2968:	4393      	bics	r3, r2
    296a:	81a3      	strh	r3, [r4, #12]
    296c:	9b01      	ldr	r3, [sp, #4]
    296e:	2b02      	cmp	r3, #2
    2970:	d013      	beq.n	299a <setvbuf+0x96>
    2972:	2f00      	cmp	r7, #0
    2974:	d125      	bne.n	29c2 <setvbuf+0xbe>
    2976:	2e00      	cmp	r6, #0
    2978:	d101      	bne.n	297e <setvbuf+0x7a>
    297a:	2680      	movs	r6, #128	; 0x80
    297c:	00f6      	lsls	r6, r6, #3
    297e:	1c30      	adds	r0, r6, #0
    2980:	f000 faf4 	bl	2f6c <malloc>
    2984:	1e07      	subs	r7, r0, #0
    2986:	d118      	bne.n	29ba <setvbuf+0xb6>
    2988:	2080      	movs	r0, #128	; 0x80
    298a:	00c0      	lsls	r0, r0, #3
    298c:	f000 faee 	bl	2f6c <malloc>
    2990:	1e07      	subs	r7, r0, #0
    2992:	d110      	bne.n	29b6 <setvbuf+0xb2>
    2994:	2001      	movs	r0, #1
    2996:	4240      	negs	r0, r0
    2998:	e000      	b.n	299c <setvbuf+0x98>
    299a:	2000      	movs	r0, #0
    299c:	2202      	movs	r2, #2
    299e:	89a3      	ldrh	r3, [r4, #12]
    29a0:	4313      	orrs	r3, r2
    29a2:	81a3      	strh	r3, [r4, #12]
    29a4:	2300      	movs	r3, #0
    29a6:	60a3      	str	r3, [r4, #8]
    29a8:	1c23      	adds	r3, r4, #0
    29aa:	3347      	adds	r3, #71	; 0x47
    29ac:	6023      	str	r3, [r4, #0]
    29ae:	6123      	str	r3, [r4, #16]
    29b0:	2301      	movs	r3, #1
    29b2:	6163      	str	r3, [r4, #20]
    29b4:	e021      	b.n	29fa <setvbuf+0xf6>
    29b6:	2680      	movs	r6, #128	; 0x80
    29b8:	00f6      	lsls	r6, r6, #3
    29ba:	2280      	movs	r2, #128	; 0x80
    29bc:	89a3      	ldrh	r3, [r4, #12]
    29be:	4313      	orrs	r3, r2
    29c0:	81a3      	strh	r3, [r4, #12]
    29c2:	9b01      	ldr	r3, [sp, #4]
    29c4:	2b01      	cmp	r3, #1
    29c6:	d105      	bne.n	29d4 <setvbuf+0xd0>
    29c8:	89a3      	ldrh	r3, [r4, #12]
    29ca:	9a01      	ldr	r2, [sp, #4]
    29cc:	431a      	orrs	r2, r3
    29ce:	4273      	negs	r3, r6
    29d0:	81a2      	strh	r2, [r4, #12]
    29d2:	61a3      	str	r3, [r4, #24]
    29d4:	4b0d      	ldr	r3, [pc, #52]	; (2a0c <setvbuf+0x108>)
    29d6:	2000      	movs	r0, #0
    29d8:	62ab      	str	r3, [r5, #40]	; 0x28
    29da:	89a2      	ldrh	r2, [r4, #12]
    29dc:	6027      	str	r7, [r4, #0]
    29de:	6127      	str	r7, [r4, #16]
    29e0:	6166      	str	r6, [r4, #20]
    29e2:	0713      	lsls	r3, r2, #28
    29e4:	d509      	bpl.n	29fa <setvbuf+0xf6>
    29e6:	2303      	movs	r3, #3
    29e8:	401a      	ands	r2, r3
    29ea:	4253      	negs	r3, r2
    29ec:	4153      	adcs	r3, r2
    29ee:	425b      	negs	r3, r3
    29f0:	401e      	ands	r6, r3
    29f2:	60a6      	str	r6, [r4, #8]
    29f4:	e001      	b.n	29fa <setvbuf+0xf6>
    29f6:	2001      	movs	r0, #1
    29f8:	4240      	negs	r0, r0
    29fa:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    29fc:	20000068 	.word	0x20000068
    2a00:	00003300 	.word	0x00003300
    2a04:	00003320 	.word	0x00003320
    2a08:	00003340 	.word	0x00003340
    2a0c:	00002d15 	.word	0x00002d15

00002a10 <__swbuf_r>:
    2a10:	b570      	push	{r4, r5, r6, lr}
    2a12:	1c05      	adds	r5, r0, #0
    2a14:	1c0e      	adds	r6, r1, #0
    2a16:	1c14      	adds	r4, r2, #0
    2a18:	2800      	cmp	r0, #0
    2a1a:	d004      	beq.n	2a26 <__swbuf_r+0x16>
    2a1c:	6983      	ldr	r3, [r0, #24]
    2a1e:	2b00      	cmp	r3, #0
    2a20:	d101      	bne.n	2a26 <__swbuf_r+0x16>
    2a22:	f000 f9b9 	bl	2d98 <__sinit>
    2a26:	4b23      	ldr	r3, [pc, #140]	; (2ab4 <__swbuf_r+0xa4>)
    2a28:	429c      	cmp	r4, r3
    2a2a:	d101      	bne.n	2a30 <__swbuf_r+0x20>
    2a2c:	686c      	ldr	r4, [r5, #4]
    2a2e:	e008      	b.n	2a42 <__swbuf_r+0x32>
    2a30:	4b21      	ldr	r3, [pc, #132]	; (2ab8 <__swbuf_r+0xa8>)
    2a32:	429c      	cmp	r4, r3
    2a34:	d101      	bne.n	2a3a <__swbuf_r+0x2a>
    2a36:	68ac      	ldr	r4, [r5, #8]
    2a38:	e003      	b.n	2a42 <__swbuf_r+0x32>
    2a3a:	4b20      	ldr	r3, [pc, #128]	; (2abc <__swbuf_r+0xac>)
    2a3c:	429c      	cmp	r4, r3
    2a3e:	d100      	bne.n	2a42 <__swbuf_r+0x32>
    2a40:	68ec      	ldr	r4, [r5, #12]
    2a42:	69a3      	ldr	r3, [r4, #24]
    2a44:	60a3      	str	r3, [r4, #8]
    2a46:	89a3      	ldrh	r3, [r4, #12]
    2a48:	071b      	lsls	r3, r3, #28
    2a4a:	d50a      	bpl.n	2a62 <__swbuf_r+0x52>
    2a4c:	6923      	ldr	r3, [r4, #16]
    2a4e:	2b00      	cmp	r3, #0
    2a50:	d007      	beq.n	2a62 <__swbuf_r+0x52>
    2a52:	6823      	ldr	r3, [r4, #0]
    2a54:	6922      	ldr	r2, [r4, #16]
    2a56:	b2f6      	uxtb	r6, r6
    2a58:	1a98      	subs	r0, r3, r2
    2a5a:	6963      	ldr	r3, [r4, #20]
    2a5c:	4298      	cmp	r0, r3
    2a5e:	db0f      	blt.n	2a80 <__swbuf_r+0x70>
    2a60:	e008      	b.n	2a74 <__swbuf_r+0x64>
    2a62:	1c28      	adds	r0, r5, #0
    2a64:	1c21      	adds	r1, r4, #0
    2a66:	f000 f82b 	bl	2ac0 <__swsetup_r>
    2a6a:	2800      	cmp	r0, #0
    2a6c:	d0f1      	beq.n	2a52 <__swbuf_r+0x42>
    2a6e:	2001      	movs	r0, #1
    2a70:	4240      	negs	r0, r0
    2a72:	e01d      	b.n	2ab0 <__swbuf_r+0xa0>
    2a74:	1c28      	adds	r0, r5, #0
    2a76:	1c21      	adds	r1, r4, #0
    2a78:	f000 f920 	bl	2cbc <_fflush_r>
    2a7c:	2800      	cmp	r0, #0
    2a7e:	d1f6      	bne.n	2a6e <__swbuf_r+0x5e>
    2a80:	68a3      	ldr	r3, [r4, #8]
    2a82:	3001      	adds	r0, #1
    2a84:	3b01      	subs	r3, #1
    2a86:	60a3      	str	r3, [r4, #8]
    2a88:	6823      	ldr	r3, [r4, #0]
    2a8a:	1c5a      	adds	r2, r3, #1
    2a8c:	6022      	str	r2, [r4, #0]
    2a8e:	701e      	strb	r6, [r3, #0]
    2a90:	6963      	ldr	r3, [r4, #20]
    2a92:	4298      	cmp	r0, r3
    2a94:	d005      	beq.n	2aa2 <__swbuf_r+0x92>
    2a96:	89a3      	ldrh	r3, [r4, #12]
    2a98:	1c30      	adds	r0, r6, #0
    2a9a:	07db      	lsls	r3, r3, #31
    2a9c:	d508      	bpl.n	2ab0 <__swbuf_r+0xa0>
    2a9e:	2e0a      	cmp	r6, #10
    2aa0:	d106      	bne.n	2ab0 <__swbuf_r+0xa0>
    2aa2:	1c28      	adds	r0, r5, #0
    2aa4:	1c21      	adds	r1, r4, #0
    2aa6:	f000 f909 	bl	2cbc <_fflush_r>
    2aaa:	2800      	cmp	r0, #0
    2aac:	d1df      	bne.n	2a6e <__swbuf_r+0x5e>
    2aae:	1c30      	adds	r0, r6, #0
    2ab0:	bd70      	pop	{r4, r5, r6, pc}
    2ab2:	46c0      	nop			; (mov r8, r8)
    2ab4:	00003300 	.word	0x00003300
    2ab8:	00003320 	.word	0x00003320
    2abc:	00003340 	.word	0x00003340

00002ac0 <__swsetup_r>:
    2ac0:	4b35      	ldr	r3, [pc, #212]	; (2b98 <__swsetup_r+0xd8>)
    2ac2:	b570      	push	{r4, r5, r6, lr}
    2ac4:	681d      	ldr	r5, [r3, #0]
    2ac6:	1c06      	adds	r6, r0, #0
    2ac8:	1c0c      	adds	r4, r1, #0
    2aca:	2d00      	cmp	r5, #0
    2acc:	d005      	beq.n	2ada <__swsetup_r+0x1a>
    2ace:	69ab      	ldr	r3, [r5, #24]
    2ad0:	2b00      	cmp	r3, #0
    2ad2:	d102      	bne.n	2ada <__swsetup_r+0x1a>
    2ad4:	1c28      	adds	r0, r5, #0
    2ad6:	f000 f95f 	bl	2d98 <__sinit>
    2ada:	4b30      	ldr	r3, [pc, #192]	; (2b9c <__swsetup_r+0xdc>)
    2adc:	429c      	cmp	r4, r3
    2ade:	d101      	bne.n	2ae4 <__swsetup_r+0x24>
    2ae0:	686c      	ldr	r4, [r5, #4]
    2ae2:	e008      	b.n	2af6 <__swsetup_r+0x36>
    2ae4:	4b2e      	ldr	r3, [pc, #184]	; (2ba0 <__swsetup_r+0xe0>)
    2ae6:	429c      	cmp	r4, r3
    2ae8:	d101      	bne.n	2aee <__swsetup_r+0x2e>
    2aea:	68ac      	ldr	r4, [r5, #8]
    2aec:	e003      	b.n	2af6 <__swsetup_r+0x36>
    2aee:	4b2d      	ldr	r3, [pc, #180]	; (2ba4 <__swsetup_r+0xe4>)
    2af0:	429c      	cmp	r4, r3
    2af2:	d100      	bne.n	2af6 <__swsetup_r+0x36>
    2af4:	68ec      	ldr	r4, [r5, #12]
    2af6:	89a3      	ldrh	r3, [r4, #12]
    2af8:	b29a      	uxth	r2, r3
    2afa:	0711      	lsls	r1, r2, #28
    2afc:	d423      	bmi.n	2b46 <__swsetup_r+0x86>
    2afe:	06d1      	lsls	r1, r2, #27
    2b00:	d407      	bmi.n	2b12 <__swsetup_r+0x52>
    2b02:	2209      	movs	r2, #9
    2b04:	2001      	movs	r0, #1
    2b06:	6032      	str	r2, [r6, #0]
    2b08:	3237      	adds	r2, #55	; 0x37
    2b0a:	4313      	orrs	r3, r2
    2b0c:	81a3      	strh	r3, [r4, #12]
    2b0e:	4240      	negs	r0, r0
    2b10:	e040      	b.n	2b94 <__swsetup_r+0xd4>
    2b12:	0753      	lsls	r3, r2, #29
    2b14:	d513      	bpl.n	2b3e <__swsetup_r+0x7e>
    2b16:	6b61      	ldr	r1, [r4, #52]	; 0x34
    2b18:	2900      	cmp	r1, #0
    2b1a:	d008      	beq.n	2b2e <__swsetup_r+0x6e>
    2b1c:	1c23      	adds	r3, r4, #0
    2b1e:	3344      	adds	r3, #68	; 0x44
    2b20:	4299      	cmp	r1, r3
    2b22:	d002      	beq.n	2b2a <__swsetup_r+0x6a>
    2b24:	1c30      	adds	r0, r6, #0
    2b26:	f000 fa2b 	bl	2f80 <_free_r>
    2b2a:	2300      	movs	r3, #0
    2b2c:	6363      	str	r3, [r4, #52]	; 0x34
    2b2e:	2224      	movs	r2, #36	; 0x24
    2b30:	89a3      	ldrh	r3, [r4, #12]
    2b32:	4393      	bics	r3, r2
    2b34:	81a3      	strh	r3, [r4, #12]
    2b36:	2300      	movs	r3, #0
    2b38:	6063      	str	r3, [r4, #4]
    2b3a:	6923      	ldr	r3, [r4, #16]
    2b3c:	6023      	str	r3, [r4, #0]
    2b3e:	2208      	movs	r2, #8
    2b40:	89a3      	ldrh	r3, [r4, #12]
    2b42:	4313      	orrs	r3, r2
    2b44:	81a3      	strh	r3, [r4, #12]
    2b46:	6923      	ldr	r3, [r4, #16]
    2b48:	2b00      	cmp	r3, #0
    2b4a:	d10b      	bne.n	2b64 <__swsetup_r+0xa4>
    2b4c:	23a0      	movs	r3, #160	; 0xa0
    2b4e:	89a2      	ldrh	r2, [r4, #12]
    2b50:	009b      	lsls	r3, r3, #2
    2b52:	4013      	ands	r3, r2
    2b54:	2280      	movs	r2, #128	; 0x80
    2b56:	0092      	lsls	r2, r2, #2
    2b58:	4293      	cmp	r3, r2
    2b5a:	d003      	beq.n	2b64 <__swsetup_r+0xa4>
    2b5c:	1c30      	adds	r0, r6, #0
    2b5e:	1c21      	adds	r1, r4, #0
    2b60:	f000 f9ac 	bl	2ebc <__smakebuf_r>
    2b64:	2301      	movs	r3, #1
    2b66:	89a2      	ldrh	r2, [r4, #12]
    2b68:	4013      	ands	r3, r2
    2b6a:	d005      	beq.n	2b78 <__swsetup_r+0xb8>
    2b6c:	2300      	movs	r3, #0
    2b6e:	60a3      	str	r3, [r4, #8]
    2b70:	6963      	ldr	r3, [r4, #20]
    2b72:	425b      	negs	r3, r3
    2b74:	61a3      	str	r3, [r4, #24]
    2b76:	e003      	b.n	2b80 <__swsetup_r+0xc0>
    2b78:	0791      	lsls	r1, r2, #30
    2b7a:	d400      	bmi.n	2b7e <__swsetup_r+0xbe>
    2b7c:	6963      	ldr	r3, [r4, #20]
    2b7e:	60a3      	str	r3, [r4, #8]
    2b80:	2000      	movs	r0, #0
    2b82:	6923      	ldr	r3, [r4, #16]
    2b84:	4283      	cmp	r3, r0
    2b86:	d105      	bne.n	2b94 <__swsetup_r+0xd4>
    2b88:	0613      	lsls	r3, r2, #24
    2b8a:	d503      	bpl.n	2b94 <__swsetup_r+0xd4>
    2b8c:	2340      	movs	r3, #64	; 0x40
    2b8e:	431a      	orrs	r2, r3
    2b90:	81a2      	strh	r2, [r4, #12]
    2b92:	3801      	subs	r0, #1
    2b94:	bd70      	pop	{r4, r5, r6, pc}
    2b96:	46c0      	nop			; (mov r8, r8)
    2b98:	20000068 	.word	0x20000068
    2b9c:	00003300 	.word	0x00003300
    2ba0:	00003320 	.word	0x00003320
    2ba4:	00003340 	.word	0x00003340

00002ba8 <__sflush_r>:
    2ba8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    2baa:	898a      	ldrh	r2, [r1, #12]
    2bac:	1c05      	adds	r5, r0, #0
    2bae:	1c0c      	adds	r4, r1, #0
    2bb0:	0713      	lsls	r3, r2, #28
    2bb2:	d45e      	bmi.n	2c72 <__sflush_r+0xca>
    2bb4:	684b      	ldr	r3, [r1, #4]
    2bb6:	2b00      	cmp	r3, #0
    2bb8:	dc02      	bgt.n	2bc0 <__sflush_r+0x18>
    2bba:	6c0b      	ldr	r3, [r1, #64]	; 0x40
    2bbc:	2b00      	cmp	r3, #0
    2bbe:	dd1a      	ble.n	2bf6 <__sflush_r+0x4e>
    2bc0:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
    2bc2:	2f00      	cmp	r7, #0
    2bc4:	d017      	beq.n	2bf6 <__sflush_r+0x4e>
    2bc6:	2300      	movs	r3, #0
    2bc8:	682e      	ldr	r6, [r5, #0]
    2bca:	602b      	str	r3, [r5, #0]
    2bcc:	2380      	movs	r3, #128	; 0x80
    2bce:	015b      	lsls	r3, r3, #5
    2bd0:	401a      	ands	r2, r3
    2bd2:	d001      	beq.n	2bd8 <__sflush_r+0x30>
    2bd4:	6d62      	ldr	r2, [r4, #84]	; 0x54
    2bd6:	e015      	b.n	2c04 <__sflush_r+0x5c>
    2bd8:	1c28      	adds	r0, r5, #0
    2bda:	6a21      	ldr	r1, [r4, #32]
    2bdc:	2301      	movs	r3, #1
    2bde:	47b8      	blx	r7
    2be0:	1c02      	adds	r2, r0, #0
    2be2:	1c43      	adds	r3, r0, #1
    2be4:	d10e      	bne.n	2c04 <__sflush_r+0x5c>
    2be6:	682b      	ldr	r3, [r5, #0]
    2be8:	2b00      	cmp	r3, #0
    2bea:	d00b      	beq.n	2c04 <__sflush_r+0x5c>
    2bec:	2b1d      	cmp	r3, #29
    2bee:	d001      	beq.n	2bf4 <__sflush_r+0x4c>
    2bf0:	2b16      	cmp	r3, #22
    2bf2:	d102      	bne.n	2bfa <__sflush_r+0x52>
    2bf4:	602e      	str	r6, [r5, #0]
    2bf6:	2000      	movs	r0, #0
    2bf8:	e05e      	b.n	2cb8 <__sflush_r+0x110>
    2bfa:	2140      	movs	r1, #64	; 0x40
    2bfc:	89a3      	ldrh	r3, [r4, #12]
    2bfe:	430b      	orrs	r3, r1
    2c00:	81a3      	strh	r3, [r4, #12]
    2c02:	e059      	b.n	2cb8 <__sflush_r+0x110>
    2c04:	89a3      	ldrh	r3, [r4, #12]
    2c06:	075b      	lsls	r3, r3, #29
    2c08:	d506      	bpl.n	2c18 <__sflush_r+0x70>
    2c0a:	6863      	ldr	r3, [r4, #4]
    2c0c:	1ad2      	subs	r2, r2, r3
    2c0e:	6b63      	ldr	r3, [r4, #52]	; 0x34
    2c10:	2b00      	cmp	r3, #0
    2c12:	d001      	beq.n	2c18 <__sflush_r+0x70>
    2c14:	6c23      	ldr	r3, [r4, #64]	; 0x40
    2c16:	1ad2      	subs	r2, r2, r3
    2c18:	2300      	movs	r3, #0
    2c1a:	1c28      	adds	r0, r5, #0
    2c1c:	6a21      	ldr	r1, [r4, #32]
    2c1e:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
    2c20:	47b8      	blx	r7
    2c22:	89a3      	ldrh	r3, [r4, #12]
    2c24:	1c42      	adds	r2, r0, #1
    2c26:	d106      	bne.n	2c36 <__sflush_r+0x8e>
    2c28:	682a      	ldr	r2, [r5, #0]
    2c2a:	2a00      	cmp	r2, #0
    2c2c:	d003      	beq.n	2c36 <__sflush_r+0x8e>
    2c2e:	2a1d      	cmp	r2, #29
    2c30:	d001      	beq.n	2c36 <__sflush_r+0x8e>
    2c32:	2a16      	cmp	r2, #22
    2c34:	d119      	bne.n	2c6a <__sflush_r+0xc2>
    2c36:	2200      	movs	r2, #0
    2c38:	6062      	str	r2, [r4, #4]
    2c3a:	6922      	ldr	r2, [r4, #16]
    2c3c:	6022      	str	r2, [r4, #0]
    2c3e:	04db      	lsls	r3, r3, #19
    2c40:	d505      	bpl.n	2c4e <__sflush_r+0xa6>
    2c42:	1c43      	adds	r3, r0, #1
    2c44:	d102      	bne.n	2c4c <__sflush_r+0xa4>
    2c46:	682b      	ldr	r3, [r5, #0]
    2c48:	2b00      	cmp	r3, #0
    2c4a:	d100      	bne.n	2c4e <__sflush_r+0xa6>
    2c4c:	6560      	str	r0, [r4, #84]	; 0x54
    2c4e:	6b61      	ldr	r1, [r4, #52]	; 0x34
    2c50:	602e      	str	r6, [r5, #0]
    2c52:	2900      	cmp	r1, #0
    2c54:	d0cf      	beq.n	2bf6 <__sflush_r+0x4e>
    2c56:	1c23      	adds	r3, r4, #0
    2c58:	3344      	adds	r3, #68	; 0x44
    2c5a:	4299      	cmp	r1, r3
    2c5c:	d002      	beq.n	2c64 <__sflush_r+0xbc>
    2c5e:	1c28      	adds	r0, r5, #0
    2c60:	f000 f98e 	bl	2f80 <_free_r>
    2c64:	2000      	movs	r0, #0
    2c66:	6360      	str	r0, [r4, #52]	; 0x34
    2c68:	e026      	b.n	2cb8 <__sflush_r+0x110>
    2c6a:	2240      	movs	r2, #64	; 0x40
    2c6c:	4313      	orrs	r3, r2
    2c6e:	81a3      	strh	r3, [r4, #12]
    2c70:	e022      	b.n	2cb8 <__sflush_r+0x110>
    2c72:	690f      	ldr	r7, [r1, #16]
    2c74:	2f00      	cmp	r7, #0
    2c76:	d0be      	beq.n	2bf6 <__sflush_r+0x4e>
    2c78:	680b      	ldr	r3, [r1, #0]
    2c7a:	600f      	str	r7, [r1, #0]
    2c7c:	1bdb      	subs	r3, r3, r7
    2c7e:	9301      	str	r3, [sp, #4]
    2c80:	2300      	movs	r3, #0
    2c82:	0792      	lsls	r2, r2, #30
    2c84:	d100      	bne.n	2c88 <__sflush_r+0xe0>
    2c86:	694b      	ldr	r3, [r1, #20]
    2c88:	60a3      	str	r3, [r4, #8]
    2c8a:	9b01      	ldr	r3, [sp, #4]
    2c8c:	2b00      	cmp	r3, #0
    2c8e:	ddb2      	ble.n	2bf6 <__sflush_r+0x4e>
    2c90:	1c28      	adds	r0, r5, #0
    2c92:	6a21      	ldr	r1, [r4, #32]
    2c94:	1c3a      	adds	r2, r7, #0
    2c96:	9b01      	ldr	r3, [sp, #4]
    2c98:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    2c9a:	47b0      	blx	r6
    2c9c:	2800      	cmp	r0, #0
    2c9e:	dc06      	bgt.n	2cae <__sflush_r+0x106>
    2ca0:	2240      	movs	r2, #64	; 0x40
    2ca2:	2001      	movs	r0, #1
    2ca4:	89a3      	ldrh	r3, [r4, #12]
    2ca6:	4240      	negs	r0, r0
    2ca8:	4313      	orrs	r3, r2
    2caa:	81a3      	strh	r3, [r4, #12]
    2cac:	e004      	b.n	2cb8 <__sflush_r+0x110>
    2cae:	9b01      	ldr	r3, [sp, #4]
    2cb0:	183f      	adds	r7, r7, r0
    2cb2:	1a1b      	subs	r3, r3, r0
    2cb4:	9301      	str	r3, [sp, #4]
    2cb6:	e7e8      	b.n	2c8a <__sflush_r+0xe2>
    2cb8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

00002cbc <_fflush_r>:
    2cbc:	b538      	push	{r3, r4, r5, lr}
    2cbe:	690b      	ldr	r3, [r1, #16]
    2cc0:	1c05      	adds	r5, r0, #0
    2cc2:	1c0c      	adds	r4, r1, #0
    2cc4:	2b00      	cmp	r3, #0
    2cc6:	d101      	bne.n	2ccc <_fflush_r+0x10>
    2cc8:	2000      	movs	r0, #0
    2cca:	e01c      	b.n	2d06 <_fflush_r+0x4a>
    2ccc:	2800      	cmp	r0, #0
    2cce:	d004      	beq.n	2cda <_fflush_r+0x1e>
    2cd0:	6983      	ldr	r3, [r0, #24]
    2cd2:	2b00      	cmp	r3, #0
    2cd4:	d101      	bne.n	2cda <_fflush_r+0x1e>
    2cd6:	f000 f85f 	bl	2d98 <__sinit>
    2cda:	4b0b      	ldr	r3, [pc, #44]	; (2d08 <_fflush_r+0x4c>)
    2cdc:	429c      	cmp	r4, r3
    2cde:	d101      	bne.n	2ce4 <_fflush_r+0x28>
    2ce0:	686c      	ldr	r4, [r5, #4]
    2ce2:	e008      	b.n	2cf6 <_fflush_r+0x3a>
    2ce4:	4b09      	ldr	r3, [pc, #36]	; (2d0c <_fflush_r+0x50>)
    2ce6:	429c      	cmp	r4, r3
    2ce8:	d101      	bne.n	2cee <_fflush_r+0x32>
    2cea:	68ac      	ldr	r4, [r5, #8]
    2cec:	e003      	b.n	2cf6 <_fflush_r+0x3a>
    2cee:	4b08      	ldr	r3, [pc, #32]	; (2d10 <_fflush_r+0x54>)
    2cf0:	429c      	cmp	r4, r3
    2cf2:	d100      	bne.n	2cf6 <_fflush_r+0x3a>
    2cf4:	68ec      	ldr	r4, [r5, #12]
    2cf6:	220c      	movs	r2, #12
    2cf8:	5ea3      	ldrsh	r3, [r4, r2]
    2cfa:	2b00      	cmp	r3, #0
    2cfc:	d0e4      	beq.n	2cc8 <_fflush_r+0xc>
    2cfe:	1c28      	adds	r0, r5, #0
    2d00:	1c21      	adds	r1, r4, #0
    2d02:	f7ff ff51 	bl	2ba8 <__sflush_r>
    2d06:	bd38      	pop	{r3, r4, r5, pc}
    2d08:	00003300 	.word	0x00003300
    2d0c:	00003320 	.word	0x00003320
    2d10:	00003340 	.word	0x00003340

00002d14 <_cleanup_r>:
    2d14:	b508      	push	{r3, lr}
    2d16:	4902      	ldr	r1, [pc, #8]	; (2d20 <_cleanup_r+0xc>)
    2d18:	f000 f8ae 	bl	2e78 <_fwalk_reent>
    2d1c:	bd08      	pop	{r3, pc}
    2d1e:	46c0      	nop			; (mov r8, r8)
    2d20:	00002cbd 	.word	0x00002cbd

00002d24 <std.isra.0>:
    2d24:	2300      	movs	r3, #0
    2d26:	b510      	push	{r4, lr}
    2d28:	1c04      	adds	r4, r0, #0
    2d2a:	6003      	str	r3, [r0, #0]
    2d2c:	6043      	str	r3, [r0, #4]
    2d2e:	6083      	str	r3, [r0, #8]
    2d30:	8181      	strh	r1, [r0, #12]
    2d32:	6643      	str	r3, [r0, #100]	; 0x64
    2d34:	81c2      	strh	r2, [r0, #14]
    2d36:	6103      	str	r3, [r0, #16]
    2d38:	6143      	str	r3, [r0, #20]
    2d3a:	6183      	str	r3, [r0, #24]
    2d3c:	1c19      	adds	r1, r3, #0
    2d3e:	2208      	movs	r2, #8
    2d40:	305c      	adds	r0, #92	; 0x5c
    2d42:	f7ff fd62 	bl	280a <memset>
    2d46:	4b05      	ldr	r3, [pc, #20]	; (2d5c <std.isra.0+0x38>)
    2d48:	6224      	str	r4, [r4, #32]
    2d4a:	6263      	str	r3, [r4, #36]	; 0x24
    2d4c:	4b04      	ldr	r3, [pc, #16]	; (2d60 <std.isra.0+0x3c>)
    2d4e:	62a3      	str	r3, [r4, #40]	; 0x28
    2d50:	4b04      	ldr	r3, [pc, #16]	; (2d64 <std.isra.0+0x40>)
    2d52:	62e3      	str	r3, [r4, #44]	; 0x2c
    2d54:	4b04      	ldr	r3, [pc, #16]	; (2d68 <std.isra.0+0x44>)
    2d56:	6323      	str	r3, [r4, #48]	; 0x30
    2d58:	bd10      	pop	{r4, pc}
    2d5a:	46c0      	nop			; (mov r8, r8)
    2d5c:	000030e1 	.word	0x000030e1
    2d60:	00003109 	.word	0x00003109
    2d64:	00003141 	.word	0x00003141
    2d68:	0000316d 	.word	0x0000316d

00002d6c <__sfmoreglue>:
    2d6c:	b570      	push	{r4, r5, r6, lr}
    2d6e:	2568      	movs	r5, #104	; 0x68
    2d70:	1e4b      	subs	r3, r1, #1
    2d72:	435d      	muls	r5, r3
    2d74:	1c0e      	adds	r6, r1, #0
    2d76:	1c29      	adds	r1, r5, #0
    2d78:	3174      	adds	r1, #116	; 0x74
    2d7a:	f000 f947 	bl	300c <_malloc_r>
    2d7e:	1e04      	subs	r4, r0, #0
    2d80:	d008      	beq.n	2d94 <__sfmoreglue+0x28>
    2d82:	2100      	movs	r1, #0
    2d84:	1c2a      	adds	r2, r5, #0
    2d86:	6001      	str	r1, [r0, #0]
    2d88:	6046      	str	r6, [r0, #4]
    2d8a:	300c      	adds	r0, #12
    2d8c:	60a0      	str	r0, [r4, #8]
    2d8e:	3268      	adds	r2, #104	; 0x68
    2d90:	f7ff fd3b 	bl	280a <memset>
    2d94:	1c20      	adds	r0, r4, #0
    2d96:	bd70      	pop	{r4, r5, r6, pc}

00002d98 <__sinit>:
    2d98:	6983      	ldr	r3, [r0, #24]
    2d9a:	b513      	push	{r0, r1, r4, lr}
    2d9c:	2b00      	cmp	r3, #0
    2d9e:	d128      	bne.n	2df2 <__sinit+0x5a>
    2da0:	6483      	str	r3, [r0, #72]	; 0x48
    2da2:	64c3      	str	r3, [r0, #76]	; 0x4c
    2da4:	6503      	str	r3, [r0, #80]	; 0x50
    2da6:	4b13      	ldr	r3, [pc, #76]	; (2df4 <__sinit+0x5c>)
    2da8:	4a13      	ldr	r2, [pc, #76]	; (2df8 <__sinit+0x60>)
    2daa:	681b      	ldr	r3, [r3, #0]
    2dac:	6282      	str	r2, [r0, #40]	; 0x28
    2dae:	9301      	str	r3, [sp, #4]
    2db0:	4298      	cmp	r0, r3
    2db2:	d101      	bne.n	2db8 <__sinit+0x20>
    2db4:	2301      	movs	r3, #1
    2db6:	6183      	str	r3, [r0, #24]
    2db8:	1c04      	adds	r4, r0, #0
    2dba:	f000 f81f 	bl	2dfc <__sfp>
    2dbe:	6060      	str	r0, [r4, #4]
    2dc0:	1c20      	adds	r0, r4, #0
    2dc2:	f000 f81b 	bl	2dfc <__sfp>
    2dc6:	60a0      	str	r0, [r4, #8]
    2dc8:	1c20      	adds	r0, r4, #0
    2dca:	f000 f817 	bl	2dfc <__sfp>
    2dce:	2104      	movs	r1, #4
    2dd0:	60e0      	str	r0, [r4, #12]
    2dd2:	2200      	movs	r2, #0
    2dd4:	6860      	ldr	r0, [r4, #4]
    2dd6:	f7ff ffa5 	bl	2d24 <std.isra.0>
    2dda:	68a0      	ldr	r0, [r4, #8]
    2ddc:	2109      	movs	r1, #9
    2dde:	2201      	movs	r2, #1
    2de0:	f7ff ffa0 	bl	2d24 <std.isra.0>
    2de4:	68e0      	ldr	r0, [r4, #12]
    2de6:	2112      	movs	r1, #18
    2de8:	2202      	movs	r2, #2
    2dea:	f7ff ff9b 	bl	2d24 <std.isra.0>
    2dee:	2301      	movs	r3, #1
    2df0:	61a3      	str	r3, [r4, #24]
    2df2:	bd13      	pop	{r0, r1, r4, pc}
    2df4:	000032fc 	.word	0x000032fc
    2df8:	00002d15 	.word	0x00002d15

00002dfc <__sfp>:
    2dfc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2dfe:	4b1d      	ldr	r3, [pc, #116]	; (2e74 <__sfp+0x78>)
    2e00:	1c06      	adds	r6, r0, #0
    2e02:	681d      	ldr	r5, [r3, #0]
    2e04:	69ab      	ldr	r3, [r5, #24]
    2e06:	2b00      	cmp	r3, #0
    2e08:	d102      	bne.n	2e10 <__sfp+0x14>
    2e0a:	1c28      	adds	r0, r5, #0
    2e0c:	f7ff ffc4 	bl	2d98 <__sinit>
    2e10:	3548      	adds	r5, #72	; 0x48
    2e12:	68ac      	ldr	r4, [r5, #8]
    2e14:	686b      	ldr	r3, [r5, #4]
    2e16:	3b01      	subs	r3, #1
    2e18:	d405      	bmi.n	2e26 <__sfp+0x2a>
    2e1a:	220c      	movs	r2, #12
    2e1c:	5ea7      	ldrsh	r7, [r4, r2]
    2e1e:	2f00      	cmp	r7, #0
    2e20:	d010      	beq.n	2e44 <__sfp+0x48>
    2e22:	3468      	adds	r4, #104	; 0x68
    2e24:	e7f7      	b.n	2e16 <__sfp+0x1a>
    2e26:	682b      	ldr	r3, [r5, #0]
    2e28:	2b00      	cmp	r3, #0
    2e2a:	d106      	bne.n	2e3a <__sfp+0x3e>
    2e2c:	1c30      	adds	r0, r6, #0
    2e2e:	2104      	movs	r1, #4
    2e30:	f7ff ff9c 	bl	2d6c <__sfmoreglue>
    2e34:	6028      	str	r0, [r5, #0]
    2e36:	2800      	cmp	r0, #0
    2e38:	d001      	beq.n	2e3e <__sfp+0x42>
    2e3a:	682d      	ldr	r5, [r5, #0]
    2e3c:	e7e9      	b.n	2e12 <__sfp+0x16>
    2e3e:	230c      	movs	r3, #12
    2e40:	6033      	str	r3, [r6, #0]
    2e42:	e016      	b.n	2e72 <__sfp+0x76>
    2e44:	2301      	movs	r3, #1
    2e46:	1c20      	adds	r0, r4, #0
    2e48:	425b      	negs	r3, r3
    2e4a:	81e3      	strh	r3, [r4, #14]
    2e4c:	3302      	adds	r3, #2
    2e4e:	81a3      	strh	r3, [r4, #12]
    2e50:	6667      	str	r7, [r4, #100]	; 0x64
    2e52:	6027      	str	r7, [r4, #0]
    2e54:	60a7      	str	r7, [r4, #8]
    2e56:	6067      	str	r7, [r4, #4]
    2e58:	6127      	str	r7, [r4, #16]
    2e5a:	6167      	str	r7, [r4, #20]
    2e5c:	61a7      	str	r7, [r4, #24]
    2e5e:	305c      	adds	r0, #92	; 0x5c
    2e60:	1c39      	adds	r1, r7, #0
    2e62:	2208      	movs	r2, #8
    2e64:	f7ff fcd1 	bl	280a <memset>
    2e68:	1c20      	adds	r0, r4, #0
    2e6a:	6367      	str	r7, [r4, #52]	; 0x34
    2e6c:	63a7      	str	r7, [r4, #56]	; 0x38
    2e6e:	64a7      	str	r7, [r4, #72]	; 0x48
    2e70:	64e7      	str	r7, [r4, #76]	; 0x4c
    2e72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2e74:	000032fc 	.word	0x000032fc

00002e78 <_fwalk_reent>:
    2e78:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    2e7a:	1c04      	adds	r4, r0, #0
    2e7c:	1c07      	adds	r7, r0, #0
    2e7e:	2600      	movs	r6, #0
    2e80:	9101      	str	r1, [sp, #4]
    2e82:	3448      	adds	r4, #72	; 0x48
    2e84:	2c00      	cmp	r4, #0
    2e86:	d016      	beq.n	2eb6 <_fwalk_reent+0x3e>
    2e88:	6863      	ldr	r3, [r4, #4]
    2e8a:	68a5      	ldr	r5, [r4, #8]
    2e8c:	9300      	str	r3, [sp, #0]
    2e8e:	9b00      	ldr	r3, [sp, #0]
    2e90:	3b01      	subs	r3, #1
    2e92:	9300      	str	r3, [sp, #0]
    2e94:	d40d      	bmi.n	2eb2 <_fwalk_reent+0x3a>
    2e96:	89ab      	ldrh	r3, [r5, #12]
    2e98:	2b01      	cmp	r3, #1
    2e9a:	d908      	bls.n	2eae <_fwalk_reent+0x36>
    2e9c:	220e      	movs	r2, #14
    2e9e:	5eab      	ldrsh	r3, [r5, r2]
    2ea0:	3301      	adds	r3, #1
    2ea2:	d004      	beq.n	2eae <_fwalk_reent+0x36>
    2ea4:	1c38      	adds	r0, r7, #0
    2ea6:	1c29      	adds	r1, r5, #0
    2ea8:	9b01      	ldr	r3, [sp, #4]
    2eaa:	4798      	blx	r3
    2eac:	4306      	orrs	r6, r0
    2eae:	3568      	adds	r5, #104	; 0x68
    2eb0:	e7ed      	b.n	2e8e <_fwalk_reent+0x16>
    2eb2:	6824      	ldr	r4, [r4, #0]
    2eb4:	e7e6      	b.n	2e84 <_fwalk_reent+0xc>
    2eb6:	1c30      	adds	r0, r6, #0
    2eb8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

00002ebc <__smakebuf_r>:
    2ebc:	b5f0      	push	{r4, r5, r6, r7, lr}
    2ebe:	898b      	ldrh	r3, [r1, #12]
    2ec0:	b091      	sub	sp, #68	; 0x44
    2ec2:	079b      	lsls	r3, r3, #30
    2ec4:	d506      	bpl.n	2ed4 <__smakebuf_r+0x18>
    2ec6:	1c0b      	adds	r3, r1, #0
    2ec8:	3347      	adds	r3, #71	; 0x47
    2eca:	600b      	str	r3, [r1, #0]
    2ecc:	610b      	str	r3, [r1, #16]
    2ece:	2301      	movs	r3, #1
    2ed0:	614b      	str	r3, [r1, #20]
    2ed2:	e045      	b.n	2f60 <__smakebuf_r+0xa4>
    2ed4:	1c0c      	adds	r4, r1, #0
    2ed6:	230e      	movs	r3, #14
    2ed8:	5ec9      	ldrsh	r1, [r1, r3]
    2eda:	1c06      	adds	r6, r0, #0
    2edc:	2900      	cmp	r1, #0
    2ede:	da04      	bge.n	2eea <__smakebuf_r+0x2e>
    2ee0:	2380      	movs	r3, #128	; 0x80
    2ee2:	89a5      	ldrh	r5, [r4, #12]
    2ee4:	401d      	ands	r5, r3
    2ee6:	d110      	bne.n	2f0a <__smakebuf_r+0x4e>
    2ee8:	e00c      	b.n	2f04 <__smakebuf_r+0x48>
    2eea:	aa01      	add	r2, sp, #4
    2eec:	f000 f96a 	bl	31c4 <_fstat_r>
    2ef0:	2800      	cmp	r0, #0
    2ef2:	dbf5      	blt.n	2ee0 <__smakebuf_r+0x24>
    2ef4:	23f0      	movs	r3, #240	; 0xf0
    2ef6:	9d02      	ldr	r5, [sp, #8]
    2ef8:	021b      	lsls	r3, r3, #8
    2efa:	401d      	ands	r5, r3
    2efc:	4b19      	ldr	r3, [pc, #100]	; (2f64 <__smakebuf_r+0xa8>)
    2efe:	18ed      	adds	r5, r5, r3
    2f00:	426b      	negs	r3, r5
    2f02:	415d      	adcs	r5, r3
    2f04:	2780      	movs	r7, #128	; 0x80
    2f06:	00ff      	lsls	r7, r7, #3
    2f08:	e001      	b.n	2f0e <__smakebuf_r+0x52>
    2f0a:	2500      	movs	r5, #0
    2f0c:	2740      	movs	r7, #64	; 0x40
    2f0e:	1c30      	adds	r0, r6, #0
    2f10:	1c39      	adds	r1, r7, #0
    2f12:	f000 f87b 	bl	300c <_malloc_r>
    2f16:	2800      	cmp	r0, #0
    2f18:	d10c      	bne.n	2f34 <__smakebuf_r+0x78>
    2f1a:	89a3      	ldrh	r3, [r4, #12]
    2f1c:	059a      	lsls	r2, r3, #22
    2f1e:	d41f      	bmi.n	2f60 <__smakebuf_r+0xa4>
    2f20:	2202      	movs	r2, #2
    2f22:	4313      	orrs	r3, r2
    2f24:	81a3      	strh	r3, [r4, #12]
    2f26:	1c23      	adds	r3, r4, #0
    2f28:	3347      	adds	r3, #71	; 0x47
    2f2a:	6023      	str	r3, [r4, #0]
    2f2c:	6123      	str	r3, [r4, #16]
    2f2e:	2301      	movs	r3, #1
    2f30:	6163      	str	r3, [r4, #20]
    2f32:	e015      	b.n	2f60 <__smakebuf_r+0xa4>
    2f34:	2280      	movs	r2, #128	; 0x80
    2f36:	4b0c      	ldr	r3, [pc, #48]	; (2f68 <__smakebuf_r+0xac>)
    2f38:	62b3      	str	r3, [r6, #40]	; 0x28
    2f3a:	89a3      	ldrh	r3, [r4, #12]
    2f3c:	6020      	str	r0, [r4, #0]
    2f3e:	4313      	orrs	r3, r2
    2f40:	81a3      	strh	r3, [r4, #12]
    2f42:	6120      	str	r0, [r4, #16]
    2f44:	6167      	str	r7, [r4, #20]
    2f46:	2d00      	cmp	r5, #0
    2f48:	d00a      	beq.n	2f60 <__smakebuf_r+0xa4>
    2f4a:	230e      	movs	r3, #14
    2f4c:	5ee1      	ldrsh	r1, [r4, r3]
    2f4e:	1c30      	adds	r0, r6, #0
    2f50:	f000 f94a 	bl	31e8 <_isatty_r>
    2f54:	2800      	cmp	r0, #0
    2f56:	d003      	beq.n	2f60 <__smakebuf_r+0xa4>
    2f58:	2201      	movs	r2, #1
    2f5a:	89a3      	ldrh	r3, [r4, #12]
    2f5c:	4313      	orrs	r3, r2
    2f5e:	81a3      	strh	r3, [r4, #12]
    2f60:	b011      	add	sp, #68	; 0x44
    2f62:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2f64:	ffffe000 	.word	0xffffe000
    2f68:	00002d15 	.word	0x00002d15

00002f6c <malloc>:
    2f6c:	b508      	push	{r3, lr}
    2f6e:	4b03      	ldr	r3, [pc, #12]	; (2f7c <malloc+0x10>)
    2f70:	1c01      	adds	r1, r0, #0
    2f72:	6818      	ldr	r0, [r3, #0]
    2f74:	f000 f84a 	bl	300c <_malloc_r>
    2f78:	bd08      	pop	{r3, pc}
    2f7a:	46c0      	nop			; (mov r8, r8)
    2f7c:	20000068 	.word	0x20000068

00002f80 <_free_r>:
    2f80:	b530      	push	{r4, r5, lr}
    2f82:	2900      	cmp	r1, #0
    2f84:	d03e      	beq.n	3004 <_free_r+0x84>
    2f86:	3904      	subs	r1, #4
    2f88:	680b      	ldr	r3, [r1, #0]
    2f8a:	2b00      	cmp	r3, #0
    2f8c:	da00      	bge.n	2f90 <_free_r+0x10>
    2f8e:	18c9      	adds	r1, r1, r3
    2f90:	4a1d      	ldr	r2, [pc, #116]	; (3008 <_free_r+0x88>)
    2f92:	6813      	ldr	r3, [r2, #0]
    2f94:	1c14      	adds	r4, r2, #0
    2f96:	2b00      	cmp	r3, #0
    2f98:	d102      	bne.n	2fa0 <_free_r+0x20>
    2f9a:	604b      	str	r3, [r1, #4]
    2f9c:	6011      	str	r1, [r2, #0]
    2f9e:	e031      	b.n	3004 <_free_r+0x84>
    2fa0:	4299      	cmp	r1, r3
    2fa2:	d20d      	bcs.n	2fc0 <_free_r+0x40>
    2fa4:	6808      	ldr	r0, [r1, #0]
    2fa6:	180a      	adds	r2, r1, r0
    2fa8:	429a      	cmp	r2, r3
    2faa:	d103      	bne.n	2fb4 <_free_r+0x34>
    2fac:	6813      	ldr	r3, [r2, #0]
    2fae:	18c3      	adds	r3, r0, r3
    2fb0:	600b      	str	r3, [r1, #0]
    2fb2:	6853      	ldr	r3, [r2, #4]
    2fb4:	604b      	str	r3, [r1, #4]
    2fb6:	6021      	str	r1, [r4, #0]
    2fb8:	e024      	b.n	3004 <_free_r+0x84>
    2fba:	428a      	cmp	r2, r1
    2fbc:	d803      	bhi.n	2fc6 <_free_r+0x46>
    2fbe:	1c13      	adds	r3, r2, #0
    2fc0:	685a      	ldr	r2, [r3, #4]
    2fc2:	2a00      	cmp	r2, #0
    2fc4:	d1f9      	bne.n	2fba <_free_r+0x3a>
    2fc6:	681d      	ldr	r5, [r3, #0]
    2fc8:	195c      	adds	r4, r3, r5
    2fca:	428c      	cmp	r4, r1
    2fcc:	d10b      	bne.n	2fe6 <_free_r+0x66>
    2fce:	6809      	ldr	r1, [r1, #0]
    2fd0:	1869      	adds	r1, r5, r1
    2fd2:	1858      	adds	r0, r3, r1
    2fd4:	6019      	str	r1, [r3, #0]
    2fd6:	4290      	cmp	r0, r2
    2fd8:	d114      	bne.n	3004 <_free_r+0x84>
    2fda:	6810      	ldr	r0, [r2, #0]
    2fdc:	6852      	ldr	r2, [r2, #4]
    2fde:	1809      	adds	r1, r1, r0
    2fe0:	6019      	str	r1, [r3, #0]
    2fe2:	605a      	str	r2, [r3, #4]
    2fe4:	e00e      	b.n	3004 <_free_r+0x84>
    2fe6:	428c      	cmp	r4, r1
    2fe8:	d902      	bls.n	2ff0 <_free_r+0x70>
    2fea:	230c      	movs	r3, #12
    2fec:	6003      	str	r3, [r0, #0]
    2fee:	e009      	b.n	3004 <_free_r+0x84>
    2ff0:	6808      	ldr	r0, [r1, #0]
    2ff2:	180c      	adds	r4, r1, r0
    2ff4:	4294      	cmp	r4, r2
    2ff6:	d103      	bne.n	3000 <_free_r+0x80>
    2ff8:	6814      	ldr	r4, [r2, #0]
    2ffa:	6852      	ldr	r2, [r2, #4]
    2ffc:	1900      	adds	r0, r0, r4
    2ffe:	6008      	str	r0, [r1, #0]
    3000:	604a      	str	r2, [r1, #4]
    3002:	6059      	str	r1, [r3, #4]
    3004:	bd30      	pop	{r4, r5, pc}
    3006:	46c0      	nop			; (mov r8, r8)
    3008:	200001a0 	.word	0x200001a0

0000300c <_malloc_r>:
    300c:	2303      	movs	r3, #3
    300e:	b570      	push	{r4, r5, r6, lr}
    3010:	1ccc      	adds	r4, r1, #3
    3012:	439c      	bics	r4, r3
    3014:	3408      	adds	r4, #8
    3016:	1c05      	adds	r5, r0, #0
    3018:	2c0c      	cmp	r4, #12
    301a:	d201      	bcs.n	3020 <_malloc_r+0x14>
    301c:	240c      	movs	r4, #12
    301e:	e005      	b.n	302c <_malloc_r+0x20>
    3020:	2c00      	cmp	r4, #0
    3022:	da03      	bge.n	302c <_malloc_r+0x20>
    3024:	230c      	movs	r3, #12
    3026:	2000      	movs	r0, #0
    3028:	602b      	str	r3, [r5, #0]
    302a:	e042      	b.n	30b2 <_malloc_r+0xa6>
    302c:	428c      	cmp	r4, r1
    302e:	d3f9      	bcc.n	3024 <_malloc_r+0x18>
    3030:	4a20      	ldr	r2, [pc, #128]	; (30b4 <_malloc_r+0xa8>)
    3032:	6813      	ldr	r3, [r2, #0]
    3034:	1c10      	adds	r0, r2, #0
    3036:	1c19      	adds	r1, r3, #0
    3038:	2900      	cmp	r1, #0
    303a:	d013      	beq.n	3064 <_malloc_r+0x58>
    303c:	680a      	ldr	r2, [r1, #0]
    303e:	1b12      	subs	r2, r2, r4
    3040:	d40d      	bmi.n	305e <_malloc_r+0x52>
    3042:	2a0b      	cmp	r2, #11
    3044:	d902      	bls.n	304c <_malloc_r+0x40>
    3046:	600a      	str	r2, [r1, #0]
    3048:	188b      	adds	r3, r1, r2
    304a:	e01f      	b.n	308c <_malloc_r+0x80>
    304c:	428b      	cmp	r3, r1
    304e:	d102      	bne.n	3056 <_malloc_r+0x4a>
    3050:	685a      	ldr	r2, [r3, #4]
    3052:	6002      	str	r2, [r0, #0]
    3054:	e01b      	b.n	308e <_malloc_r+0x82>
    3056:	684a      	ldr	r2, [r1, #4]
    3058:	605a      	str	r2, [r3, #4]
    305a:	1c0b      	adds	r3, r1, #0
    305c:	e017      	b.n	308e <_malloc_r+0x82>
    305e:	1c0b      	adds	r3, r1, #0
    3060:	6849      	ldr	r1, [r1, #4]
    3062:	e7e9      	b.n	3038 <_malloc_r+0x2c>
    3064:	4e14      	ldr	r6, [pc, #80]	; (30b8 <_malloc_r+0xac>)
    3066:	6833      	ldr	r3, [r6, #0]
    3068:	2b00      	cmp	r3, #0
    306a:	d103      	bne.n	3074 <_malloc_r+0x68>
    306c:	1c28      	adds	r0, r5, #0
    306e:	f000 f825 	bl	30bc <_sbrk_r>
    3072:	6030      	str	r0, [r6, #0]
    3074:	1c28      	adds	r0, r5, #0
    3076:	1c21      	adds	r1, r4, #0
    3078:	f000 f820 	bl	30bc <_sbrk_r>
    307c:	1c03      	adds	r3, r0, #0
    307e:	1c42      	adds	r2, r0, #1
    3080:	d0d0      	beq.n	3024 <_malloc_r+0x18>
    3082:	2203      	movs	r2, #3
    3084:	1cc6      	adds	r6, r0, #3
    3086:	4396      	bics	r6, r2
    3088:	4286      	cmp	r6, r0
    308a:	d10a      	bne.n	30a2 <_malloc_r+0x96>
    308c:	601c      	str	r4, [r3, #0]
    308e:	1c18      	adds	r0, r3, #0
    3090:	2107      	movs	r1, #7
    3092:	300b      	adds	r0, #11
    3094:	1d1a      	adds	r2, r3, #4
    3096:	4388      	bics	r0, r1
    3098:	1a82      	subs	r2, r0, r2
    309a:	d00a      	beq.n	30b2 <_malloc_r+0xa6>
    309c:	4251      	negs	r1, r2
    309e:	5099      	str	r1, [r3, r2]
    30a0:	e007      	b.n	30b2 <_malloc_r+0xa6>
    30a2:	1a31      	subs	r1, r6, r0
    30a4:	1c28      	adds	r0, r5, #0
    30a6:	f000 f809 	bl	30bc <_sbrk_r>
    30aa:	1c43      	adds	r3, r0, #1
    30ac:	d0ba      	beq.n	3024 <_malloc_r+0x18>
    30ae:	1c33      	adds	r3, r6, #0
    30b0:	e7ec      	b.n	308c <_malloc_r+0x80>
    30b2:	bd70      	pop	{r4, r5, r6, pc}
    30b4:	200001a0 	.word	0x200001a0
    30b8:	2000019c 	.word	0x2000019c

000030bc <_sbrk_r>:
    30bc:	b538      	push	{r3, r4, r5, lr}
    30be:	2300      	movs	r3, #0
    30c0:	4c06      	ldr	r4, [pc, #24]	; (30dc <_sbrk_r+0x20>)
    30c2:	1c05      	adds	r5, r0, #0
    30c4:	1c08      	adds	r0, r1, #0
    30c6:	6023      	str	r3, [r4, #0]
    30c8:	f7fe ffee 	bl	20a8 <_sbrk>
    30cc:	1c43      	adds	r3, r0, #1
    30ce:	d103      	bne.n	30d8 <_sbrk_r+0x1c>
    30d0:	6823      	ldr	r3, [r4, #0]
    30d2:	2b00      	cmp	r3, #0
    30d4:	d000      	beq.n	30d8 <_sbrk_r+0x1c>
    30d6:	602b      	str	r3, [r5, #0]
    30d8:	bd38      	pop	{r3, r4, r5, pc}
    30da:	46c0      	nop			; (mov r8, r8)
    30dc:	20000264 	.word	0x20000264

000030e0 <__sread>:
    30e0:	b538      	push	{r3, r4, r5, lr}
    30e2:	1c0c      	adds	r4, r1, #0
    30e4:	250e      	movs	r5, #14
    30e6:	5f49      	ldrsh	r1, [r1, r5]
    30e8:	f000 f8a4 	bl	3234 <_read_r>
    30ec:	2800      	cmp	r0, #0
    30ee:	db03      	blt.n	30f8 <__sread+0x18>
    30f0:	6d63      	ldr	r3, [r4, #84]	; 0x54
    30f2:	181b      	adds	r3, r3, r0
    30f4:	6563      	str	r3, [r4, #84]	; 0x54
    30f6:	e003      	b.n	3100 <__sread+0x20>
    30f8:	89a2      	ldrh	r2, [r4, #12]
    30fa:	4b02      	ldr	r3, [pc, #8]	; (3104 <__sread+0x24>)
    30fc:	4013      	ands	r3, r2
    30fe:	81a3      	strh	r3, [r4, #12]
    3100:	bd38      	pop	{r3, r4, r5, pc}
    3102:	46c0      	nop			; (mov r8, r8)
    3104:	ffffefff 	.word	0xffffefff

00003108 <__swrite>:
    3108:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    310a:	1c1e      	adds	r6, r3, #0
    310c:	898b      	ldrh	r3, [r1, #12]
    310e:	1c05      	adds	r5, r0, #0
    3110:	1c0c      	adds	r4, r1, #0
    3112:	1c17      	adds	r7, r2, #0
    3114:	05db      	lsls	r3, r3, #23
    3116:	d505      	bpl.n	3124 <__swrite+0x1c>
    3118:	230e      	movs	r3, #14
    311a:	5ec9      	ldrsh	r1, [r1, r3]
    311c:	2200      	movs	r2, #0
    311e:	2302      	movs	r3, #2
    3120:	f000 f874 	bl	320c <_lseek_r>
    3124:	89a2      	ldrh	r2, [r4, #12]
    3126:	4b05      	ldr	r3, [pc, #20]	; (313c <__swrite+0x34>)
    3128:	1c28      	adds	r0, r5, #0
    312a:	4013      	ands	r3, r2
    312c:	81a3      	strh	r3, [r4, #12]
    312e:	1c3a      	adds	r2, r7, #0
    3130:	230e      	movs	r3, #14
    3132:	5ee1      	ldrsh	r1, [r4, r3]
    3134:	1c33      	adds	r3, r6, #0
    3136:	f000 f81f 	bl	3178 <_write_r>
    313a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    313c:	ffffefff 	.word	0xffffefff

00003140 <__sseek>:
    3140:	b538      	push	{r3, r4, r5, lr}
    3142:	1c0c      	adds	r4, r1, #0
    3144:	250e      	movs	r5, #14
    3146:	5f49      	ldrsh	r1, [r1, r5]
    3148:	f000 f860 	bl	320c <_lseek_r>
    314c:	89a3      	ldrh	r3, [r4, #12]
    314e:	1c42      	adds	r2, r0, #1
    3150:	d103      	bne.n	315a <__sseek+0x1a>
    3152:	4a05      	ldr	r2, [pc, #20]	; (3168 <__sseek+0x28>)
    3154:	4013      	ands	r3, r2
    3156:	81a3      	strh	r3, [r4, #12]
    3158:	e004      	b.n	3164 <__sseek+0x24>
    315a:	2280      	movs	r2, #128	; 0x80
    315c:	0152      	lsls	r2, r2, #5
    315e:	4313      	orrs	r3, r2
    3160:	81a3      	strh	r3, [r4, #12]
    3162:	6560      	str	r0, [r4, #84]	; 0x54
    3164:	bd38      	pop	{r3, r4, r5, pc}
    3166:	46c0      	nop			; (mov r8, r8)
    3168:	ffffefff 	.word	0xffffefff

0000316c <__sclose>:
    316c:	b508      	push	{r3, lr}
    316e:	230e      	movs	r3, #14
    3170:	5ec9      	ldrsh	r1, [r1, r3]
    3172:	f000 f815 	bl	31a0 <_close_r>
    3176:	bd08      	pop	{r3, pc}

00003178 <_write_r>:
    3178:	b538      	push	{r3, r4, r5, lr}
    317a:	1c05      	adds	r5, r0, #0
    317c:	2000      	movs	r0, #0
    317e:	4c07      	ldr	r4, [pc, #28]	; (319c <_write_r+0x24>)
    3180:	6020      	str	r0, [r4, #0]
    3182:	1c08      	adds	r0, r1, #0
    3184:	1c11      	adds	r1, r2, #0
    3186:	1c1a      	adds	r2, r3, #0
    3188:	f7fd f9f6 	bl	578 <_write>
    318c:	1c43      	adds	r3, r0, #1
    318e:	d103      	bne.n	3198 <_write_r+0x20>
    3190:	6823      	ldr	r3, [r4, #0]
    3192:	2b00      	cmp	r3, #0
    3194:	d000      	beq.n	3198 <_write_r+0x20>
    3196:	602b      	str	r3, [r5, #0]
    3198:	bd38      	pop	{r3, r4, r5, pc}
    319a:	46c0      	nop			; (mov r8, r8)
    319c:	20000264 	.word	0x20000264

000031a0 <_close_r>:
    31a0:	b538      	push	{r3, r4, r5, lr}
    31a2:	2300      	movs	r3, #0
    31a4:	4c06      	ldr	r4, [pc, #24]	; (31c0 <_close_r+0x20>)
    31a6:	1c05      	adds	r5, r0, #0
    31a8:	1c08      	adds	r0, r1, #0
    31aa:	6023      	str	r3, [r4, #0]
    31ac:	f7fe ff8a 	bl	20c4 <_close>
    31b0:	1c43      	adds	r3, r0, #1
    31b2:	d103      	bne.n	31bc <_close_r+0x1c>
    31b4:	6823      	ldr	r3, [r4, #0]
    31b6:	2b00      	cmp	r3, #0
    31b8:	d000      	beq.n	31bc <_close_r+0x1c>
    31ba:	602b      	str	r3, [r5, #0]
    31bc:	bd38      	pop	{r3, r4, r5, pc}
    31be:	46c0      	nop			; (mov r8, r8)
    31c0:	20000264 	.word	0x20000264

000031c4 <_fstat_r>:
    31c4:	b538      	push	{r3, r4, r5, lr}
    31c6:	2300      	movs	r3, #0
    31c8:	4c06      	ldr	r4, [pc, #24]	; (31e4 <_fstat_r+0x20>)
    31ca:	1c05      	adds	r5, r0, #0
    31cc:	1c08      	adds	r0, r1, #0
    31ce:	1c11      	adds	r1, r2, #0
    31d0:	6023      	str	r3, [r4, #0]
    31d2:	f7fe ff7b 	bl	20cc <_fstat>
    31d6:	1c43      	adds	r3, r0, #1
    31d8:	d103      	bne.n	31e2 <_fstat_r+0x1e>
    31da:	6823      	ldr	r3, [r4, #0]
    31dc:	2b00      	cmp	r3, #0
    31de:	d000      	beq.n	31e2 <_fstat_r+0x1e>
    31e0:	602b      	str	r3, [r5, #0]
    31e2:	bd38      	pop	{r3, r4, r5, pc}
    31e4:	20000264 	.word	0x20000264

000031e8 <_isatty_r>:
    31e8:	b538      	push	{r3, r4, r5, lr}
    31ea:	2300      	movs	r3, #0
    31ec:	4c06      	ldr	r4, [pc, #24]	; (3208 <_isatty_r+0x20>)
    31ee:	1c05      	adds	r5, r0, #0
    31f0:	1c08      	adds	r0, r1, #0
    31f2:	6023      	str	r3, [r4, #0]
    31f4:	f7fe ff70 	bl	20d8 <_isatty>
    31f8:	1c43      	adds	r3, r0, #1
    31fa:	d103      	bne.n	3204 <_isatty_r+0x1c>
    31fc:	6823      	ldr	r3, [r4, #0]
    31fe:	2b00      	cmp	r3, #0
    3200:	d000      	beq.n	3204 <_isatty_r+0x1c>
    3202:	602b      	str	r3, [r5, #0]
    3204:	bd38      	pop	{r3, r4, r5, pc}
    3206:	46c0      	nop			; (mov r8, r8)
    3208:	20000264 	.word	0x20000264

0000320c <_lseek_r>:
    320c:	b538      	push	{r3, r4, r5, lr}
    320e:	1c05      	adds	r5, r0, #0
    3210:	2000      	movs	r0, #0
    3212:	4c07      	ldr	r4, [pc, #28]	; (3230 <_lseek_r+0x24>)
    3214:	6020      	str	r0, [r4, #0]
    3216:	1c08      	adds	r0, r1, #0
    3218:	1c11      	adds	r1, r2, #0
    321a:	1c1a      	adds	r2, r3, #0
    321c:	f7fe ff5e 	bl	20dc <_lseek>
    3220:	1c43      	adds	r3, r0, #1
    3222:	d103      	bne.n	322c <_lseek_r+0x20>
    3224:	6823      	ldr	r3, [r4, #0]
    3226:	2b00      	cmp	r3, #0
    3228:	d000      	beq.n	322c <_lseek_r+0x20>
    322a:	602b      	str	r3, [r5, #0]
    322c:	bd38      	pop	{r3, r4, r5, pc}
    322e:	46c0      	nop			; (mov r8, r8)
    3230:	20000264 	.word	0x20000264

00003234 <_read_r>:
    3234:	b538      	push	{r3, r4, r5, lr}
    3236:	1c05      	adds	r5, r0, #0
    3238:	2000      	movs	r0, #0
    323a:	4c07      	ldr	r4, [pc, #28]	; (3258 <_read_r+0x24>)
    323c:	6020      	str	r0, [r4, #0]
    323e:	1c08      	adds	r0, r1, #0
    3240:	1c11      	adds	r1, r2, #0
    3242:	1c1a      	adds	r2, r3, #0
    3244:	f7fd f976 	bl	534 <_read>
    3248:	1c43      	adds	r3, r0, #1
    324a:	d103      	bne.n	3254 <_read_r+0x20>
    324c:	6823      	ldr	r3, [r4, #0]
    324e:	2b00      	cmp	r3, #0
    3250:	d000      	beq.n	3254 <_read_r+0x20>
    3252:	602b      	str	r3, [r5, #0]
    3254:	bd38      	pop	{r3, r4, r5, pc}
    3256:	46c0      	nop			; (mov r8, r8)
    3258:	20000264 	.word	0x20000264
    325c:	42000800 	.word	0x42000800
    3260:	42000c00 	.word	0x42000c00
    3264:	42001000 	.word	0x42001000
    3268:	42001400 	.word	0x42001400
    326c:	42001800 	.word	0x42001800
    3270:	42001c00 	.word	0x42001c00
    3274:	0c0b0a09 	.word	0x0c0b0a09
    3278:	00000e0d 	.word	0x00000e0d
    327c:	000019a8 	.word	0x000019a8
    3280:	000019c0 	.word	0x000019c0
    3284:	000019c0 	.word	0x000019c0
    3288:	0000196e 	.word	0x0000196e
    328c:	0000196e 	.word	0x0000196e
    3290:	00001974 	.word	0x00001974
    3294:	0000197a 	.word	0x0000197a
    3298:	0000198a 	.word	0x0000198a
    329c:	000019ae 	.word	0x000019ae
    32a0:	00001bc8 	.word	0x00001bc8
    32a4:	00001bd6 	.word	0x00001bd6
    32a8:	00001bd6 	.word	0x00001bd6
    32ac:	00001b52 	.word	0x00001b52
    32b0:	00001b56 	.word	0x00001b56
    32b4:	00001b64 	.word	0x00001b64
    32b8:	00001b72 	.word	0x00001b72
    32bc:	00001b80 	.word	0x00001b80
    32c0:	00001bb8 	.word	0x00001bb8
    32c4:	65746e49 	.word	0x65746e49
    32c8:	70757272 	.word	0x70757272
    32cc:	202d2074 	.word	0x202d2074
    32d0:	616d6553 	.word	0x616d6553
    32d4:	726f6870 	.word	0x726f6870
    32d8:	65672065 	.word	0x65672065
    32dc:	6172656e 	.word	0x6172656e
    32e0:	2e646574 	.word	0x2e646574
    32e4:	0000000d 	.word	0x0000000d
    32e8:	474f5250 	.word	0x474f5250
    32ec:	204d4152 	.word	0x204d4152
    32f0:	52415453 	.word	0x52415453
    32f4:	000d2154 	.word	0x000d2154
    32f8:	00000043 	.word	0x00000043

000032fc <_global_impure_ptr>:
    32fc:	20000008                                ... 

00003300 <__sf_fake_stdin>:
	...

00003320 <__sf_fake_stdout>:
	...

00003340 <__sf_fake_stderr>:
	...

00003360 <_init>:
    3360:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3362:	46c0      	nop			; (mov r8, r8)
    3364:	bcf8      	pop	{r3, r4, r5, r6, r7}
    3366:	bc08      	pop	{r3}
    3368:	469e      	mov	lr, r3
    336a:	4770      	bx	lr

0000336c <__init_array_start>:
    336c:	000000dd 	.word	0x000000dd

00003370 <_fini>:
    3370:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3372:	46c0      	nop			; (mov r8, r8)
    3374:	bcf8      	pop	{r3, r4, r5, r6, r7}
    3376:	bc08      	pop	{r3}
    3378:	469e      	mov	lr, r3
    337a:	4770      	bx	lr

0000337c <__fini_array_start>:
    337c:	000000b5 	.word	0x000000b5
